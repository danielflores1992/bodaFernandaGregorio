var Bg = e => {
  throw TypeError(e)
};
var sd = (e, t, n) => t.has(e) || Bg("Cannot " + n);
var C = (e, t, n) => (sd(e, t, "read from private field"), n ? n.call(e) : t.get(e)),
  z = (e, t, n) => t.has(e) ? Bg("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n),
  L = (e, t, n, r) => (sd(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n),
  te = (e, t, n) => (sd(e, t, "access private method"), n);
var vl = (e, t, n, r) => ({
  set _(s) {
      L(e, t, s, n)
  },
  get _() {
      return C(e, t, r)
  }
});

function sk(e, t) {
  for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
          for (const s in r)
              if (s !== "default" && !(s in e)) {
                  const i = Object.getOwnPropertyDescriptor(r, s);
                  i && Object.defineProperty(e, s, i.get ? i : {
                      enumerable: !0,
                      get: () => r[s]
                  })
              }
      }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
  }))
}(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
  new MutationObserver(s => {
      for (const i of s)
          if (i.type === "childList")
              for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
  }).observe(document, {
      childList: !0,
      subtree: !0
  });

  function n(s) {
      const i = {};
      return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
  }

  function r(s) {
      if (s.ep) return;
      s.ep = !0;
      const i = n(s);
      fetch(s.href, i)
  }
})();

function Kw(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var qw = {
      exports: {}
  },
  hu = {},
  Gw = {
      exports: {}
  },
  se = {};
/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Za = Symbol.for("react.element"),
  ik = Symbol.for("react.portal"),
  ok = Symbol.for("react.fragment"),
  ak = Symbol.for("react.strict_mode"),
  lk = Symbol.for("react.profiler"),
  ck = Symbol.for("react.provider"),
  uk = Symbol.for("react.context"),
  dk = Symbol.for("react.forward_ref"),
  hk = Symbol.for("react.suspense"),
  fk = Symbol.for("react.memo"),
  pk = Symbol.for("react.lazy"),
  zg = Symbol.iterator;

function mk(e) {
  return e === null || typeof e != "object" ? null : (e = zg && e[zg] || e["@@iterator"], typeof e == "function" ? e : null)
}
var Qw = {
      isMounted: function() {
          return !1
      },
      enqueueForceUpdate: function() {},
      enqueueReplaceState: function() {},
      enqueueSetState: function() {}
  },
  Yw = Object.assign,
  Jw = {};

function xo(e, t, n) {
  this.props = e, this.context = t, this.refs = Jw, this.updater = n || Qw
}
xo.prototype.isReactComponent = {};
xo.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState")
};
xo.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate")
};

function Xw() {}
Xw.prototype = xo.prototype;

function bp(e, t, n) {
  this.props = e, this.context = t, this.refs = Jw, this.updater = n || Qw
}
var Sp = bp.prototype = new Xw;
Sp.constructor = bp;
Yw(Sp, xo.prototype);
Sp.isPureReactComponent = !0;
var Wg = Array.isArray,
  Zw = Object.prototype.hasOwnProperty,
  _p = {
      current: null
  },
  ex = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
  };

function tx(e, t, n) {
  var r, s = {},
      i = null,
      o = null;
  if (t != null)
      for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (i = "" + t.key), t) Zw.call(t, r) && !ex.hasOwnProperty(r) && (s[r] = t[r]);
  var a = arguments.length - 2;
  if (a === 1) s.children = n;
  else if (1 < a) {
      for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
      s.children = l
  }
  if (e && e.defaultProps)
      for (r in a = e.defaultProps, a) s[r] === void 0 && (s[r] = a[r]);
  return {
      $$typeof: Za,
      type: e,
      key: i,
      ref: o,
      props: s,
      _owner: _p.current
  }
}

function gk(e, t) {
  return {
      $$typeof: Za,
      type: e.type,
      key: t,
      ref: e.ref,
      props: e.props,
      _owner: e._owner
  }
}

function Ep(e) {
  return typeof e == "object" && e !== null && e.$$typeof === Za
}

function yk(e) {
  var t = {
      "=": "=0",
      ":": "=2"
  };
  return "$" + e.replace(/[=:]/g, function(n) {
      return t[n]
  })
}
var Hg = /\/+/g;

function id(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? yk("" + e.key) : t.toString(36)
}

function Zl(e, t, n, r, s) {
  var i = typeof e;
  (i === "undefined" || i === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else switch (i) {
      case "string":
      case "number":
          o = !0;
          break;
      case "object":
          switch (e.$$typeof) {
              case Za:
              case ik:
                  o = !0
          }
  }
  if (o) return o = e, s = s(o), e = r === "" ? "." + id(o, 0) : r, Wg(s) ? (n = "", e != null && (n = e.replace(Hg, "$&/") + "/"), Zl(s, t, n, "", function(c) {
      return c
  })) : s != null && (Ep(s) && (s = gk(s, n + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(Hg, "$&/") + "/") + e)), t.push(s)), 1;
  if (o = 0, r = r === "" ? "." : r + ":", Wg(e))
      for (var a = 0; a < e.length; a++) {
          i = e[a];
          var l = r + id(i, a);
          o += Zl(i, t, n, l, s)
      } else if (l = mk(e), typeof l == "function")
          for (e = l.call(e), a = 0; !(i = e.next()).done;) i = i.value, l = r + id(i, a++), o += Zl(i, t, n, l, s);
      else if (i === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return o
}

function wl(e, t, n) {
  if (e == null) return e;
  var r = [],
      s = 0;
  return Zl(e, r, "", "", function(i) {
      return t.call(n, i, s++)
  }), r
}

function vk(e) {
  if (e._status === -1) {
      var t = e._result;
      t = t(), t.then(function(n) {
          (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n)
      }, function(n) {
          (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n)
      }), e._status === -1 && (e._status = 0, e._result = t)
  }
  if (e._status === 1) return e._result.default;
  throw e._result
}
var ut = {
      current: null
  },
  ec = {
      transition: null
  },
  wk = {
      ReactCurrentDispatcher: ut,
      ReactCurrentBatchConfig: ec,
      ReactCurrentOwner: _p
  };

function nx() {
  throw Error("act(...) is not supported in production builds of React.")
}
se.Children = {
  map: wl,
  forEach: function(e, t, n) {
      wl(e, function() {
          t.apply(this, arguments)
      }, n)
  },
  count: function(e) {
      var t = 0;
      return wl(e, function() {
          t++
      }), t
  },
  toArray: function(e) {
      return wl(e, function(t) {
          return t
      }) || []
  },
  only: function(e) {
      if (!Ep(e)) throw Error("React.Children.only expected to receive a single React element child.");
      return e
  }
};
se.Component = xo;
se.Fragment = ok;
se.Profiler = lk;
se.PureComponent = bp;
se.StrictMode = ak;
se.Suspense = hk;
se.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = wk;
se.act = nx;
se.cloneElement = function(e, t, n) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var r = Yw({}, e.props),
      s = e.key,
      i = e.ref,
      o = e._owner;
  if (t != null) {
      if (t.ref !== void 0 && (i = t.ref, o = _p.current), t.key !== void 0 && (s = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
      for (l in t) Zw.call(t, l) && !ex.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
      a = Array(l);
      for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
      r.children = a
  }
  return {
      $$typeof: Za,
      type: e.type,
      key: s,
      ref: i,
      props: r,
      _owner: o
  }
};
se.createContext = function(e) {
  return e = {
      $$typeof: uk,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
  }, e.Provider = {
      $$typeof: ck,
      _context: e
  }, e.Consumer = e
};
se.createElement = tx;
se.createFactory = function(e) {
  var t = tx.bind(null, e);
  return t.type = e, t
};
se.createRef = function() {
  return {
      current: null
  }
};
se.forwardRef = function(e) {
  return {
      $$typeof: dk,
      render: e
  }
};
se.isValidElement = Ep;
se.lazy = function(e) {
  return {
      $$typeof: pk,
      _payload: {
          _status: -1,
          _result: e
      },
      _init: vk
  }
};
se.memo = function(e, t) {
  return {
      $$typeof: fk,
      type: e,
      compare: t === void 0 ? null : t
  }
};
se.startTransition = function(e) {
  var t = ec.transition;
  ec.transition = {};
  try {
      e()
  } finally {
      ec.transition = t
  }
};
se.unstable_act = nx;
se.useCallback = function(e, t) {
  return ut.current.useCallback(e, t)
};
se.useContext = function(e) {
  return ut.current.useContext(e)
};
se.useDebugValue = function() {};
se.useDeferredValue = function(e) {
  return ut.current.useDeferredValue(e)
};
se.useEffect = function(e, t) {
  return ut.current.useEffect(e, t)
};
se.useId = function() {
  return ut.current.useId()
};
se.useImperativeHandle = function(e, t, n) {
  return ut.current.useImperativeHandle(e, t, n)
};
se.useInsertionEffect = function(e, t) {
  return ut.current.useInsertionEffect(e, t)
};
se.useLayoutEffect = function(e, t) {
  return ut.current.useLayoutEffect(e, t)
};
se.useMemo = function(e, t) {
  return ut.current.useMemo(e, t)
};
se.useReducer = function(e, t, n) {
  return ut.current.useReducer(e, t, n)
};
se.useRef = function(e) {
  return ut.current.useRef(e)
};
se.useState = function(e) {
  return ut.current.useState(e)
};
se.useSyncExternalStore = function(e, t, n) {
  return ut.current.useSyncExternalStore(e, t, n)
};
se.useTransition = function() {
  return ut.current.useTransition()
};
se.version = "18.3.1";
Gw.exports = se;
var g = Gw.exports;
const j = Kw(g),
  Cp = sk({
      __proto__: null,
      default: j
  }, [g]);
/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var xk = g,
  bk = Symbol.for("react.element"),
  Sk = Symbol.for("react.fragment"),
  _k = Object.prototype.hasOwnProperty,
  Ek = xk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Ck = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
  };

function rx(e, t, n) {
  var r, s = {},
      i = null,
      o = null;
  n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), t.ref !== void 0 && (o = t.ref);
  for (r in t) _k.call(t, r) && !Ck.hasOwnProperty(r) && (s[r] = t[r]);
  if (e && e.defaultProps)
      for (r in t = e.defaultProps, t) s[r] === void 0 && (s[r] = t[r]);
  return {
      $$typeof: bk,
      type: e,
      key: i,
      ref: o,
      props: s,
      _owner: Ek.current
  }
}
hu.Fragment = Sk;
hu.jsx = rx;
hu.jsxs = rx;
qw.exports = hu;
var p = qw.exports,
  sx = {
      exports: {}
  },
  jt = {},
  ix = {
      exports: {}
  },
  ox = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(e) {
  function t(R, N) {
      var M = R.length;
      R.push(N);
      e: for (; 0 < M;) {
          var Q = M - 1 >>> 1,
              W = R[Q];
          if (0 < s(W, N)) R[Q] = N, R[M] = W, M = Q;
          else break e
      }
  }

  function n(R) {
      return R.length === 0 ? null : R[0]
  }

  function r(R) {
      if (R.length === 0) return null;
      var N = R[0],
          M = R.pop();
      if (M !== N) {
          R[0] = M;
          e: for (var Q = 0, W = R.length, re = W >>> 1; Q < re;) {
              var ie = 2 * (Q + 1) - 1,
                  Oe = R[ie],
                  Je = ie + 1,
                  ue = R[Je];
              if (0 > s(Oe, M)) Je < W && 0 > s(ue, Oe) ? (R[Q] = ue, R[Je] = M, Q = Je) : (R[Q] = Oe, R[ie] = M, Q = ie);
              else if (Je < W && 0 > s(ue, M)) R[Q] = ue, R[Je] = M, Q = Je;
              else break e
          }
      }
      return N
  }

  function s(R, N) {
      var M = R.sortIndex - N.sortIndex;
      return M !== 0 ? M : R.id - N.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
      var i = performance;
      e.unstable_now = function() {
          return i.now()
      }
  } else {
      var o = Date,
          a = o.now();
      e.unstable_now = function() {
          return o.now() - a
      }
  }
  var l = [],
      c = [],
      u = 1,
      d = null,
      h = 3,
      f = !1,
      x = !1,
      m = !1,
      b = typeof setTimeout == "function" ? setTimeout : null,
      v = typeof clearTimeout == "function" ? clearTimeout : null,
      y = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

  function w(R) {
      for (var N = n(c); N !== null;) {
          if (N.callback === null) r(c);
          else if (N.startTime <= R) r(c), N.sortIndex = N.expirationTime, t(l, N);
          else break;
          N = n(c)
      }
  }

  function S(R) {
      if (m = !1, w(R), !x)
          if (n(l) !== null) x = !0, B(_);
          else {
              var N = n(c);
              N !== null && U(S, N.startTime - R)
          }
  }

  function _(R, N) {
      x = !1, m && (m = !1, v(k), k = -1), f = !0;
      var M = h;
      try {
          for (w(N), d = n(l); d !== null && (!(d.expirationTime > N) || R && !$());) {
              var Q = d.callback;
              if (typeof Q == "function") {
                  d.callback = null, h = d.priorityLevel;
                  var W = Q(d.expirationTime <= N);
                  N = e.unstable_now(), typeof W == "function" ? d.callback = W : d === n(l) && r(l), w(N)
              } else r(l);
              d = n(l)
          }
          if (d !== null) var re = !0;
          else {
              var ie = n(c);
              ie !== null && U(S, ie.startTime - N), re = !1
          }
          return re
      } finally {
          d = null, h = M, f = !1
      }
  }
  var E = !1,
      T = null,
      k = -1,
      P = 5,
      A = -1;

  function $() {
      return !(e.unstable_now() - A < P)
  }

  function I() {
      if (T !== null) {
          var R = e.unstable_now();
          A = R;
          var N = !0;
          try {
              N = T(!0, R)
          } finally {
              N ? G() : (E = !1, T = null)
          }
      } else E = !1
  }
  var G;
  if (typeof y == "function") G = function() {
      y(I)
  };
  else if (typeof MessageChannel < "u") {
      var D = new MessageChannel,
          X = D.port2;
      D.port1.onmessage = I, G = function() {
          X.postMessage(null)
      }
  } else G = function() {
      b(I, 0)
  };

  function B(R) {
      T = R, E || (E = !0, G())
  }

  function U(R, N) {
      k = b(function() {
          R(e.unstable_now())
      }, N)
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(R) {
      R.callback = null
  }, e.unstable_continueExecution = function() {
      x || f || (x = !0, B(_))
  }, e.unstable_forceFrameRate = function(R) {
      0 > R || 125 < R ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < R ? Math.floor(1e3 / R) : 5
  }, e.unstable_getCurrentPriorityLevel = function() {
      return h
  }, e.unstable_getFirstCallbackNode = function() {
      return n(l)
  }, e.unstable_next = function(R) {
      switch (h) {
          case 1:
          case 2:
          case 3:
              var N = 3;
              break;
          default:
              N = h
      }
      var M = h;
      h = N;
      try {
          return R()
      } finally {
          h = M
      }
  }, e.unstable_pauseExecution = function() {}, e.unstable_requestPaint = function() {}, e.unstable_runWithPriority = function(R, N) {
      switch (R) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
              break;
          default:
              R = 3
      }
      var M = h;
      h = R;
      try {
          return N()
      } finally {
          h = M
      }
  }, e.unstable_scheduleCallback = function(R, N, M) {
      var Q = e.unstable_now();
      switch (typeof M == "object" && M !== null ? (M = M.delay, M = typeof M == "number" && 0 < M ? Q + M : Q) : M = Q, R) {
          case 1:
              var W = -1;
              break;
          case 2:
              W = 250;
              break;
          case 5:
              W = 1073741823;
              break;
          case 4:
              W = 1e4;
              break;
          default:
              W = 5e3
      }
      return W = M + W, R = {
          id: u++,
          callback: N,
          priorityLevel: R,
          startTime: M,
          expirationTime: W,
          sortIndex: -1
      }, M > Q ? (R.sortIndex = M, t(c, R), n(l) === null && R === n(c) && (m ? (v(k), k = -1) : m = !0, U(S, M - Q))) : (R.sortIndex = W, t(l, R), x || f || (x = !0, B(_))), R
  }, e.unstable_shouldYield = $, e.unstable_wrapCallback = function(R) {
      var N = h;
      return function() {
          var M = h;
          h = N;
          try {
              return R.apply(this, arguments)
          } finally {
              h = M
          }
      }
  }
})(ox);
ix.exports = ox;
var Tk = ix.exports;
/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var kk = g,
  Nt = Tk;

function O(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var ax = new Set,
  ma = {};

function Ys(e, t) {
  lo(e, t), lo(e + "Capture", t)
}

function lo(e, t) {
  for (ma[e] = t, e = 0; e < t.length; e++) ax.add(t[e])
}
var Kn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
  yh = Object.prototype.hasOwnProperty,
  Rk = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Kg = {},
  qg = {};

function Pk(e) {
  return yh.call(qg, e) ? !0 : yh.call(Kg, e) ? !1 : Rk.test(e) ? qg[e] = !0 : (Kg[e] = !0, !1)
}

function Ak(e, t, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
      case "function":
      case "symbol":
          return !0;
      case "boolean":
          return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
      default:
          return !1
  }
}

function Nk(e, t, n, r) {
  if (t === null || typeof t > "u" || Ak(e, t, n, r)) return !0;
  if (r) return !1;
  if (n !== null) switch (n.type) {
      case 3:
          return !t;
      case 4:
          return t === !1;
      case 5:
          return isNaN(t);
      case 6:
          return isNaN(t) || 1 > t
  }
  return !1
}

function dt(e, t, n, r, s, i, o) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = s, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = o
}
var Ye = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
  Ye[e] = new dt(e, 0, !1, e, null, !1, !1)
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function(e) {
  var t = e[0];
  Ye[t] = new dt(t, 1, !1, e[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  Ye[e] = new dt(e, 2, !1, e.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  Ye[e] = new dt(e, 2, !1, e, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
  Ye[e] = new dt(e, 3, !1, e.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
  Ye[e] = new dt(e, 3, !0, e, null, !1, !1)
});
["capture", "download"].forEach(function(e) {
  Ye[e] = new dt(e, 4, !1, e, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
  Ye[e] = new dt(e, 6, !1, e, null, !1, !1)
});
["rowSpan", "start"].forEach(function(e) {
  Ye[e] = new dt(e, 5, !1, e.toLowerCase(), null, !1, !1)
});
var Tp = /[\-:]([a-z])/g;

function kp(e) {
  return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
  var t = e.replace(Tp, kp);
  Ye[t] = new dt(t, 1, !1, e, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
  var t = e.replace(Tp, kp);
  Ye[t] = new dt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
  var t = e.replace(Tp, kp);
  Ye[t] = new dt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  Ye[e] = new dt(e, 1, !1, e.toLowerCase(), null, !1, !1)
});
Ye.xlinkHref = new dt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
  Ye[e] = new dt(e, 1, !1, e.toLowerCase(), null, !0, !0)
});

function Rp(e, t, n, r) {
  var s = Ye.hasOwnProperty(t) ? Ye[t] : null;
  (s !== null ? s.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Nk(t, n, s, r) && (n = null), r || s === null ? Pk(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : s.mustUseProperty ? e[s.propertyName] = n === null ? s.type === 3 ? !1 : "" : n : (t = s.attributeName, r = s.attributeNamespace, n === null ? e.removeAttribute(t) : (s = s.type, n = s === 3 || s === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var er = kk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  xl = Symbol.for("react.element"),
  wi = Symbol.for("react.portal"),
  xi = Symbol.for("react.fragment"),
  Pp = Symbol.for("react.strict_mode"),
  vh = Symbol.for("react.profiler"),
  lx = Symbol.for("react.provider"),
  cx = Symbol.for("react.context"),
  Ap = Symbol.for("react.forward_ref"),
  wh = Symbol.for("react.suspense"),
  xh = Symbol.for("react.suspense_list"),
  Np = Symbol.for("react.memo"),
  vr = Symbol.for("react.lazy"),
  ux = Symbol.for("react.offscreen"),
  Gg = Symbol.iterator;

function Io(e) {
  return e === null || typeof e != "object" ? null : (e = Gg && e[Gg] || e["@@iterator"], typeof e == "function" ? e : null)
}
var ke = Object.assign,
  od;

function Ho(e) {
  if (od === void 0) try {
      throw Error()
  } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      od = t && t[1] || ""
  }
  return `
` + od + e
}
var ad = !1;

function ld(e, t) {
  if (!e || ad) return "";
  ad = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
      if (t)
          if (t = function() {
                  throw Error()
              }, Object.defineProperty(t.prototype, "props", {
                  set: function() {
                      throw Error()
                  }
              }), typeof Reflect == "object" && Reflect.construct) {
              try {
                  Reflect.construct(t, [])
              } catch (c) {
                  var r = c
              }
              Reflect.construct(e, [], t)
          } else {
              try {
                  t.call()
              } catch (c) {
                  r = c
              }
              e.call(t.prototype)
          }
      else {
          try {
              throw Error()
          } catch (c) {
              r = c
          }
          e()
      }
  } catch (c) {
      if (c && r && typeof c.stack == "string") {
          for (var s = c.stack.split(`
`), i = r.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a];) a--;
          for (; 1 <= o && 0 <= a; o--, a--)
              if (s[o] !== i[a]) {
                  if (o !== 1 || a !== 1)
                      do
                          if (o--, a--, 0 > a || s[o] !== i[a]) {
                              var l = `
` + s[o].replace(" at new ", " at ");
                              return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                          } while (1 <= o && 0 <= a);
                  break
              }
      }
  } finally {
      ad = !1, Error.prepareStackTrace = n
  }
  return (e = e ? e.displayName || e.name : "") ? Ho(e) : ""
}

function jk(e) {
  switch (e.tag) {
      case 5:
          return Ho(e.type);
      case 16:
          return Ho("Lazy");
      case 13:
          return Ho("Suspense");
      case 19:
          return Ho("SuspenseList");
      case 0:
      case 2:
      case 15:
          return e = ld(e.type, !1), e;
      case 11:
          return e = ld(e.type.render, !1), e;
      case 1:
          return e = ld(e.type, !0), e;
      default:
          return ""
  }
}

function bh(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
      case xi:
          return "Fragment";
      case wi:
          return "Portal";
      case vh:
          return "Profiler";
      case Pp:
          return "StrictMode";
      case wh:
          return "Suspense";
      case xh:
          return "SuspenseList"
  }
  if (typeof e == "object") switch (e.$$typeof) {
      case cx:
          return (e.displayName || "Context") + ".Consumer";
      case lx:
          return (e._context.displayName || "Context") + ".Provider";
      case Ap:
          var t = e.render;
          return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
      case Np:
          return t = e.displayName || null, t !== null ? t : bh(e.type) || "Memo";
      case vr:
          t = e._payload, e = e._init;
          try {
              return bh(e(t))
          } catch {}
  }
  return null
}

function Ok(e) {
  var t = e.type;
  switch (e.tag) {
      case 24:
          return "Cache";
      case 9:
          return (t.displayName || "Context") + ".Consumer";
      case 10:
          return (t._context.displayName || "Context") + ".Provider";
      case 18:
          return "DehydratedFragment";
      case 11:
          return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
      case 7:
          return "Fragment";
      case 5:
          return t;
      case 4:
          return "Portal";
      case 3:
          return "Root";
      case 6:
          return "Text";
      case 16:
          return bh(t);
      case 8:
          return t === Pp ? "StrictMode" : "Mode";
      case 22:
          return "Offscreen";
      case 12:
          return "Profiler";
      case 21:
          return "Scope";
      case 13:
          return "Suspense";
      case 19:
          return "SuspenseList";
      case 25:
          return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
          if (typeof t == "function") return t.displayName || t.name || null;
          if (typeof t == "string") return t
  }
  return null
}

function Qr(e) {
  switch (typeof e) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
          return e;
      case "object":
          return e;
      default:
          return ""
  }
}

function dx(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}

function Ik(e) {
  var t = dx(e) ? "checked" : "value",
      n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
      r = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
      var s = n.get,
          i = n.set;
      return Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
              return s.call(this)
          },
          set: function(o) {
              r = "" + o, i.call(this, o)
          }
      }), Object.defineProperty(e, t, {
          enumerable: n.enumerable
      }), {
          getValue: function() {
              return r
          },
          setValue: function(o) {
              r = "" + o
          },
          stopTracking: function() {
              e._valueTracker = null, delete e[t]
          }
      }
  }
}

function bl(e) {
  e._valueTracker || (e._valueTracker = Ik(e))
}

function hx(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(),
      r = "";
  return e && (r = dx(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1
}

function bc(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
      return e.activeElement || e.body
  } catch {
      return e.body
  }
}

function Sh(e, t) {
  var n = t.checked;
  return ke({}, t, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: n ?? e._wrapperState.initialChecked
  })
}

function Qg(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
      r = t.checked != null ? t.checked : t.defaultChecked;
  n = Qr(t.value != null ? t.value : n), e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
  }
}

function fx(e, t) {
  t = t.checked, t != null && Rp(e, "checked", t, !1)
}

function _h(e, t) {
  fx(e, t);
  var n = Qr(t.value),
      r = t.type;
  if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
      e.removeAttribute("value");
      return
  }
  t.hasOwnProperty("value") ? Eh(e, t.type, n) : t.hasOwnProperty("defaultValue") && Eh(e, t.type, Qr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}

function Yg(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
      var r = t.type;
      if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return;
      t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
  }
  n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n)
}

function Eh(e, t, n) {
  (t !== "number" || bc(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Ko = Array.isArray;

function Li(e, t, n, r) {
  if (e = e.options, t) {
      t = {};
      for (var s = 0; s < n.length; s++) t["$" + n[s]] = !0;
      for (n = 0; n < e.length; n++) s = t.hasOwnProperty("$" + e[n].value), e[n].selected !== s && (e[n].selected = s), s && r && (e[n].defaultSelected = !0)
  } else {
      for (n = "" + Qr(n), t = null, s = 0; s < e.length; s++) {
          if (e[s].value === n) {
              e[s].selected = !0, r && (e[s].defaultSelected = !0);
              return
          }
          t !== null || e[s].disabled || (t = e[s])
      }
      t !== null && (t.selected = !0)
  }
}

function Ch(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(O(91));
  return ke({}, t, {
      value: void 0,
      defaultValue: void 0,
      children: "" + e._wrapperState.initialValue
  })
}

function Jg(e, t) {
  var n = t.value;
  if (n == null) {
      if (n = t.children, t = t.defaultValue, n != null) {
          if (t != null) throw Error(O(92));
          if (Ko(n)) {
              if (1 < n.length) throw Error(O(93));
              n = n[0]
          }
          t = n
      }
      t == null && (t = ""), n = t
  }
  e._wrapperState = {
      initialValue: Qr(n)
  }
}

function px(e, t) {
  var n = Qr(t.value),
      r = Qr(t.defaultValue);
  n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r)
}

function Xg(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}

function mx(e) {
  switch (e) {
      case "svg":
          return "http://www.w3.org/2000/svg";
      case "math":
          return "http://www.w3.org/1998/Math/MathML";
      default:
          return "http://www.w3.org/1999/xhtml"
  }
}

function Th(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? mx(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Sl, gx = function(e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, s) {
      MSApp.execUnsafeLocalFunction(function() {
          return e(t, n, r, s)
      })
  } : e
}(function(e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
  else {
      for (Sl = Sl || document.createElement("div"), Sl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Sl.firstChild; e.firstChild;) e.removeChild(e.firstChild);
      for (; t.firstChild;) e.appendChild(t.firstChild)
  }
});

function ga(e, t) {
  if (t) {
      var n = e.firstChild;
      if (n && n === e.lastChild && n.nodeType === 3) {
          n.nodeValue = t;
          return
      }
  }
  e.textContent = t
}
var Zo = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
  },
  Dk = ["Webkit", "ms", "Moz", "O"];
Object.keys(Zo).forEach(function(e) {
  Dk.forEach(function(t) {
      t = t + e.charAt(0).toUpperCase() + e.substring(1), Zo[t] = Zo[e]
  })
});

function yx(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Zo.hasOwnProperty(e) && Zo[e] ? ("" + t).trim() : t + "px"
}

function vx(e, t) {
  e = e.style;
  for (var n in t)
      if (t.hasOwnProperty(n)) {
          var r = n.indexOf("--") === 0,
              s = yx(n, t[n], r);
          n === "float" && (n = "cssFloat"), r ? e.setProperty(n, s) : e[n] = s
      }
}
var Mk = ke({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function kh(e, t) {
  if (t) {
      if (Mk[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(O(137, e));
      if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null) throw Error(O(60));
          if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(O(61))
      }
      if (t.style != null && typeof t.style != "object") throw Error(O(62))
  }
}

function Rh(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
          return !1;
      default:
          return !0
  }
}
var Ph = null;

function jp(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e
}
var Ah = null,
  $i = null,
  Fi = null;

function Zg(e) {
  if (e = nl(e)) {
      if (typeof Ah != "function") throw Error(O(280));
      var t = e.stateNode;
      t && (t = yu(t), Ah(e.stateNode, e.type, t))
  }
}

function wx(e) {
  $i ? Fi ? Fi.push(e) : Fi = [e] : $i = e
}

function xx() {
  if ($i) {
      var e = $i,
          t = Fi;
      if (Fi = $i = null, Zg(e), t)
          for (e = 0; e < t.length; e++) Zg(t[e])
  }
}

function bx(e, t) {
  return e(t)
}

function Sx() {}
var cd = !1;

function _x(e, t, n) {
  if (cd) return e(t, n);
  cd = !0;
  try {
      return bx(e, t, n)
  } finally {
      cd = !1, ($i !== null || Fi !== null) && (Sx(), xx())
  }
}

function ya(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = yu(n);
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
          (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
          break e;
      default:
          e = !1
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(O(231, t, typeof n));
  return n
}
var Nh = !1;
if (Kn) try {
  var Do = {};
  Object.defineProperty(Do, "passive", {
      get: function() {
          Nh = !0
      }
  }), window.addEventListener("test", Do, Do), window.removeEventListener("test", Do, Do)
} catch {
  Nh = !1
}

function Lk(e, t, n, r, s, i, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
      t.apply(n, c)
  } catch (u) {
      this.onError(u)
  }
}
var ea = !1,
  Sc = null,
  _c = !1,
  jh = null,
  $k = {
      onError: function(e) {
          ea = !0, Sc = e
      }
  };

function Fk(e, t, n, r, s, i, o, a, l) {
  ea = !1, Sc = null, Lk.apply($k, arguments)
}

function Uk(e, t, n, r, s, i, o, a, l) {
  if (Fk.apply(this, arguments), ea) {
      if (ea) {
          var c = Sc;
          ea = !1, Sc = null
      } else throw Error(O(198));
      _c || (_c = !0, jh = c)
  }
}

function Js(e) {
  var t = e,
      n = e;
  if (e.alternate)
      for (; t.return;) t = t.return;
  else {
      e = t;
      do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e)
  }
  return t.tag === 3 ? n : null
}

function Ex(e) {
  if (e.tag === 13) {
      var t = e.memoizedState;
      if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated
  }
  return null
}

function ey(e) {
  if (Js(e) !== e) throw Error(O(188))
}

function Vk(e) {
  var t = e.alternate;
  if (!t) {
      if (t = Js(e), t === null) throw Error(O(188));
      return t !== e ? null : e
  }
  for (var n = e, r = t;;) {
      var s = n.return;
      if (s === null) break;
      var i = s.alternate;
      if (i === null) {
          if (r = s.return, r !== null) {
              n = r;
              continue
          }
          break
      }
      if (s.child === i.child) {
          for (i = s.child; i;) {
              if (i === n) return ey(s), e;
              if (i === r) return ey(s), t;
              i = i.sibling
          }
          throw Error(O(188))
      }
      if (n.return !== r.return) n = s, r = i;
      else {
          for (var o = !1, a = s.child; a;) {
              if (a === n) {
                  o = !0, n = s, r = i;
                  break
              }
              if (a === r) {
                  o = !0, r = s, n = i;
                  break
              }
              a = a.sibling
          }
          if (!o) {
              for (a = i.child; a;) {
                  if (a === n) {
                      o = !0, n = i, r = s;
                      break
                  }
                  if (a === r) {
                      o = !0, r = i, n = s;
                      break
                  }
                  a = a.sibling
              }
              if (!o) throw Error(O(189))
          }
      }
      if (n.alternate !== r) throw Error(O(190))
  }
  if (n.tag !== 3) throw Error(O(188));
  return n.stateNode.current === n ? e : t
}

function Cx(e) {
  return e = Vk(e), e !== null ? Tx(e) : null
}

function Tx(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null;) {
      var t = Tx(e);
      if (t !== null) return t;
      e = e.sibling
  }
  return null
}
var kx = Nt.unstable_scheduleCallback,
  ty = Nt.unstable_cancelCallback,
  Bk = Nt.unstable_shouldYield,
  zk = Nt.unstable_requestPaint,
  je = Nt.unstable_now,
  Wk = Nt.unstable_getCurrentPriorityLevel,
  Op = Nt.unstable_ImmediatePriority,
  Rx = Nt.unstable_UserBlockingPriority,
  Ec = Nt.unstable_NormalPriority,
  Hk = Nt.unstable_LowPriority,
  Px = Nt.unstable_IdlePriority,
  fu = null,
  Tn = null;

function Kk(e) {
  if (Tn && typeof Tn.onCommitFiberRoot == "function") try {
      Tn.onCommitFiberRoot(fu, e, void 0, (e.current.flags & 128) === 128)
  } catch {}
}
var un = Math.clz32 ? Math.clz32 : Qk,
  qk = Math.log,
  Gk = Math.LN2;

function Qk(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (qk(e) / Gk | 0) | 0
}
var _l = 64,
  El = 4194304;

function qo(e) {
  switch (e & -e) {
      case 1:
          return 1;
      case 2:
          return 2;
      case 4:
          return 4;
      case 8:
          return 8;
      case 16:
          return 16;
      case 32:
          return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
          return e & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
          return e & 130023424;
      case 134217728:
          return 134217728;
      case 268435456:
          return 268435456;
      case 536870912:
          return 536870912;
      case 1073741824:
          return 1073741824;
      default:
          return e
  }
}

function Cc(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
      s = e.suspendedLanes,
      i = e.pingedLanes,
      o = n & 268435455;
  if (o !== 0) {
      var a = o & ~s;
      a !== 0 ? r = qo(a) : (i &= o, i !== 0 && (r = qo(i)))
  } else o = n & ~s, o !== 0 ? r = qo(o) : i !== 0 && (r = qo(i));
  if (r === 0) return 0;
  if (t !== 0 && t !== r && !(t & s) && (s = r & -r, i = t & -t, s >= i || s === 16 && (i & 4194240) !== 0)) return t;
  if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0)
      for (e = e.entanglements, t &= r; 0 < t;) n = 31 - un(t), s = 1 << n, r |= e[n], t &= ~s;
  return r
}

function Yk(e, t) {
  switch (e) {
      case 1:
      case 2:
      case 4:
          return t + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
          return t + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
          return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
          return -1;
      default:
          return -1
  }
}

function Jk(e, t) {
  for (var n = e.suspendedLanes, r = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i;) {
      var o = 31 - un(i),
          a = 1 << o,
          l = s[o];
      l === -1 ? (!(a & n) || a & r) && (s[o] = Yk(a, t)) : l <= t && (e.expiredLanes |= a), i &= ~a
  }
}

function Oh(e) {
  return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}

function Ax() {
  var e = _l;
  return _l <<= 1, !(_l & 4194240) && (_l = 64), e
}

function ud(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t
}

function el(e, t, n) {
  e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - un(t), e[t] = n
}

function Xk(e, t) {
  var n = e.pendingLanes & ~t;
  e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n;) {
      var s = 31 - un(n),
          i = 1 << s;
      t[s] = 0, r[s] = -1, e[s] = -1, n &= ~i
  }
}

function Ip(e, t) {
  var n = e.entangledLanes |= t;
  for (e = e.entanglements; n;) {
      var r = 31 - un(n),
          s = 1 << r;
      s & t | e[r] & t && (e[r] |= t), n &= ~s
  }
}
var he = 0;

function Nx(e) {
  return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var jx, Dp, Ox, Ix, Dx, Ih = !1,
  Cl = [],
  $r = null,
  Fr = null,
  Ur = null,
  va = new Map,
  wa = new Map,
  br = [],
  Zk = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function ny(e, t) {
  switch (e) {
      case "focusin":
      case "focusout":
          $r = null;
          break;
      case "dragenter":
      case "dragleave":
          Fr = null;
          break;
      case "mouseover":
      case "mouseout":
          Ur = null;
          break;
      case "pointerover":
      case "pointerout":
          va.delete(t.pointerId);
          break;
      case "gotpointercapture":
      case "lostpointercapture":
          wa.delete(t.pointerId)
  }
}

function Mo(e, t, n, r, s, i) {
  return e === null || e.nativeEvent !== i ? (e = {
      blockedOn: t,
      domEventName: n,
      eventSystemFlags: r,
      nativeEvent: i,
      targetContainers: [s]
  }, t !== null && (t = nl(t), t !== null && Dp(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, s !== null && t.indexOf(s) === -1 && t.push(s), e)
}

function eR(e, t, n, r, s) {
  switch (t) {
      case "focusin":
          return $r = Mo($r, e, t, n, r, s), !0;
      case "dragenter":
          return Fr = Mo(Fr, e, t, n, r, s), !0;
      case "mouseover":
          return Ur = Mo(Ur, e, t, n, r, s), !0;
      case "pointerover":
          var i = s.pointerId;
          return va.set(i, Mo(va.get(i) || null, e, t, n, r, s)), !0;
      case "gotpointercapture":
          return i = s.pointerId, wa.set(i, Mo(wa.get(i) || null, e, t, n, r, s)), !0
  }
  return !1
}

function Mx(e) {
  var t = Ss(e.target);
  if (t !== null) {
      var n = Js(t);
      if (n !== null) {
          if (t = n.tag, t === 13) {
              if (t = Ex(n), t !== null) {
                  e.blockedOn = t, Dx(e.priority, function() {
                      Ox(n)
                  });
                  return
              }
          } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
              e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
              return
          }
      }
  }
  e.blockedOn = null
}

function tc(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length;) {
      var n = Dh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
      if (n === null) {
          n = e.nativeEvent;
          var r = new n.constructor(n.type, n);
          Ph = r, n.target.dispatchEvent(r), Ph = null
      } else return t = nl(n), t !== null && Dp(t), e.blockedOn = n, !1;
      t.shift()
  }
  return !0
}

function ry(e, t, n) {
  tc(e) && n.delete(t)
}

function tR() {
  Ih = !1, $r !== null && tc($r) && ($r = null), Fr !== null && tc(Fr) && (Fr = null), Ur !== null && tc(Ur) && (Ur = null), va.forEach(ry), wa.forEach(ry)
}

function Lo(e, t) {
  e.blockedOn === t && (e.blockedOn = null, Ih || (Ih = !0, Nt.unstable_scheduleCallback(Nt.unstable_NormalPriority, tR)))
}

function xa(e) {
  function t(s) {
      return Lo(s, e)
  }
  if (0 < Cl.length) {
      Lo(Cl[0], e);
      for (var n = 1; n < Cl.length; n++) {
          var r = Cl[n];
          r.blockedOn === e && (r.blockedOn = null)
      }
  }
  for ($r !== null && Lo($r, e), Fr !== null && Lo(Fr, e), Ur !== null && Lo(Ur, e), va.forEach(t), wa.forEach(t), n = 0; n < br.length; n++) r = br[n], r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < br.length && (n = br[0], n.blockedOn === null);) Mx(n), n.blockedOn === null && br.shift()
}
var Ui = er.ReactCurrentBatchConfig,
  Tc = !0;

function nR(e, t, n, r) {
  var s = he,
      i = Ui.transition;
  Ui.transition = null;
  try {
      he = 1, Mp(e, t, n, r)
  } finally {
      he = s, Ui.transition = i
  }
}

function rR(e, t, n, r) {
  var s = he,
      i = Ui.transition;
  Ui.transition = null;
  try {
      he = 4, Mp(e, t, n, r)
  } finally {
      he = s, Ui.transition = i
  }
}

function Mp(e, t, n, r) {
  if (Tc) {
      var s = Dh(e, t, n, r);
      if (s === null) xd(e, t, r, kc, n), ny(e, r);
      else if (eR(s, e, t, n, r)) r.stopPropagation();
      else if (ny(e, r), t & 4 && -1 < Zk.indexOf(e)) {
          for (; s !== null;) {
              var i = nl(s);
              if (i !== null && jx(i), i = Dh(e, t, n, r), i === null && xd(e, t, r, kc, n), i === s) break;
              s = i
          }
          s !== null && r.stopPropagation()
      } else xd(e, t, r, null, n)
  }
}
var kc = null;

function Dh(e, t, n, r) {
  if (kc = null, e = jp(r), e = Ss(e), e !== null)
      if (t = Js(e), t === null) e = null;
      else if (n = t.tag, n === 13) {
      if (e = Ex(t), e !== null) return e;
      e = null
  } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
      e = null
  } else t !== e && (e = null);
  return kc = e, null
}

function Lx(e) {
  switch (e) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
          return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
          return 4;
      case "message":
          switch (Wk()) {
              case Op:
                  return 1;
              case Rx:
                  return 4;
              case Ec:
              case Hk:
                  return 16;
              case Px:
                  return 536870912;
              default:
                  return 16
          }
      default:
          return 16
  }
}
var Dr = null,
  Lp = null,
  nc = null;

function $x() {
  if (nc) return nc;
  var e, t = Lp,
      n = t.length,
      r, s = "value" in Dr ? Dr.value : Dr.textContent,
      i = s.length;
  for (e = 0; e < n && t[e] === s[e]; e++);
  var o = n - e;
  for (r = 1; r <= o && t[n - r] === s[i - r]; r++);
  return nc = s.slice(e, 1 < r ? 1 - r : void 0)
}

function rc(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0
}

function Tl() {
  return !0
}

function sy() {
  return !1
}

function Ot(e) {
  function t(n, r, s, i, o) {
      this._reactName = n, this._targetInst = s, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null;
      for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(i) : i[a]);
      return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Tl : sy, this.isPropagationStopped = sy, this
  }
  return ke(t.prototype, {
      preventDefault: function() {
          this.defaultPrevented = !0;
          var n = this.nativeEvent;
          n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Tl)
      },
      stopPropagation: function() {
          var n = this.nativeEvent;
          n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Tl)
      },
      persist: function() {},
      isPersistent: Tl
  }), t
}
var bo = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
          return e.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0
  },
  $p = Ot(bo),
  tl = ke({}, bo, {
      view: 0,
      detail: 0
  }),
  sR = Ot(tl),
  dd, hd, $o, pu = ke({}, tl, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Fp,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
          return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
      },
      movementX: function(e) {
          return "movementX" in e ? e.movementX : (e !== $o && ($o && e.type === "mousemove" ? (dd = e.screenX - $o.screenX, hd = e.screenY - $o.screenY) : hd = dd = 0, $o = e), dd)
      },
      movementY: function(e) {
          return "movementY" in e ? e.movementY : hd
      }
  }),
  iy = Ot(pu),
  iR = ke({}, pu, {
      dataTransfer: 0
  }),
  oR = Ot(iR),
  aR = ke({}, tl, {
      relatedTarget: 0
  }),
  fd = Ot(aR),
  lR = ke({}, bo, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
  }),
  cR = Ot(lR),
  uR = ke({}, bo, {
      clipboardData: function(e) {
          return "clipboardData" in e ? e.clipboardData : window.clipboardData
      }
  }),
  dR = Ot(uR),
  hR = ke({}, bo, {
      data: 0
  }),
  oy = Ot(hR),
  fR = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
  },
  pR = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
  },
  mR = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
  };

function gR(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = mR[e]) ? !!t[e] : !1
}

function Fp() {
  return gR
}
var yR = ke({}, tl, {
      key: function(e) {
          if (e.key) {
              var t = fR[e.key] || e.key;
              if (t !== "Unidentified") return t
          }
          return e.type === "keypress" ? (e = rc(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? pR[e.keyCode] || "Unidentified" : ""
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Fp,
      charCode: function(e) {
          return e.type === "keypress" ? rc(e) : 0
      },
      keyCode: function(e) {
          return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
      },
      which: function(e) {
          return e.type === "keypress" ? rc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
      }
  }),
  vR = Ot(yR),
  wR = ke({}, pu, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
  }),
  ay = Ot(wR),
  xR = ke({}, tl, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Fp
  }),
  bR = Ot(xR),
  SR = ke({}, bo, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
  }),
  _R = Ot(SR),
  ER = ke({}, pu, {
      deltaX: function(e) {
          return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
      },
      deltaY: function(e) {
          return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
      },
      deltaZ: 0,
      deltaMode: 0
  }),
  CR = Ot(ER),
  TR = [9, 13, 27, 32],
  Up = Kn && "CompositionEvent" in window,
  ta = null;
Kn && "documentMode" in document && (ta = document.documentMode);
var kR = Kn && "TextEvent" in window && !ta,
  Fx = Kn && (!Up || ta && 8 < ta && 11 >= ta),
  ly = " ",
  cy = !1;

function Ux(e, t) {
  switch (e) {
      case "keyup":
          return TR.indexOf(t.keyCode) !== -1;
      case "keydown":
          return t.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
          return !0;
      default:
          return !1
  }
}

function Vx(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null
}
var bi = !1;

function RR(e, t) {
  switch (e) {
      case "compositionend":
          return Vx(t);
      case "keypress":
          return t.which !== 32 ? null : (cy = !0, ly);
      case "textInput":
          return e = t.data, e === ly && cy ? null : e;
      default:
          return null
  }
}

function PR(e, t) {
  if (bi) return e === "compositionend" || !Up && Ux(e, t) ? (e = $x(), nc = Lp = Dr = null, bi = !1, e) : null;
  switch (e) {
      case "paste":
          return null;
      case "keypress":
          if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
              if (t.char && 1 < t.char.length) return t.char;
              if (t.which) return String.fromCharCode(t.which)
          }
          return null;
      case "compositionend":
          return Fx && t.locale !== "ko" ? null : t.data;
      default:
          return null
  }
}
var AR = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function uy(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!AR[e.type] : t === "textarea"
}

function Bx(e, t, n, r) {
  wx(r), t = Rc(t, "onChange"), 0 < t.length && (n = new $p("onChange", "change", null, n, r), e.push({
      event: n,
      listeners: t
  }))
}
var na = null,
  ba = null;

function NR(e) {
  Zx(e, 0)
}

function mu(e) {
  var t = Ei(e);
  if (hx(t)) return e
}

function jR(e, t) {
  if (e === "change") return t
}
var zx = !1;
if (Kn) {
  var pd;
  if (Kn) {
      var md = "oninput" in document;
      if (!md) {
          var dy = document.createElement("div");
          dy.setAttribute("oninput", "return;"), md = typeof dy.oninput == "function"
      }
      pd = md
  } else pd = !1;
  zx = pd && (!document.documentMode || 9 < document.documentMode)
}

function hy() {
  na && (na.detachEvent("onpropertychange", Wx), ba = na = null)
}

function Wx(e) {
  if (e.propertyName === "value" && mu(ba)) {
      var t = [];
      Bx(t, ba, e, jp(e)), _x(NR, t)
  }
}

function OR(e, t, n) {
  e === "focusin" ? (hy(), na = t, ba = n, na.attachEvent("onpropertychange", Wx)) : e === "focusout" && hy()
}

function IR(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return mu(ba)
}

function DR(e, t) {
  if (e === "click") return mu(t)
}

function MR(e, t) {
  if (e === "input" || e === "change") return mu(t)
}

function LR(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var hn = typeof Object.is == "function" ? Object.is : LR;

function Sa(e, t) {
  if (hn(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  var n = Object.keys(e),
      r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
      var s = n[r];
      if (!yh.call(t, s) || !hn(e[s], t[s])) return !1
  }
  return !0
}

function fy(e) {
  for (; e && e.firstChild;) e = e.firstChild;
  return e
}

function py(e, t) {
  var n = fy(e);
  e = 0;
  for (var r; n;) {
      if (n.nodeType === 3) {
          if (r = e + n.textContent.length, e <= t && r >= t) return {
              node: n,
              offset: t - e
          };
          e = r
      }
      e: {
          for (; n;) {
              if (n.nextSibling) {
                  n = n.nextSibling;
                  break e
              }
              n = n.parentNode
          }
          n = void 0
      }
      n = fy(n)
  }
}

function Hx(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Hx(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}

function Kx() {
  for (var e = window, t = bc(); t instanceof e.HTMLIFrameElement;) {
      try {
          var n = typeof t.contentWindow.location.href == "string"
      } catch {
          n = !1
      }
      if (n) e = t.contentWindow;
      else break;
      t = bc(e.document)
  }
  return t
}

function Vp(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}

function $R(e) {
  var t = Kx(),
      n = e.focusedElem,
      r = e.selectionRange;
  if (t !== n && n && n.ownerDocument && Hx(n.ownerDocument.documentElement, n)) {
      if (r !== null && Vp(n)) {
          if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
          else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) {
              e = e.getSelection();
              var s = n.textContent.length,
                  i = Math.min(r.start, s);
              r = r.end === void 0 ? i : Math.min(r.end, s), !e.extend && i > r && (s = r, r = i, i = s), s = py(n, i);
              var o = py(n, r);
              s && o && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(s.node, s.offset), e.removeAllRanges(), i > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)))
          }
      }
      for (t = [], e = n; e = e.parentNode;) e.nodeType === 1 && t.push({
          element: e,
          left: e.scrollLeft,
          top: e.scrollTop
      });
      for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++) e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top
  }
}
var FR = Kn && "documentMode" in document && 11 >= document.documentMode,
  Si = null,
  Mh = null,
  ra = null,
  Lh = !1;

function my(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  Lh || Si == null || Si !== bc(r) || (r = Si, "selectionStart" in r && Vp(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
  } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
  }), ra && Sa(ra, r) || (ra = r, r = Rc(Mh, "onSelect"), 0 < r.length && (t = new $p("onSelect", "select", null, t, n), e.push({
      event: t,
      listeners: r
  }), t.target = Si)))
}

function kl(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
}
var _i = {
      animationend: kl("Animation", "AnimationEnd"),
      animationiteration: kl("Animation", "AnimationIteration"),
      animationstart: kl("Animation", "AnimationStart"),
      transitionend: kl("Transition", "TransitionEnd")
  },
  gd = {},
  qx = {};
Kn && (qx = document.createElement("div").style, "AnimationEvent" in window || (delete _i.animationend.animation, delete _i.animationiteration.animation, delete _i.animationstart.animation), "TransitionEvent" in window || delete _i.transitionend.transition);

function gu(e) {
  if (gd[e]) return gd[e];
  if (!_i[e]) return e;
  var t = _i[e],
      n;
  for (n in t)
      if (t.hasOwnProperty(n) && n in qx) return gd[e] = t[n];
  return e
}
var Gx = gu("animationend"),
  Qx = gu("animationiteration"),
  Yx = gu("animationstart"),
  Jx = gu("transitionend"),
  Xx = new Map,
  gy = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function ts(e, t) {
  Xx.set(e, t), Ys(t, [e])
}
for (var yd = 0; yd < gy.length; yd++) {
  var vd = gy[yd],
      UR = vd.toLowerCase(),
      VR = vd[0].toUpperCase() + vd.slice(1);
  ts(UR, "on" + VR)
}
ts(Gx, "onAnimationEnd");
ts(Qx, "onAnimationIteration");
ts(Yx, "onAnimationStart");
ts("dblclick", "onDoubleClick");
ts("focusin", "onFocus");
ts("focusout", "onBlur");
ts(Jx, "onTransitionEnd");
lo("onMouseEnter", ["mouseout", "mouseover"]);
lo("onMouseLeave", ["mouseout", "mouseover"]);
lo("onPointerEnter", ["pointerout", "pointerover"]);
lo("onPointerLeave", ["pointerout", "pointerover"]);
Ys("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Ys("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Ys("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ys("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Ys("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Ys("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Go = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  BR = new Set("cancel close invalid load scroll toggle".split(" ").concat(Go));

function yy(e, t, n) {
  var r = e.type || "unknown-event";
  e.currentTarget = n, Uk(r, t, void 0, e), e.currentTarget = null
}

function Zx(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
      var r = e[n],
          s = r.event;
      r = r.listeners;
      e: {
          var i = void 0;
          if (t)
              for (var o = r.length - 1; 0 <= o; o--) {
                  var a = r[o],
                      l = a.instance,
                      c = a.currentTarget;
                  if (a = a.listener, l !== i && s.isPropagationStopped()) break e;
                  yy(s, a, c), i = l
              } else
                  for (o = 0; o < r.length; o++) {
                      if (a = r[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== i && s.isPropagationStopped()) break e;
                      yy(s, a, c), i = l
                  }
      }
  }
  if (_c) throw e = jh, _c = !1, jh = null, e
}

function ye(e, t) {
  var n = t[Bh];
  n === void 0 && (n = t[Bh] = new Set);
  var r = e + "__bubble";
  n.has(r) || (eb(t, e, 2, !1), n.add(r))
}

function wd(e, t, n) {
  var r = 0;
  t && (r |= 4), eb(n, e, r, t)
}
var Rl = "_reactListening" + Math.random().toString(36).slice(2);

function _a(e) {
  if (!e[Rl]) {
      e[Rl] = !0, ax.forEach(function(n) {
          n !== "selectionchange" && (BR.has(n) || wd(n, !1, e), wd(n, !0, e))
      });
      var t = e.nodeType === 9 ? e : e.ownerDocument;
      t === null || t[Rl] || (t[Rl] = !0, wd("selectionchange", !1, t))
  }
}

function eb(e, t, n, r) {
  switch (Lx(t)) {
      case 1:
          var s = nR;
          break;
      case 4:
          s = rR;
          break;
      default:
          s = Mp
  }
  n = s.bind(null, t, n, e), s = void 0, !Nh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0), r ? s !== void 0 ? e.addEventListener(t, n, {
      capture: !0,
      passive: s
  }) : e.addEventListener(t, n, !0) : s !== void 0 ? e.addEventListener(t, n, {
      passive: s
  }) : e.addEventListener(t, n, !1)
}

function xd(e, t, n, r, s) {
  var i = r;
  if (!(t & 1) && !(t & 2) && r !== null) e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
          var a = r.stateNode.containerInfo;
          if (a === s || a.nodeType === 8 && a.parentNode === s) break;
          if (o === 4)
              for (o = r.return; o !== null;) {
                  var l = o.tag;
                  if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === s || l.nodeType === 8 && l.parentNode === s)) return;
                  o = o.return
              }
          for (; a !== null;) {
              if (o = Ss(a), o === null) return;
              if (l = o.tag, l === 5 || l === 6) {
                  r = i = o;
                  continue e
              }
              a = a.parentNode
          }
      }
      r = r.return
  }
  _x(function() {
      var c = i,
          u = jp(n),
          d = [];
      e: {
          var h = Xx.get(e);
          if (h !== void 0) {
              var f = $p,
                  x = e;
              switch (e) {
                  case "keypress":
                      if (rc(n) === 0) break e;
                  case "keydown":
                  case "keyup":
                      f = vR;
                      break;
                  case "focusin":
                      x = "focus", f = fd;
                      break;
                  case "focusout":
                      x = "blur", f = fd;
                      break;
                  case "beforeblur":
                  case "afterblur":
                      f = fd;
                      break;
                  case "click":
                      if (n.button === 2) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                      f = iy;
                      break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                      f = oR;
                      break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                      f = bR;
                      break;
                  case Gx:
                  case Qx:
                  case Yx:
                      f = cR;
                      break;
                  case Jx:
                      f = _R;
                      break;
                  case "scroll":
                      f = sR;
                      break;
                  case "wheel":
                      f = CR;
                      break;
                  case "copy":
                  case "cut":
                  case "paste":
                      f = dR;
                      break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                      f = ay
              }
              var m = (t & 4) !== 0,
                  b = !m && e === "scroll",
                  v = m ? h !== null ? h + "Capture" : null : h;
              m = [];
              for (var y = c, w; y !== null;) {
                  w = y;
                  var S = w.stateNode;
                  if (w.tag === 5 && S !== null && (w = S, v !== null && (S = ya(y, v), S != null && m.push(Ea(y, S, w)))), b) break;
                  y = y.return
              }
              0 < m.length && (h = new f(h, x, null, n, u), d.push({
                  event: h,
                  listeners: m
              }))
          }
      }
      if (!(t & 7)) {
          e: {
              if (h = e === "mouseover" || e === "pointerover", f = e === "mouseout" || e === "pointerout", h && n !== Ph && (x = n.relatedTarget || n.fromElement) && (Ss(x) || x[qn])) break e;
              if ((f || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window, f ? (x = n.relatedTarget || n.toElement, f = c, x = x ? Ss(x) : null, x !== null && (b = Js(x), x !== b || x.tag !== 5 && x.tag !== 6) && (x = null)) : (f = null, x = c), f !== x)) {
                  if (m = iy, S = "onMouseLeave", v = "onMouseEnter", y = "mouse", (e === "pointerout" || e === "pointerover") && (m = ay, S = "onPointerLeave", v = "onPointerEnter", y = "pointer"), b = f == null ? h : Ei(f), w = x == null ? h : Ei(x), h = new m(S, y + "leave", f, n, u), h.target = b, h.relatedTarget = w, S = null, Ss(u) === c && (m = new m(v, y + "enter", x, n, u), m.target = w, m.relatedTarget = b, S = m), b = S, f && x) t: {
                      for (m = f, v = x, y = 0, w = m; w; w = oi(w)) y++;
                      for (w = 0, S = v; S; S = oi(S)) w++;
                      for (; 0 < y - w;) m = oi(m),
                      y--;
                      for (; 0 < w - y;) v = oi(v),
                      w--;
                      for (; y--;) {
                          if (m === v || v !== null && m === v.alternate) break t;
                          m = oi(m), v = oi(v)
                      }
                      m = null
                  }
                  else m = null;
                  f !== null && vy(d, h, f, m, !1), x !== null && b !== null && vy(d, b, x, m, !0)
              }
          }
          e: {
              if (h = c ? Ei(c) : window, f = h.nodeName && h.nodeName.toLowerCase(), f === "select" || f === "input" && h.type === "file") var _ = jR;
              else if (uy(h))
                  if (zx) _ = MR;
                  else {
                      _ = IR;
                      var E = OR
                  }
              else(f = h.nodeName) && f.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (_ = DR);
              if (_ && (_ = _(e, c))) {
                  Bx(d, _, n, u);
                  break e
              }
              E && E(e, h, c),
              e === "focusout" && (E = h._wrapperState) && E.controlled && h.type === "number" && Eh(h, "number", h.value)
          }
          switch (E = c ? Ei(c) : window, e) {
              case "focusin":
                  (uy(E) || E.contentEditable === "true") && (Si = E, Mh = c, ra = null);
                  break;
              case "focusout":
                  ra = Mh = Si = null;
                  break;
              case "mousedown":
                  Lh = !0;
                  break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                  Lh = !1, my(d, n, u);
                  break;
              case "selectionchange":
                  if (FR) break;
              case "keydown":
              case "keyup":
                  my(d, n, u)
          }
          var T;
          if (Up) e: {
              switch (e) {
                  case "compositionstart":
                      var k = "onCompositionStart";
                      break e;
                  case "compositionend":
                      k = "onCompositionEnd";
                      break e;
                  case "compositionupdate":
                      k = "onCompositionUpdate";
                      break e
              }
              k = void 0
          }
          else bi ? Ux(e, n) && (k = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (k = "onCompositionStart");k && (Fx && n.locale !== "ko" && (bi || k !== "onCompositionStart" ? k === "onCompositionEnd" && bi && (T = $x()) : (Dr = u, Lp = "value" in Dr ? Dr.value : Dr.textContent, bi = !0)), E = Rc(c, k), 0 < E.length && (k = new oy(k, e, null, n, u), d.push({
              event: k,
              listeners: E
          }), T ? k.data = T : (T = Vx(n), T !== null && (k.data = T)))),
          (T = kR ? RR(e, n) : PR(e, n)) && (c = Rc(c, "onBeforeInput"), 0 < c.length && (u = new oy("onBeforeInput", "beforeinput", null, n, u), d.push({
              event: u,
              listeners: c
          }), u.data = T))
      }
      Zx(d, t)
  })
}

function Ea(e, t, n) {
  return {
      instance: e,
      listener: t,
      currentTarget: n
  }
}

function Rc(e, t) {
  for (var n = t + "Capture", r = []; e !== null;) {
      var s = e,
          i = s.stateNode;
      s.tag === 5 && i !== null && (s = i, i = ya(e, n), i != null && r.unshift(Ea(e, i, s)), i = ya(e, t), i != null && r.push(Ea(e, i, s))), e = e.return
  }
  return r
}

function oi(e) {
  if (e === null) return null;
  do e = e.return; while (e && e.tag !== 5);
  return e || null
}

function vy(e, t, n, r, s) {
  for (var i = t._reactName, o = []; n !== null && n !== r;) {
      var a = n,
          l = a.alternate,
          c = a.stateNode;
      if (l !== null && l === r) break;
      a.tag === 5 && c !== null && (a = c, s ? (l = ya(n, i), l != null && o.unshift(Ea(n, l, a))) : s || (l = ya(n, i), l != null && o.push(Ea(n, l, a)))), n = n.return
  }
  o.length !== 0 && e.push({
      event: t,
      listeners: o
  })
}
var zR = /\r\n?/g,
  WR = /\u0000|\uFFFD/g;

function wy(e) {
  return (typeof e == "string" ? e : "" + e).replace(zR, `
`).replace(WR, "")
}

function Pl(e, t, n) {
  if (t = wy(t), wy(e) !== t && n) throw Error(O(425))
}

function Pc() {}
var $h = null,
  Fh = null;

function Uh(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var Vh = typeof setTimeout == "function" ? setTimeout : void 0,
  HR = typeof clearTimeout == "function" ? clearTimeout : void 0,
  xy = typeof Promise == "function" ? Promise : void 0,
  KR = typeof queueMicrotask == "function" ? queueMicrotask : typeof xy < "u" ? function(e) {
      return xy.resolve(null).then(e).catch(qR)
  } : Vh;

function qR(e) {
  setTimeout(function() {
      throw e
  })
}

function bd(e, t) {
  var n = t,
      r = 0;
  do {
      var s = n.nextSibling;
      if (e.removeChild(n), s && s.nodeType === 8)
          if (n = s.data, n === "/$") {
              if (r === 0) {
                  e.removeChild(s), xa(t);
                  return
              }
              r--
          } else n !== "$" && n !== "$?" && n !== "$!" || r++;
      n = s
  } while (n);
  xa(t)
}

function Vr(e) {
  for (; e != null; e = e.nextSibling) {
      var t = e.nodeType;
      if (t === 1 || t === 3) break;
      if (t === 8) {
          if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
          if (t === "/$") return null
      }
  }
  return e
}

function by(e) {
  e = e.previousSibling;
  for (var t = 0; e;) {
      if (e.nodeType === 8) {
          var n = e.data;
          if (n === "$" || n === "$!" || n === "$?") {
              if (t === 0) return e;
              t--
          } else n === "/$" && t++
      }
      e = e.previousSibling
  }
  return null
}
var So = Math.random().toString(36).slice(2),
  _n = "__reactFiber$" + So,
  Ca = "__reactProps$" + So,
  qn = "__reactContainer$" + So,
  Bh = "__reactEvents$" + So,
  GR = "__reactListeners$" + So,
  QR = "__reactHandles$" + So;

function Ss(e) {
  var t = e[_n];
  if (t) return t;
  for (var n = e.parentNode; n;) {
      if (t = n[qn] || n[_n]) {
          if (n = t.alternate, t.child !== null || n !== null && n.child !== null)
              for (e = by(e); e !== null;) {
                  if (n = e[_n]) return n;
                  e = by(e)
              }
          return t
      }
      e = n, n = e.parentNode
  }
  return null
}

function nl(e) {
  return e = e[_n] || e[qn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}

function Ei(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(O(33))
}

function yu(e) {
  return e[Ca] || null
}
var zh = [],
  Ci = -1;

function ns(e) {
  return {
      current: e
  }
}

function ve(e) {
  0 > Ci || (e.current = zh[Ci], zh[Ci] = null, Ci--)
}

function me(e, t) {
  Ci++, zh[Ci] = e.current, e.current = t
}
var Yr = {},
  rt = ns(Yr),
  xt = ns(!1),
  Vs = Yr;

function co(e, t) {
  var n = e.type.contextTypes;
  if (!n) return Yr;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
  var s = {},
      i;
  for (i in n) s[i] = t[i];
  return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s
}

function bt(e) {
  return e = e.childContextTypes, e != null
}

function Ac() {
  ve(xt), ve(rt)
}

function Sy(e, t, n) {
  if (rt.current !== Yr) throw Error(O(168));
  me(rt, t), me(xt, n)
}

function tb(e, t, n) {
  var r = e.stateNode;
  if (t = t.childContextTypes, typeof r.getChildContext != "function") return n;
  r = r.getChildContext();
  for (var s in r)
      if (!(s in t)) throw Error(O(108, Ok(e) || "Unknown", s));
  return ke({}, n, r)
}

function Nc(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Yr, Vs = rt.current, me(rt, e), me(xt, xt.current), !0
}

function _y(e, t, n) {
  var r = e.stateNode;
  if (!r) throw Error(O(169));
  n ? (e = tb(e, t, Vs), r.__reactInternalMemoizedMergedChildContext = e, ve(xt), ve(rt), me(rt, e)) : ve(xt), me(xt, n)
}
var Fn = null,
  vu = !1,
  Sd = !1;

function nb(e) {
  Fn === null ? Fn = [e] : Fn.push(e)
}

function YR(e) {
  vu = !0, nb(e)
}

function rs() {
  if (!Sd && Fn !== null) {
      Sd = !0;
      var e = 0,
          t = he;
      try {
          var n = Fn;
          for (he = 1; e < n.length; e++) {
              var r = n[e];
              do r = r(!0); while (r !== null)
          }
          Fn = null, vu = !1
      } catch (s) {
          throw Fn !== null && (Fn = Fn.slice(e + 1)), kx(Op, rs), s
      } finally {
          he = t, Sd = !1
      }
  }
  return null
}
var Ti = [],
  ki = 0,
  jc = null,
  Oc = 0,
  $t = [],
  Ft = 0,
  Bs = null,
  Bn = 1,
  zn = "";

function hs(e, t) {
  Ti[ki++] = Oc, Ti[ki++] = jc, jc = e, Oc = t
}

function rb(e, t, n) {
  $t[Ft++] = Bn, $t[Ft++] = zn, $t[Ft++] = Bs, Bs = e;
  var r = Bn;
  e = zn;
  var s = 32 - un(r) - 1;
  r &= ~(1 << s), n += 1;
  var i = 32 - un(t) + s;
  if (30 < i) {
      var o = s - s % 5;
      i = (r & (1 << o) - 1).toString(32), r >>= o, s -= o, Bn = 1 << 32 - un(t) + s | n << s | r, zn = i + e
  } else Bn = 1 << i | n << s | r, zn = e
}

function Bp(e) {
  e.return !== null && (hs(e, 1), rb(e, 1, 0))
}

function zp(e) {
  for (; e === jc;) jc = Ti[--ki], Ti[ki] = null, Oc = Ti[--ki], Ti[ki] = null;
  for (; e === Bs;) Bs = $t[--Ft], $t[Ft] = null, zn = $t[--Ft], $t[Ft] = null, Bn = $t[--Ft], $t[Ft] = null
}
var Pt = null,
  Rt = null,
  be = !1,
  cn = null;

function sb(e, t) {
  var n = Ut(5, null, null, 0);
  n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)
}

function Ey(e, t) {
  switch (e.tag) {
      case 5:
          var n = e.type;
          return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Pt = e, Rt = Vr(t.firstChild), !0) : !1;
      case 6:
          return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Pt = e, Rt = null, !0) : !1;
      case 13:
          return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Bs !== null ? {
              id: Bn,
              overflow: zn
          } : null, e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824
          }, n = Ut(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Pt = e, Rt = null, !0) : !1;
      default:
          return !1
  }
}

function Wh(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}

function Hh(e) {
  if (be) {
      var t = Rt;
      if (t) {
          var n = t;
          if (!Ey(e, t)) {
              if (Wh(e)) throw Error(O(418));
              t = Vr(n.nextSibling);
              var r = Pt;
              t && Ey(e, t) ? sb(r, n) : (e.flags = e.flags & -4097 | 2, be = !1, Pt = e)
          }
      } else {
          if (Wh(e)) throw Error(O(418));
          e.flags = e.flags & -4097 | 2, be = !1, Pt = e
      }
  }
}

function Cy(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;) e = e.return;
  Pt = e
}

function Al(e) {
  if (e !== Pt) return !1;
  if (!be) return Cy(e), be = !0, !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Uh(e.type, e.memoizedProps)), t && (t = Rt)) {
      if (Wh(e)) throw ib(), Error(O(418));
      for (; t;) sb(e, t), t = Vr(t.nextSibling)
  }
  if (Cy(e), e.tag === 13) {
      if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(O(317));
      e: {
          for (e = e.nextSibling, t = 0; e;) {
              if (e.nodeType === 8) {
                  var n = e.data;
                  if (n === "/$") {
                      if (t === 0) {
                          Rt = Vr(e.nextSibling);
                          break e
                      }
                      t--
                  } else n !== "$" && n !== "$!" && n !== "$?" || t++
              }
              e = e.nextSibling
          }
          Rt = null
      }
  } else Rt = Pt ? Vr(e.stateNode.nextSibling) : null;
  return !0
}

function ib() {
  for (var e = Rt; e;) e = Vr(e.nextSibling)
}

function uo() {
  Rt = Pt = null, be = !1
}

function Wp(e) {
  cn === null ? cn = [e] : cn.push(e)
}
var JR = er.ReactCurrentBatchConfig;

function Fo(e, t, n) {
  if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") {
      if (n._owner) {
          if (n = n._owner, n) {
              if (n.tag !== 1) throw Error(O(309));
              var r = n.stateNode
          }
          if (!r) throw Error(O(147, e));
          var s = r,
              i = "" + e;
          return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function(o) {
              var a = s.refs;
              o === null ? delete a[i] : a[i] = o
          }, t._stringRef = i, t)
      }
      if (typeof e != "string") throw Error(O(284));
      if (!n._owner) throw Error(O(290, e))
  }
  return e
}

function Nl(e, t) {
  throw e = Object.prototype.toString.call(t), Error(O(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}

function Ty(e) {
  var t = e._init;
  return t(e._payload)
}

function ob(e) {
  function t(v, y) {
      if (e) {
          var w = v.deletions;
          w === null ? (v.deletions = [y], v.flags |= 16) : w.push(y)
      }
  }

  function n(v, y) {
      if (!e) return null;
      for (; y !== null;) t(v, y), y = y.sibling;
      return null
  }

  function r(v, y) {
      for (v = new Map; y !== null;) y.key !== null ? v.set(y.key, y) : v.set(y.index, y), y = y.sibling;
      return v
  }

  function s(v, y) {
      return v = Hr(v, y), v.index = 0, v.sibling = null, v
  }

  function i(v, y, w) {
      return v.index = w, e ? (w = v.alternate, w !== null ? (w = w.index, w < y ? (v.flags |= 2, y) : w) : (v.flags |= 2, y)) : (v.flags |= 1048576, y)
  }

  function o(v) {
      return e && v.alternate === null && (v.flags |= 2), v
  }

  function a(v, y, w, S) {
      return y === null || y.tag !== 6 ? (y = Pd(w, v.mode, S), y.return = v, y) : (y = s(y, w), y.return = v, y)
  }

  function l(v, y, w, S) {
      var _ = w.type;
      return _ === xi ? u(v, y, w.props.children, S, w.key) : y !== null && (y.elementType === _ || typeof _ == "object" && _ !== null && _.$$typeof === vr && Ty(_) === y.type) ? (S = s(y, w.props), S.ref = Fo(v, y, w), S.return = v, S) : (S = uc(w.type, w.key, w.props, null, v.mode, S), S.ref = Fo(v, y, w), S.return = v, S)
  }

  function c(v, y, w, S) {
      return y === null || y.tag !== 4 || y.stateNode.containerInfo !== w.containerInfo || y.stateNode.implementation !== w.implementation ? (y = Ad(w, v.mode, S), y.return = v, y) : (y = s(y, w.children || []), y.return = v, y)
  }

  function u(v, y, w, S, _) {
      return y === null || y.tag !== 7 ? (y = $s(w, v.mode, S, _), y.return = v, y) : (y = s(y, w), y.return = v, y)
  }

  function d(v, y, w) {
      if (typeof y == "string" && y !== "" || typeof y == "number") return y = Pd("" + y, v.mode, w), y.return = v, y;
      if (typeof y == "object" && y !== null) {
          switch (y.$$typeof) {
              case xl:
                  return w = uc(y.type, y.key, y.props, null, v.mode, w), w.ref = Fo(v, null, y), w.return = v, w;
              case wi:
                  return y = Ad(y, v.mode, w), y.return = v, y;
              case vr:
                  var S = y._init;
                  return d(v, S(y._payload), w)
          }
          if (Ko(y) || Io(y)) return y = $s(y, v.mode, w, null), y.return = v, y;
          Nl(v, y)
      }
      return null
  }

  function h(v, y, w, S) {
      var _ = y !== null ? y.key : null;
      if (typeof w == "string" && w !== "" || typeof w == "number") return _ !== null ? null : a(v, y, "" + w, S);
      if (typeof w == "object" && w !== null) {
          switch (w.$$typeof) {
              case xl:
                  return w.key === _ ? l(v, y, w, S) : null;
              case wi:
                  return w.key === _ ? c(v, y, w, S) : null;
              case vr:
                  return _ = w._init, h(v, y, _(w._payload), S)
          }
          if (Ko(w) || Io(w)) return _ !== null ? null : u(v, y, w, S, null);
          Nl(v, w)
      }
      return null
  }

  function f(v, y, w, S, _) {
      if (typeof S == "string" && S !== "" || typeof S == "number") return v = v.get(w) || null, a(y, v, "" + S, _);
      if (typeof S == "object" && S !== null) {
          switch (S.$$typeof) {
              case xl:
                  return v = v.get(S.key === null ? w : S.key) || null, l(y, v, S, _);
              case wi:
                  return v = v.get(S.key === null ? w : S.key) || null, c(y, v, S, _);
              case vr:
                  var E = S._init;
                  return f(v, y, w, E(S._payload), _)
          }
          if (Ko(S) || Io(S)) return v = v.get(w) || null, u(y, v, S, _, null);
          Nl(y, S)
      }
      return null
  }

  function x(v, y, w, S) {
      for (var _ = null, E = null, T = y, k = y = 0, P = null; T !== null && k < w.length; k++) {
          T.index > k ? (P = T, T = null) : P = T.sibling;
          var A = h(v, T, w[k], S);
          if (A === null) {
              T === null && (T = P);
              break
          }
          e && T && A.alternate === null && t(v, T), y = i(A, y, k), E === null ? _ = A : E.sibling = A, E = A, T = P
      }
      if (k === w.length) return n(v, T), be && hs(v, k), _;
      if (T === null) {
          for (; k < w.length; k++) T = d(v, w[k], S), T !== null && (y = i(T, y, k), E === null ? _ = T : E.sibling = T, E = T);
          return be && hs(v, k), _
      }
      for (T = r(v, T); k < w.length; k++) P = f(T, v, k, w[k], S), P !== null && (e && P.alternate !== null && T.delete(P.key === null ? k : P.key), y = i(P, y, k), E === null ? _ = P : E.sibling = P, E = P);
      return e && T.forEach(function($) {
          return t(v, $)
      }), be && hs(v, k), _
  }

  function m(v, y, w, S) {
      var _ = Io(w);
      if (typeof _ != "function") throw Error(O(150));
      if (w = _.call(w), w == null) throw Error(O(151));
      for (var E = _ = null, T = y, k = y = 0, P = null, A = w.next(); T !== null && !A.done; k++, A = w.next()) {
          T.index > k ? (P = T, T = null) : P = T.sibling;
          var $ = h(v, T, A.value, S);
          if ($ === null) {
              T === null && (T = P);
              break
          }
          e && T && $.alternate === null && t(v, T), y = i($, y, k), E === null ? _ = $ : E.sibling = $, E = $, T = P
      }
      if (A.done) return n(v, T), be && hs(v, k), _;
      if (T === null) {
          for (; !A.done; k++, A = w.next()) A = d(v, A.value, S), A !== null && (y = i(A, y, k), E === null ? _ = A : E.sibling = A, E = A);
          return be && hs(v, k), _
      }
      for (T = r(v, T); !A.done; k++, A = w.next()) A = f(T, v, k, A.value, S), A !== null && (e && A.alternate !== null && T.delete(A.key === null ? k : A.key), y = i(A, y, k), E === null ? _ = A : E.sibling = A, E = A);
      return e && T.forEach(function(I) {
          return t(v, I)
      }), be && hs(v, k), _
  }

  function b(v, y, w, S) {
      if (typeof w == "object" && w !== null && w.type === xi && w.key === null && (w = w.props.children), typeof w == "object" && w !== null) {
          switch (w.$$typeof) {
              case xl:
                  e: {
                      for (var _ = w.key, E = y; E !== null;) {
                          if (E.key === _) {
                              if (_ = w.type, _ === xi) {
                                  if (E.tag === 7) {
                                      n(v, E.sibling), y = s(E, w.props.children), y.return = v, v = y;
                                      break e
                                  }
                              } else if (E.elementType === _ || typeof _ == "object" && _ !== null && _.$$typeof === vr && Ty(_) === E.type) {
                                  n(v, E.sibling), y = s(E, w.props), y.ref = Fo(v, E, w), y.return = v, v = y;
                                  break e
                              }
                              n(v, E);
                              break
                          } else t(v, E);
                          E = E.sibling
                      }
                      w.type === xi ? (y = $s(w.props.children, v.mode, S, w.key), y.return = v, v = y) : (S = uc(w.type, w.key, w.props, null, v.mode, S), S.ref = Fo(v, y, w), S.return = v, v = S)
                  }
                  return o(v);
              case wi:
                  e: {
                      for (E = w.key; y !== null;) {
                          if (y.key === E)
                              if (y.tag === 4 && y.stateNode.containerInfo === w.containerInfo && y.stateNode.implementation === w.implementation) {
                                  n(v, y.sibling), y = s(y, w.children || []), y.return = v, v = y;
                                  break e
                              } else {
                                  n(v, y);
                                  break
                              }
                          else t(v, y);
                          y = y.sibling
                      }
                      y = Ad(w, v.mode, S),
                      y.return = v,
                      v = y
                  }
                  return o(v);
              case vr:
                  return E = w._init, b(v, y, E(w._payload), S)
          }
          if (Ko(w)) return x(v, y, w, S);
          if (Io(w)) return m(v, y, w, S);
          Nl(v, w)
      }
      return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w, y !== null && y.tag === 6 ? (n(v, y.sibling), y = s(y, w), y.return = v, v = y) : (n(v, y), y = Pd(w, v.mode, S), y.return = v, v = y), o(v)) : n(v, y)
  }
  return b
}
var ho = ob(!0),
  ab = ob(!1),
  Ic = ns(null),
  Dc = null,
  Ri = null,
  Hp = null;

function Kp() {
  Hp = Ri = Dc = null
}

function qp(e) {
  var t = Ic.current;
  ve(Ic), e._currentValue = t
}

function Kh(e, t, n) {
  for (; e !== null;) {
      var r = e.alternate;
      if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
      e = e.return
  }
}

function Vi(e, t) {
  Dc = e, Hp = Ri = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (vt = !0), e.firstContext = null)
}

function Wt(e) {
  var t = e._currentValue;
  if (Hp !== e)
      if (e = {
              context: e,
              memoizedValue: t,
              next: null
          }, Ri === null) {
          if (Dc === null) throw Error(O(308));
          Ri = e, Dc.dependencies = {
              lanes: 0,
              firstContext: e
          }
      } else Ri = Ri.next = e;
  return t
}
var _s = null;

function Gp(e) {
  _s === null ? _s = [e] : _s.push(e)
}

function lb(e, t, n, r) {
  var s = t.interleaved;
  return s === null ? (n.next = n, Gp(t)) : (n.next = s.next, s.next = n), t.interleaved = n, Gn(e, r)
}

function Gn(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;) e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return;
  return n.tag === 3 ? n.stateNode : null
}
var wr = !1;

function Qp(e) {
  e.updateQueue = {
      baseState: e.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
          pending: null,
          interleaved: null,
          lanes: 0
      },
      effects: null
  }
}

function cb(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
      baseState: e.baseState,
      firstBaseUpdate: e.firstBaseUpdate,
      lastBaseUpdate: e.lastBaseUpdate,
      shared: e.shared,
      effects: e.effects
  })
}

function Wn(e, t) {
  return {
      eventTime: e,
      lane: t,
      tag: 0,
      payload: null,
      callback: null,
      next: null
  }
}

function Br(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (r = r.shared, le & 2) {
      var s = r.pending;
      return s === null ? t.next = t : (t.next = s.next, s.next = t), r.pending = t, Gn(e, n)
  }
  return s = r.interleaved, s === null ? (t.next = t, Gp(r)) : (t.next = s.next, s.next = t), r.interleaved = t, Gn(e, n)
}

function sc(e, t, n) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) {
      var r = t.lanes;
      r &= e.pendingLanes, n |= r, t.lanes = n, Ip(e, n)
  }
}

function ky(e, t) {
  var n = e.updateQueue,
      r = e.alternate;
  if (r !== null && (r = r.updateQueue, n === r)) {
      var s = null,
          i = null;
      if (n = n.firstBaseUpdate, n !== null) {
          do {
              var o = {
                  eventTime: n.eventTime,
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: n.callback,
                  next: null
              };
              i === null ? s = i = o : i = i.next = o, n = n.next
          } while (n !== null);
          i === null ? s = i = t : i = i.next = t
      } else s = i = t;
      n = {
          baseState: r.baseState,
          firstBaseUpdate: s,
          lastBaseUpdate: i,
          shared: r.shared,
          effects: r.effects
      }, e.updateQueue = n;
      return
  }
  e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
}

function Mc(e, t, n, r) {
  var s = e.updateQueue;
  wr = !1;
  var i = s.firstBaseUpdate,
      o = s.lastBaseUpdate,
      a = s.shared.pending;
  if (a !== null) {
      s.shared.pending = null;
      var l = a,
          c = l.next;
      l.next = null, o === null ? i = c : o.next = c, o = l;
      var u = e.alternate;
      u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l))
  }
  if (i !== null) {
      var d = s.baseState;
      o = 0, u = c = l = null, a = i;
      do {
          var h = a.lane,
              f = a.eventTime;
          if ((r & h) === h) {
              u !== null && (u = u.next = {
                  eventTime: f,
                  lane: 0,
                  tag: a.tag,
                  payload: a.payload,
                  callback: a.callback,
                  next: null
              });
              e: {
                  var x = e,
                      m = a;
                  switch (h = t, f = n, m.tag) {
                      case 1:
                          if (x = m.payload, typeof x == "function") {
                              d = x.call(f, d, h);
                              break e
                          }
                          d = x;
                          break e;
                      case 3:
                          x.flags = x.flags & -65537 | 128;
                      case 0:
                          if (x = m.payload, h = typeof x == "function" ? x.call(f, d, h) : x, h == null) break e;
                          d = ke({}, d, h);
                          break e;
                      case 2:
                          wr = !0
                  }
              }
              a.callback !== null && a.lane !== 0 && (e.flags |= 64, h = s.effects, h === null ? s.effects = [a] : h.push(a))
          } else f = {
              eventTime: f,
              lane: h,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null
          }, u === null ? (c = u = f, l = d) : u = u.next = f, o |= h;
          if (a = a.next, a === null) {
              if (a = s.shared.pending, a === null) break;
              h = a, a = h.next, h.next = null, s.lastBaseUpdate = h, s.shared.pending = null
          }
      } while (!0);
      if (u === null && (l = d), s.baseState = l, s.firstBaseUpdate = c, s.lastBaseUpdate = u, t = s.shared.interleaved, t !== null) {
          s = t;
          do o |= s.lane, s = s.next; while (s !== t)
      } else i === null && (s.shared.lanes = 0);
      Ws |= o, e.lanes = o, e.memoizedState = d
  }
}

function Ry(e, t, n) {
  if (e = t.effects, t.effects = null, e !== null)
      for (t = 0; t < e.length; t++) {
          var r = e[t],
              s = r.callback;
          if (s !== null) {
              if (r.callback = null, r = n, typeof s != "function") throw Error(O(191, s));
              s.call(r)
          }
      }
}
var rl = {},
  kn = ns(rl),
  Ta = ns(rl),
  ka = ns(rl);

function Es(e) {
  if (e === rl) throw Error(O(174));
  return e
}

function Yp(e, t) {
  switch (me(ka, t), me(Ta, e), me(kn, rl), e = t.nodeType, e) {
      case 9:
      case 11:
          t = (t = t.documentElement) ? t.namespaceURI : Th(null, "");
          break;
      default:
          e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Th(t, e)
  }
  ve(kn), me(kn, t)
}

function fo() {
  ve(kn), ve(Ta), ve(ka)
}

function ub(e) {
  Es(ka.current);
  var t = Es(kn.current),
      n = Th(t, e.type);
  t !== n && (me(Ta, e), me(kn, n))
}

function Jp(e) {
  Ta.current === e && (ve(kn), ve(Ta))
}
var Ee = ns(0);

function Lc(e) {
  for (var t = e; t !== null;) {
      if (t.tag === 13) {
          var n = t.memoizedState;
          if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t
      } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
          if (t.flags & 128) return t
      } else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue
      }
      if (t === e) break;
      for (; t.sibling === null;) {
          if (t.return === null || t.return === e) return null;
          t = t.return
      }
      t.sibling.return = t.return, t = t.sibling
  }
  return null
}
var _d = [];

function Xp() {
  for (var e = 0; e < _d.length; e++) _d[e]._workInProgressVersionPrimary = null;
  _d.length = 0
}
var ic = er.ReactCurrentDispatcher,
  Ed = er.ReactCurrentBatchConfig,
  zs = 0,
  Te = null,
  Ue = null,
  ze = null,
  $c = !1,
  sa = !1,
  Ra = 0,
  XR = 0;

function Xe() {
  throw Error(O(321))
}

function Zp(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
      if (!hn(e[n], t[n])) return !1;
  return !0
}

function em(e, t, n, r, s, i) {
  if (zs = i, Te = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ic.current = e === null || e.memoizedState === null ? nP : rP, e = n(r, s), sa) {
      i = 0;
      do {
          if (sa = !1, Ra = 0, 25 <= i) throw Error(O(301));
          i += 1, ze = Ue = null, t.updateQueue = null, ic.current = sP, e = n(r, s)
      } while (sa)
  }
  if (ic.current = Fc, t = Ue !== null && Ue.next !== null, zs = 0, ze = Ue = Te = null, $c = !1, t) throw Error(O(300));
  return e
}

function tm() {
  var e = Ra !== 0;
  return Ra = 0, e
}

function wn() {
  var e = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
  };
  return ze === null ? Te.memoizedState = ze = e : ze = ze.next = e, ze
}

function Ht() {
  if (Ue === null) {
      var e = Te.alternate;
      e = e !== null ? e.memoizedState : null
  } else e = Ue.next;
  var t = ze === null ? Te.memoizedState : ze.next;
  if (t !== null) ze = t, Ue = e;
  else {
      if (e === null) throw Error(O(310));
      Ue = e, e = {
          memoizedState: Ue.memoizedState,
          baseState: Ue.baseState,
          baseQueue: Ue.baseQueue,
          queue: Ue.queue,
          next: null
      }, ze === null ? Te.memoizedState = ze = e : ze = ze.next = e
  }
  return ze
}

function Pa(e, t) {
  return typeof t == "function" ? t(e) : t
}

function Cd(e) {
  var t = Ht(),
      n = t.queue;
  if (n === null) throw Error(O(311));
  n.lastRenderedReducer = e;
  var r = Ue,
      s = r.baseQueue,
      i = n.pending;
  if (i !== null) {
      if (s !== null) {
          var o = s.next;
          s.next = i.next, i.next = o
      }
      r.baseQueue = s = i, n.pending = null
  }
  if (s !== null) {
      i = s.next, r = r.baseState;
      var a = o = null,
          l = null,
          c = i;
      do {
          var u = c.lane;
          if ((zs & u) === u) l !== null && (l = l.next = {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null
          }), r = c.hasEagerState ? c.eagerState : e(r, c.action);
          else {
              var d = {
                  lane: u,
                  action: c.action,
                  hasEagerState: c.hasEagerState,
                  eagerState: c.eagerState,
                  next: null
              };
              l === null ? (a = l = d, o = r) : l = l.next = d, Te.lanes |= u, Ws |= u
          }
          c = c.next
      } while (c !== null && c !== i);
      l === null ? o = r : l.next = a, hn(r, t.memoizedState) || (vt = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = l, n.lastRenderedState = r
  }
  if (e = n.interleaved, e !== null) {
      s = e;
      do i = s.lane, Te.lanes |= i, Ws |= i, s = s.next; while (s !== e)
  } else s === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch]
}

function Td(e) {
  var t = Ht(),
      n = t.queue;
  if (n === null) throw Error(O(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch,
      s = n.pending,
      i = t.memoizedState;
  if (s !== null) {
      n.pending = null;
      var o = s = s.next;
      do i = e(i, o.action), o = o.next; while (o !== s);
      hn(i, t.memoizedState) || (vt = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i
  }
  return [i, r]
}

function db() {}

function hb(e, t) {
  var n = Te,
      r = Ht(),
      s = t(),
      i = !hn(r.memoizedState, s);
  if (i && (r.memoizedState = s, vt = !0), r = r.queue, nm(mb.bind(null, n, r, e), [e]), r.getSnapshot !== t || i || ze !== null && ze.memoizedState.tag & 1) {
      if (n.flags |= 2048, Aa(9, pb.bind(null, n, r, s, t), void 0, null), We === null) throw Error(O(349));
      zs & 30 || fb(n, t, s)
  }
  return s
}

function fb(e, t, n) {
  e.flags |= 16384, e = {
      getSnapshot: t,
      value: n
  }, t = Te.updateQueue, t === null ? (t = {
      lastEffect: null,
      stores: null
  }, Te.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e))
}

function pb(e, t, n, r) {
  t.value = n, t.getSnapshot = r, gb(t) && yb(e)
}

function mb(e, t, n) {
  return n(function() {
      gb(t) && yb(e)
  })
}

function gb(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
      var n = t();
      return !hn(e, n)
  } catch {
      return !0
  }
}

function yb(e) {
  var t = Gn(e, 1);
  t !== null && dn(t, e, 1, -1)
}

function Py(e) {
  var t = wn();
  return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Pa,
      lastRenderedState: e
  }, t.queue = e, e = e.dispatch = tP.bind(null, Te, e), [t.memoizedState, e]
}

function Aa(e, t, n, r) {
  return e = {
      tag: e,
      create: t,
      destroy: n,
      deps: r,
      next: null
  }, t = Te.updateQueue, t === null ? (t = {
      lastEffect: null,
      stores: null
  }, Te.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e
}

function vb() {
  return Ht().memoizedState
}

function oc(e, t, n, r) {
  var s = wn();
  Te.flags |= e, s.memoizedState = Aa(1 | t, n, void 0, r === void 0 ? null : r)
}

function wu(e, t, n, r) {
  var s = Ht();
  r = r === void 0 ? null : r;
  var i = void 0;
  if (Ue !== null) {
      var o = Ue.memoizedState;
      if (i = o.destroy, r !== null && Zp(r, o.deps)) {
          s.memoizedState = Aa(t, n, i, r);
          return
      }
  }
  Te.flags |= e, s.memoizedState = Aa(1 | t, n, i, r)
}

function Ay(e, t) {
  return oc(8390656, 8, e, t)
}

function nm(e, t) {
  return wu(2048, 8, e, t)
}

function wb(e, t) {
  return wu(4, 2, e, t)
}

function xb(e, t) {
  return wu(4, 4, e, t)
}

function bb(e, t) {
  if (typeof t == "function") return e = e(), t(e),
      function() {
          t(null)
      };
  if (t != null) return e = e(), t.current = e,
      function() {
          t.current = null
      }
}

function Sb(e, t, n) {
  return n = n != null ? n.concat([e]) : null, wu(4, 4, bb.bind(null, t, e), n)
}

function rm() {}

function _b(e, t) {
  var n = Ht();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && Zp(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
}

function Eb(e, t) {
  var n = Ht();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && Zp(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
}

function Cb(e, t, n) {
  return zs & 21 ? (hn(n, t) || (n = Ax(), Te.lanes |= n, Ws |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, vt = !0), e.memoizedState = n)
}

function ZR(e, t) {
  var n = he;
  he = n !== 0 && 4 > n ? n : 4, e(!0);
  var r = Ed.transition;
  Ed.transition = {};
  try {
      e(!1), t()
  } finally {
      he = n, Ed.transition = r
  }
}

function Tb() {
  return Ht().memoizedState
}

function eP(e, t, n) {
  var r = Wr(e);
  if (n = {
          lane: r,
          action: n,
          hasEagerState: !1,
          eagerState: null,
          next: null
      }, kb(e)) Rb(t, n);
  else if (n = lb(e, t, n, r), n !== null) {
      var s = ct();
      dn(n, e, r, s), Pb(n, t, r)
  }
}

function tP(e, t, n) {
  var r = Wr(e),
      s = {
          lane: r,
          action: n,
          hasEagerState: !1,
          eagerState: null,
          next: null
      };
  if (kb(e)) Rb(t, s);
  else {
      var i = e.alternate;
      if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null)) try {
          var o = t.lastRenderedState,
              a = i(o, n);
          if (s.hasEagerState = !0, s.eagerState = a, hn(a, o)) {
              var l = t.interleaved;
              l === null ? (s.next = s, Gp(t)) : (s.next = l.next, l.next = s), t.interleaved = s;
              return
          }
      } catch {} finally {}
      n = lb(e, t, s, r), n !== null && (s = ct(), dn(n, e, r, s), Pb(n, t, r))
  }
}

function kb(e) {
  var t = e.alternate;
  return e === Te || t !== null && t === Te
}

function Rb(e, t) {
  sa = $c = !0;
  var n = e.pending;
  n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
}

function Pb(e, t, n) {
  if (n & 4194240) {
      var r = t.lanes;
      r &= e.pendingLanes, n |= r, t.lanes = n, Ip(e, n)
  }
}
var Fc = {
      readContext: Wt,
      useCallback: Xe,
      useContext: Xe,
      useEffect: Xe,
      useImperativeHandle: Xe,
      useInsertionEffect: Xe,
      useLayoutEffect: Xe,
      useMemo: Xe,
      useReducer: Xe,
      useRef: Xe,
      useState: Xe,
      useDebugValue: Xe,
      useDeferredValue: Xe,
      useTransition: Xe,
      useMutableSource: Xe,
      useSyncExternalStore: Xe,
      useId: Xe,
      unstable_isNewReconciler: !1
  },
  nP = {
      readContext: Wt,
      useCallback: function(e, t) {
          return wn().memoizedState = [e, t === void 0 ? null : t], e
      },
      useContext: Wt,
      useEffect: Ay,
      useImperativeHandle: function(e, t, n) {
          return n = n != null ? n.concat([e]) : null, oc(4194308, 4, bb.bind(null, t, e), n)
      },
      useLayoutEffect: function(e, t) {
          return oc(4194308, 4, e, t)
      },
      useInsertionEffect: function(e, t) {
          return oc(4, 2, e, t)
      },
      useMemo: function(e, t) {
          var n = wn();
          return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e
      },
      useReducer: function(e, t, n) {
          var r = wn();
          return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: e,
              lastRenderedState: t
          }, r.queue = e, e = e.dispatch = eP.bind(null, Te, e), [r.memoizedState, e]
      },
      useRef: function(e) {
          var t = wn();
          return e = {
              current: e
          }, t.memoizedState = e
      },
      useState: Py,
      useDebugValue: rm,
      useDeferredValue: function(e) {
          return wn().memoizedState = e
      },
      useTransition: function() {
          var e = Py(!1),
              t = e[0];
          return e = ZR.bind(null, e[1]), wn().memoizedState = e, [t, e]
      },
      useMutableSource: function() {},
      useSyncExternalStore: function(e, t, n) {
          var r = Te,
              s = wn();
          if (be) {
              if (n === void 0) throw Error(O(407));
              n = n()
          } else {
              if (n = t(), We === null) throw Error(O(349));
              zs & 30 || fb(r, t, n)
          }
          s.memoizedState = n;
          var i = {
              value: n,
              getSnapshot: t
          };
          return s.queue = i, Ay(mb.bind(null, r, i, e), [e]), r.flags |= 2048, Aa(9, pb.bind(null, r, i, n, t), void 0, null), n
      },
      useId: function() {
          var e = wn(),
              t = We.identifierPrefix;
          if (be) {
              var n = zn,
                  r = Bn;
              n = (r & ~(1 << 32 - un(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Ra++, 0 < n && (t += "H" + n.toString(32)), t += ":"
          } else n = XR++, t = ":" + t + "r" + n.toString(32) + ":";
          return e.memoizedState = t
      },
      unstable_isNewReconciler: !1
  },
  rP = {
      readContext: Wt,
      useCallback: _b,
      useContext: Wt,
      useEffect: nm,
      useImperativeHandle: Sb,
      useInsertionEffect: wb,
      useLayoutEffect: xb,
      useMemo: Eb,
      useReducer: Cd,
      useRef: vb,
      useState: function() {
          return Cd(Pa)
      },
      useDebugValue: rm,
      useDeferredValue: function(e) {
          var t = Ht();
          return Cb(t, Ue.memoizedState, e)
      },
      useTransition: function() {
          var e = Cd(Pa)[0],
              t = Ht().memoizedState;
          return [e, t]
      },
      useMutableSource: db,
      useSyncExternalStore: hb,
      useId: Tb,
      unstable_isNewReconciler: !1
  },
  sP = {
      readContext: Wt,
      useCallback: _b,
      useContext: Wt,
      useEffect: nm,
      useImperativeHandle: Sb,
      useInsertionEffect: wb,
      useLayoutEffect: xb,
      useMemo: Eb,
      useReducer: Td,
      useRef: vb,
      useState: function() {
          return Td(Pa)
      },
      useDebugValue: rm,
      useDeferredValue: function(e) {
          var t = Ht();
          return Ue === null ? t.memoizedState = e : Cb(t, Ue.memoizedState, e)
      },
      useTransition: function() {
          var e = Td(Pa)[0],
              t = Ht().memoizedState;
          return [e, t]
      },
      useMutableSource: db,
      useSyncExternalStore: hb,
      useId: Tb,
      unstable_isNewReconciler: !1
  };

function nn(e, t) {
  if (e && e.defaultProps) {
      t = ke({}, t), e = e.defaultProps;
      for (var n in e) t[n] === void 0 && (t[n] = e[n]);
      return t
  }
  return t
}

function qh(e, t, n, r) {
  t = e.memoizedState, n = n(r, t), n = n == null ? t : ke({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n)
}
var xu = {
  isMounted: function(e) {
      return (e = e._reactInternals) ? Js(e) === e : !1
  },
  enqueueSetState: function(e, t, n) {
      e = e._reactInternals;
      var r = ct(),
          s = Wr(e),
          i = Wn(r, s);
      i.payload = t, n != null && (i.callback = n), t = Br(e, i, s), t !== null && (dn(t, e, s, r), sc(t, e, s))
  },
  enqueueReplaceState: function(e, t, n) {
      e = e._reactInternals;
      var r = ct(),
          s = Wr(e),
          i = Wn(r, s);
      i.tag = 1, i.payload = t, n != null && (i.callback = n), t = Br(e, i, s), t !== null && (dn(t, e, s, r), sc(t, e, s))
  },
  enqueueForceUpdate: function(e, t) {
      e = e._reactInternals;
      var n = ct(),
          r = Wr(e),
          s = Wn(n, r);
      s.tag = 2, t != null && (s.callback = t), t = Br(e, s, r), t !== null && (dn(t, e, r, n), sc(t, e, r))
  }
};

function Ny(e, t, n, r, s, i, o) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !Sa(n, r) || !Sa(s, i) : !0
}

function Ab(e, t, n) {
  var r = !1,
      s = Yr,
      i = t.contextType;
  return typeof i == "object" && i !== null ? i = Wt(i) : (s = bt(t) ? Vs : rt.current, r = t.contextTypes, i = (r = r != null) ? co(e, s) : Yr), t = new t(n, i), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = xu, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = s, e.__reactInternalMemoizedMaskedChildContext = i), t
}

function jy(e, t, n, r) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && xu.enqueueReplaceState(t, t.state, null)
}

function Gh(e, t, n, r) {
  var s = e.stateNode;
  s.props = n, s.state = e.memoizedState, s.refs = {}, Qp(e);
  var i = t.contextType;
  typeof i == "object" && i !== null ? s.context = Wt(i) : (i = bt(t) ? Vs : rt.current, s.context = co(e, i)), s.state = e.memoizedState, i = t.getDerivedStateFromProps, typeof i == "function" && (qh(e, t, i, n), s.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), t !== s.state && xu.enqueueReplaceState(s, s.state, null), Mc(e, n, s, r), s.state = e.memoizedState), typeof s.componentDidMount == "function" && (e.flags |= 4194308)
}

function po(e, t) {
  try {
      var n = "",
          r = t;
      do n += jk(r), r = r.return; while (r);
      var s = n
  } catch (i) {
      s = `
Error generating stack: ` + i.message + `
` + i.stack
  }
  return {
      value: e,
      source: t,
      stack: s,
      digest: null
  }
}

function kd(e, t, n) {
  return {
      value: e,
      source: null,
      stack: n ?? null,
      digest: t ?? null
  }
}

function Qh(e, t) {
  try {
      console.error(t.value)
  } catch (n) {
      setTimeout(function() {
          throw n
      })
  }
}
var iP = typeof WeakMap == "function" ? WeakMap : Map;

function Nb(e, t, n) {
  n = Wn(-1, n), n.tag = 3, n.payload = {
      element: null
  };
  var r = t.value;
  return n.callback = function() {
      Vc || (Vc = !0, of = r), Qh(e, t)
  }, n
}

function jb(e, t, n) {
  n = Wn(-1, n), n.tag = 3;
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
      var s = t.value;
      n.payload = function() {
          return r(s)
      }, n.callback = function() {
          Qh(e, t)
      }
  }
  var i = e.stateNode;
  return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function() {
      Qh(e, t), typeof r != "function" && (zr === null ? zr = new Set([this]) : zr.add(this));
      var o = t.stack;
      this.componentDidCatch(t.value, {
          componentStack: o !== null ? o : ""
      })
  }), n
}

function Oy(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
      r = e.pingCache = new iP;
      var s = new Set;
      r.set(t, s)
  } else s = r.get(t), s === void 0 && (s = new Set, r.set(t, s));
  s.has(n) || (s.add(n), e = wP.bind(null, e, t, n), t.then(e, e))
}

function Iy(e) {
  do {
      var t;
      if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
      e = e.return
  } while (e !== null);
  return null
}

function Dy(e, t, n, r, s) {
  return e.mode & 1 ? (e.flags |= 65536, e.lanes = s, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Wn(-1, 1), t.tag = 2, Br(n, t, 1))), n.lanes |= 1), e)
}
var oP = er.ReactCurrentOwner,
  vt = !1;

function ot(e, t, n, r) {
  t.child = e === null ? ab(t, null, n, r) : ho(t, e.child, n, r)
}

function My(e, t, n, r, s) {
  n = n.render;
  var i = t.ref;
  return Vi(t, s), r = em(e, t, n, r, i, s), n = tm(), e !== null && !vt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, Qn(e, t, s)) : (be && n && Bp(t), t.flags |= 1, ot(e, t, r, s), t.child)
}

function Ly(e, t, n, r, s) {
  if (e === null) {
      var i = n.type;
      return typeof i == "function" && !dm(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = i, Ob(e, t, i, r, s)) : (e = uc(n.type, null, r, t, t.mode, s), e.ref = t.ref, e.return = t, t.child = e)
  }
  if (i = e.child, !(e.lanes & s)) {
      var o = i.memoizedProps;
      if (n = n.compare, n = n !== null ? n : Sa, n(o, r) && e.ref === t.ref) return Qn(e, t, s)
  }
  return t.flags |= 1, e = Hr(i, r), e.ref = t.ref, e.return = t, t.child = e
}

function Ob(e, t, n, r, s) {
  if (e !== null) {
      var i = e.memoizedProps;
      if (Sa(i, r) && e.ref === t.ref)
          if (vt = !1, t.pendingProps = r = i, (e.lanes & s) !== 0) e.flags & 131072 && (vt = !0);
          else return t.lanes = e.lanes, Qn(e, t, s)
  }
  return Yh(e, t, n, r, s)
}

function Ib(e, t, n) {
  var r = t.pendingProps,
      s = r.children,
      i = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden")
      if (!(t.mode & 1)) t.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null
      }, me(Ai, Et), Et |= n;
      else {
          if (!(n & 1073741824)) return e = i !== null ? i.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
              baseLanes: e,
              cachePool: null,
              transitions: null
          }, t.updateQueue = null, me(Ai, Et), Et |= e, null;
          t.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
          }, r = i !== null ? i.baseLanes : n, me(Ai, Et), Et |= r
      }
  else i !== null ? (r = i.baseLanes | n, t.memoizedState = null) : r = n, me(Ai, Et), Et |= r;
  return ot(e, t, s, n), t.child
}

function Db(e, t) {
  var n = t.ref;
  (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
}

function Yh(e, t, n, r, s) {
  var i = bt(n) ? Vs : rt.current;
  return i = co(t, i), Vi(t, s), n = em(e, t, n, r, i, s), r = tm(), e !== null && !vt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~s, Qn(e, t, s)) : (be && r && Bp(t), t.flags |= 1, ot(e, t, n, s), t.child)
}

function $y(e, t, n, r, s) {
  if (bt(n)) {
      var i = !0;
      Nc(t)
  } else i = !1;
  if (Vi(t, s), t.stateNode === null) ac(e, t), Ab(t, n, r), Gh(t, n, r, s), r = !0;
  else if (e === null) {
      var o = t.stateNode,
          a = t.memoizedProps;
      o.props = a;
      var l = o.context,
          c = n.contextType;
      typeof c == "object" && c !== null ? c = Wt(c) : (c = bt(n) ? Vs : rt.current, c = co(t, c));
      var u = n.getDerivedStateFromProps,
          d = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
      d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== c) && jy(t, o, r, c), wr = !1;
      var h = t.memoizedState;
      o.state = h, Mc(t, r, o, s), l = t.memoizedState, a !== r || h !== l || xt.current || wr ? (typeof u == "function" && (qh(t, n, u, r), l = t.memoizedState), (a = wr || Ny(t, n, a, r, h, l, c)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1)
  } else {
      o = t.stateNode, cb(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : nn(t.type, a), o.props = c, d = t.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Wt(l) : (l = bt(n) ? Vs : rt.current, l = co(t, l));
      var f = n.getDerivedStateFromProps;
      (u = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || h !== l) && jy(t, o, r, l), wr = !1, h = t.memoizedState, o.state = h, Mc(t, r, o, s);
      var x = t.memoizedState;
      a !== d || h !== x || xt.current || wr ? (typeof f == "function" && (qh(t, n, f, r), x = t.memoizedState), (c = wr || Ny(t, n, c, r, h, x, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, x, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, x, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = x), o.props = r, o.state = x, o.context = l, r = c) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
  }
  return Jh(e, t, n, r, i, s)
}

function Jh(e, t, n, r, s, i) {
  Db(e, t);
  var o = (t.flags & 128) !== 0;
  if (!r && !o) return s && _y(t, n, !1), Qn(e, t, i);
  r = t.stateNode, oP.current = t;
  var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return t.flags |= 1, e !== null && o ? (t.child = ho(t, e.child, null, i), t.child = ho(t, null, a, i)) : ot(e, t, a, i), t.memoizedState = r.state, s && _y(t, n, !0), t.child
}

function Mb(e) {
  var t = e.stateNode;
  t.pendingContext ? Sy(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Sy(e, t.context, !1), Yp(e, t.containerInfo)
}

function Fy(e, t, n, r, s) {
  return uo(), Wp(s), t.flags |= 256, ot(e, t, n, r), t.child
}
var Xh = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};

function Zh(e) {
  return {
      baseLanes: e,
      cachePool: null,
      transitions: null
  }
}

function Lb(e, t, n) {
  var r = t.pendingProps,
      s = Ee.current,
      i = !1,
      o = (t.flags & 128) !== 0,
      a;
  if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0), a ? (i = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1), me(Ee, s & 1), e === null) return Hh(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, i ? (r = t.mode, i = t.child, o = {
      mode: "hidden",
      children: o
  }, !(r & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = o) : i = _u(o, r, 0, null), e = $s(e, r, n, null), i.return = t, e.return = t, i.sibling = e, t.child = i, t.child.memoizedState = Zh(n), t.memoizedState = Xh, e) : sm(t, o));
  if (s = e.memoizedState, s !== null && (a = s.dehydrated, a !== null)) return aP(e, t, o, r, a, s, n);
  if (i) {
      i = r.fallback, o = t.mode, s = e.child, a = s.sibling;
      var l = {
          mode: "hidden",
          children: r.children
      };
      return !(o & 1) && t.child !== s ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = Hr(s, l), r.subtreeFlags = s.subtreeFlags & 14680064), a !== null ? i = Hr(a, i) : (i = $s(i, o, n, null), i.flags |= 2), i.return = t, r.return = t, r.sibling = i, t.child = r, r = i, i = t.child, o = e.child.memoizedState, o = o === null ? Zh(n) : {
          baseLanes: o.baseLanes | n,
          cachePool: null,
          transitions: o.transitions
      }, i.memoizedState = o, i.childLanes = e.childLanes & ~n, t.memoizedState = Xh, r
  }
  return i = e.child, e = i.sibling, r = Hr(i, {
      mode: "visible",
      children: r.children
  }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r
}

function sm(e, t) {
  return t = _u({
      mode: "visible",
      children: t
  }, e.mode, 0, null), t.return = e, e.child = t
}

function jl(e, t, n, r) {
  return r !== null && Wp(r), ho(t, e.child, null, n), e = sm(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e
}

function aP(e, t, n, r, s, i, o) {
  if (n) return t.flags & 256 ? (t.flags &= -257, r = kd(Error(O(422))), jl(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (i = r.fallback, s = t.mode, r = _u({
      mode: "visible",
      children: r.children
  }, s, 0, null), i = $s(i, s, o, null), i.flags |= 2, r.return = t, i.return = t, r.sibling = i, t.child = r, t.mode & 1 && ho(t, e.child, null, o), t.child.memoizedState = Zh(o), t.memoizedState = Xh, i);
  if (!(t.mode & 1)) return jl(e, t, o, null);
  if (s.data === "$!") {
      if (r = s.nextSibling && s.nextSibling.dataset, r) var a = r.dgst;
      return r = a, i = Error(O(419)), r = kd(i, r, void 0), jl(e, t, o, r)
  }
  if (a = (o & e.childLanes) !== 0, vt || a) {
      if (r = We, r !== null) {
          switch (o & -o) {
              case 4:
                  s = 2;
                  break;
              case 16:
                  s = 8;
                  break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                  s = 32;
                  break;
              case 536870912:
                  s = 268435456;
                  break;
              default:
                  s = 0
          }
          s = s & (r.suspendedLanes | o) ? 0 : s, s !== 0 && s !== i.retryLane && (i.retryLane = s, Gn(e, s), dn(r, e, s, -1))
      }
      return um(), r = kd(Error(O(421))), jl(e, t, o, r)
  }
  return s.data === "$?" ? (t.flags |= 128, t.child = e.child, t = xP.bind(null, e), s._reactRetry = t, null) : (e = i.treeContext, Rt = Vr(s.nextSibling), Pt = t, be = !0, cn = null, e !== null && ($t[Ft++] = Bn, $t[Ft++] = zn, $t[Ft++] = Bs, Bn = e.id, zn = e.overflow, Bs = t), t = sm(t, r.children), t.flags |= 4096, t)
}

function Uy(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), Kh(e.return, t, n)
}

function Rd(e, t, n, r, s) {
  var i = e.memoizedState;
  i === null ? e.memoizedState = {
      isBackwards: t,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: n,
      tailMode: s
  } : (i.isBackwards = t, i.rendering = null, i.renderingStartTime = 0, i.last = r, i.tail = n, i.tailMode = s)
}

function $b(e, t, n) {
  var r = t.pendingProps,
      s = r.revealOrder,
      i = r.tail;
  if (ot(e, t, r.children, n), r = Ee.current, r & 2) r = r & 1 | 2, t.flags |= 128;
  else {
      if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) {
          if (e.tag === 13) e.memoizedState !== null && Uy(e, n, t);
          else if (e.tag === 19) Uy(e, n, t);
          else if (e.child !== null) {
              e.child.return = e, e = e.child;
              continue
          }
          if (e === t) break e;
          for (; e.sibling === null;) {
              if (e.return === null || e.return === t) break e;
              e = e.return
          }
          e.sibling.return = e.return, e = e.sibling
      }
      r &= 1
  }
  if (me(Ee, r), !(t.mode & 1)) t.memoizedState = null;
  else switch (s) {
      case "forwards":
          for (n = t.child, s = null; n !== null;) e = n.alternate, e !== null && Lc(e) === null && (s = n), n = n.sibling;
          n = s, n === null ? (s = t.child, t.child = null) : (s = n.sibling, n.sibling = null), Rd(t, !1, s, n, i);
          break;
      case "backwards":
          for (n = null, s = t.child, t.child = null; s !== null;) {
              if (e = s.alternate, e !== null && Lc(e) === null) {
                  t.child = s;
                  break
              }
              e = s.sibling, s.sibling = n, n = s, s = e
          }
          Rd(t, !0, n, null, i);
          break;
      case "together":
          Rd(t, !1, null, null, void 0);
          break;
      default:
          t.memoizedState = null
  }
  return t.child
}

function ac(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2)
}

function Qn(e, t, n) {
  if (e !== null && (t.dependencies = e.dependencies), Ws |= t.lanes, !(n & t.childLanes)) return null;
  if (e !== null && t.child !== e.child) throw Error(O(153));
  if (t.child !== null) {
      for (e = t.child, n = Hr(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;) e = e.sibling, n = n.sibling = Hr(e, e.pendingProps), n.return = t;
      n.sibling = null
  }
  return t.child
}

function lP(e, t, n) {
  switch (t.tag) {
      case 3:
          Mb(t), uo();
          break;
      case 5:
          ub(t);
          break;
      case 1:
          bt(t.type) && Nc(t);
          break;
      case 4:
          Yp(t, t.stateNode.containerInfo);
          break;
      case 10:
          var r = t.type._context,
              s = t.memoizedProps.value;
          me(Ic, r._currentValue), r._currentValue = s;
          break;
      case 13:
          if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (me(Ee, Ee.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Lb(e, t, n) : (me(Ee, Ee.current & 1), e = Qn(e, t, n), e !== null ? e.sibling : null);
          me(Ee, Ee.current & 1);
          break;
      case 19:
          if (r = (n & t.childLanes) !== 0, e.flags & 128) {
              if (r) return $b(e, t, n);
              t.flags |= 128
          }
          if (s = t.memoizedState, s !== null && (s.rendering = null, s.tail = null, s.lastEffect = null), me(Ee, Ee.current), r) break;
          return null;
      case 22:
      case 23:
          return t.lanes = 0, Ib(e, t, n)
  }
  return Qn(e, t, n)
}
var Fb, ef, Ub, Vb;
Fb = function(e, t) {
  for (var n = t.child; n !== null;) {
      if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
      else if (n.tag !== 4 && n.child !== null) {
          n.child.return = n, n = n.child;
          continue
      }
      if (n === t) break;
      for (; n.sibling === null;) {
          if (n.return === null || n.return === t) return;
          n = n.return
      }
      n.sibling.return = n.return, n = n.sibling
  }
};
ef = function() {};
Ub = function(e, t, n, r) {
  var s = e.memoizedProps;
  if (s !== r) {
      e = t.stateNode, Es(kn.current);
      var i = null;
      switch (n) {
          case "input":
              s = Sh(e, s), r = Sh(e, r), i = [];
              break;
          case "select":
              s = ke({}, s, {
                  value: void 0
              }), r = ke({}, r, {
                  value: void 0
              }), i = [];
              break;
          case "textarea":
              s = Ch(e, s), r = Ch(e, r), i = [];
              break;
          default:
              typeof s.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Pc)
      }
      kh(n, r);
      var o;
      n = null;
      for (c in s)
          if (!r.hasOwnProperty(c) && s.hasOwnProperty(c) && s[c] != null)
              if (c === "style") {
                  var a = s[c];
                  for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
              } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (ma.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null));
      for (c in r) {
          var l = r[c];
          if (a = s != null ? s[c] : void 0, r.hasOwnProperty(c) && l !== a && (l != null || a != null))
              if (c === "style")
                  if (a) {
                      for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                      for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o])
                  } else n || (i || (i = []), i.push(c, n)), n = l;
          else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (ma.hasOwnProperty(c) ? (l != null && c === "onScroll" && ye("scroll", e), i || a === l || (i = [])) : (i = i || []).push(c, l))
      }
      n && (i = i || []).push("style", n);
      var c = i;
      (t.updateQueue = c) && (t.flags |= 4)
  }
};
Vb = function(e, t, n, r) {
  n !== r && (t.flags |= 4)
};

function Uo(e, t) {
  if (!be) switch (e.tailMode) {
      case "hidden":
          t = e.tail;
          for (var n = null; t !== null;) t.alternate !== null && (n = t), t = t.sibling;
          n === null ? e.tail = null : n.sibling = null;
          break;
      case "collapsed":
          n = e.tail;
          for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
          r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
  }
}

function Ze(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
      n = 0,
      r = 0;
  if (t)
      for (var s = e.child; s !== null;) n |= s.lanes | s.childLanes, r |= s.subtreeFlags & 14680064, r |= s.flags & 14680064, s.return = e, s = s.sibling;
  else
      for (s = e.child; s !== null;) n |= s.lanes | s.childLanes, r |= s.subtreeFlags, r |= s.flags, s.return = e, s = s.sibling;
  return e.subtreeFlags |= r, e.childLanes = n, t
}

function cP(e, t, n) {
  var r = t.pendingProps;
  switch (zp(t), t.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
          return Ze(t), null;
      case 1:
          return bt(t.type) && Ac(), Ze(t), null;
      case 3:
          return r = t.stateNode, fo(), ve(xt), ve(rt), Xp(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Al(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, cn !== null && (cf(cn), cn = null))), ef(e, t), Ze(t), null;
      case 5:
          Jp(t);
          var s = Es(ka.current);
          if (n = t.type, e !== null && t.stateNode != null) Ub(e, t, n, r, s), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
          else {
              if (!r) {
                  if (t.stateNode === null) throw Error(O(166));
                  return Ze(t), null
              }
              if (e = Es(kn.current), Al(t)) {
                  r = t.stateNode, n = t.type;
                  var i = t.memoizedProps;
                  switch (r[_n] = t, r[Ca] = i, e = (t.mode & 1) !== 0, n) {
                      case "dialog":
                          ye("cancel", r), ye("close", r);
                          break;
                      case "iframe":
                      case "object":
                      case "embed":
                          ye("load", r);
                          break;
                      case "video":
                      case "audio":
                          for (s = 0; s < Go.length; s++) ye(Go[s], r);
                          break;
                      case "source":
                          ye("error", r);
                          break;
                      case "img":
                      case "image":
                      case "link":
                          ye("error", r), ye("load", r);
                          break;
                      case "details":
                          ye("toggle", r);
                          break;
                      case "input":
                          Qg(r, i), ye("invalid", r);
                          break;
                      case "select":
                          r._wrapperState = {
                              wasMultiple: !!i.multiple
                          }, ye("invalid", r);
                          break;
                      case "textarea":
                          Jg(r, i), ye("invalid", r)
                  }
                  kh(n, i), s = null;
                  for (var o in i)
                      if (i.hasOwnProperty(o)) {
                          var a = i[o];
                          o === "children" ? typeof a == "string" ? r.textContent !== a && (i.suppressHydrationWarning !== !0 && Pl(r.textContent, a, e), s = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && Pl(r.textContent, a, e), s = ["children", "" + a]) : ma.hasOwnProperty(o) && a != null && o === "onScroll" && ye("scroll", r)
                      } switch (n) {
                      case "input":
                          bl(r), Yg(r, i, !0);
                          break;
                      case "textarea":
                          bl(r), Xg(r);
                          break;
                      case "select":
                      case "option":
                          break;
                      default:
                          typeof i.onClick == "function" && (r.onclick = Pc)
                  }
                  r = s, t.updateQueue = r, r !== null && (t.flags |= 4)
              } else {
                  o = s.nodeType === 9 ? s : s.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = mx(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, {
                      is: r.is
                  }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[_n] = t, e[Ca] = r, Fb(e, t, !1, !1), t.stateNode = e;
                  e: {
                      switch (o = Rh(n, r), n) {
                          case "dialog":
                              ye("cancel", e), ye("close", e), s = r;
                              break;
                          case "iframe":
                          case "object":
                          case "embed":
                              ye("load", e), s = r;
                              break;
                          case "video":
                          case "audio":
                              for (s = 0; s < Go.length; s++) ye(Go[s], e);
                              s = r;
                              break;
                          case "source":
                              ye("error", e), s = r;
                              break;
                          case "img":
                          case "image":
                          case "link":
                              ye("error", e), ye("load", e), s = r;
                              break;
                          case "details":
                              ye("toggle", e), s = r;
                              break;
                          case "input":
                              Qg(e, r), s = Sh(e, r), ye("invalid", e);
                              break;
                          case "option":
                              s = r;
                              break;
                          case "select":
                              e._wrapperState = {
                                  wasMultiple: !!r.multiple
                              }, s = ke({}, r, {
                                  value: void 0
                              }), ye("invalid", e);
                              break;
                          case "textarea":
                              Jg(e, r), s = Ch(e, r), ye("invalid", e);
                              break;
                          default:
                              s = r
                      }
                      kh(n, s),
                      a = s;
                      for (i in a)
                          if (a.hasOwnProperty(i)) {
                              var l = a[i];
                              i === "style" ? vx(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && gx(e, l)) : i === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ga(e, l) : typeof l == "number" && ga(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (ma.hasOwnProperty(i) ? l != null && i === "onScroll" && ye("scroll", e) : l != null && Rp(e, i, l, o))
                          } switch (n) {
                          case "input":
                              bl(e), Yg(e, r, !1);
                              break;
                          case "textarea":
                              bl(e), Xg(e);
                              break;
                          case "option":
                              r.value != null && e.setAttribute("value", "" + Qr(r.value));
                              break;
                          case "select":
                              e.multiple = !!r.multiple, i = r.value, i != null ? Li(e, !!r.multiple, i, !1) : r.defaultValue != null && Li(e, !!r.multiple, r.defaultValue, !0);
                              break;
                          default:
                              typeof s.onClick == "function" && (e.onclick = Pc)
                      }
                      switch (n) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                              r = !!r.autoFocus;
                              break e;
                          case "img":
                              r = !0;
                              break e;
                          default:
                              r = !1
                      }
                  }
                  r && (t.flags |= 4)
              }
              t.ref !== null && (t.flags |= 512, t.flags |= 2097152)
          }
          return Ze(t), null;
      case 6:
          if (e && t.stateNode != null) Vb(e, t, e.memoizedProps, r);
          else {
              if (typeof r != "string" && t.stateNode === null) throw Error(O(166));
              if (n = Es(ka.current), Es(kn.current), Al(t)) {
                  if (r = t.stateNode, n = t.memoizedProps, r[_n] = t, (i = r.nodeValue !== n) && (e = Pt, e !== null)) switch (e.tag) {
                      case 3:
                          Pl(r.nodeValue, n, (e.mode & 1) !== 0);
                          break;
                      case 5:
                          e.memoizedProps.suppressHydrationWarning !== !0 && Pl(r.nodeValue, n, (e.mode & 1) !== 0)
                  }
                  i && (t.flags |= 4)
              } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[_n] = t, t.stateNode = r
          }
          return Ze(t), null;
      case 13:
          if (ve(Ee), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
              if (be && Rt !== null && t.mode & 1 && !(t.flags & 128)) ib(), uo(), t.flags |= 98560, i = !1;
              else if (i = Al(t), r !== null && r.dehydrated !== null) {
                  if (e === null) {
                      if (!i) throw Error(O(318));
                      if (i = t.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(O(317));
                      i[_n] = t
                  } else uo(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
                  Ze(t), i = !1
              } else cn !== null && (cf(cn), cn = null), i = !0;
              if (!i) return t.flags & 65536 ? t : null
          }
          return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Ee.current & 1 ? Be === 0 && (Be = 3) : um())), t.updateQueue !== null && (t.flags |= 4), Ze(t), null);
      case 4:
          return fo(), ef(e, t), e === null && _a(t.stateNode.containerInfo), Ze(t), null;
      case 10:
          return qp(t.type._context), Ze(t), null;
      case 17:
          return bt(t.type) && Ac(), Ze(t), null;
      case 19:
          if (ve(Ee), i = t.memoizedState, i === null) return Ze(t), null;
          if (r = (t.flags & 128) !== 0, o = i.rendering, o === null)
              if (r) Uo(i, !1);
              else {
                  if (Be !== 0 || e !== null && e.flags & 128)
                      for (e = t.child; e !== null;) {
                          if (o = Lc(e), o !== null) {
                              for (t.flags |= 128, Uo(i, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;) i = n, e = r, i.flags &= 14680066, o = i.alternate, o === null ? (i.childLanes = 0, i.lanes = e, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, i.type = o.type, e = o.dependencies, i.dependencies = e === null ? null : {
                                  lanes: e.lanes,
                                  firstContext: e.firstContext
                              }), n = n.sibling;
                              return me(Ee, Ee.current & 1 | 2), t.child
                          }
                          e = e.sibling
                      }
                  i.tail !== null && je() > mo && (t.flags |= 128, r = !0, Uo(i, !1), t.lanes = 4194304)
              }
          else {
              if (!r)
                  if (e = Lc(o), e !== null) {
                      if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Uo(i, !0), i.tail === null && i.tailMode === "hidden" && !o.alternate && !be) return Ze(t), null
                  } else 2 * je() - i.renderingStartTime > mo && n !== 1073741824 && (t.flags |= 128, r = !0, Uo(i, !1), t.lanes = 4194304);
              i.isBackwards ? (o.sibling = t.child, t.child = o) : (n = i.last, n !== null ? n.sibling = o : t.child = o, i.last = o)
          }
          return i.tail !== null ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = je(), t.sibling = null, n = Ee.current, me(Ee, r ? n & 1 | 2 : n & 1), t) : (Ze(t), null);
      case 22:
      case 23:
          return cm(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Et & 1073741824 && (Ze(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ze(t), null;
      case 24:
          return null;
      case 25:
          return null
  }
  throw Error(O(156, t.tag))
}

function uP(e, t) {
  switch (zp(t), t.tag) {
      case 1:
          return bt(t.type) && Ac(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
      case 3:
          return fo(), ve(xt), ve(rt), Xp(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
      case 5:
          return Jp(t), null;
      case 13:
          if (ve(Ee), e = t.memoizedState, e !== null && e.dehydrated !== null) {
              if (t.alternate === null) throw Error(O(340));
              uo()
          }
          return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
      case 19:
          return ve(Ee), null;
      case 4:
          return fo(), null;
      case 10:
          return qp(t.type._context), null;
      case 22:
      case 23:
          return cm(), null;
      case 24:
          return null;
      default:
          return null
  }
}
var Ol = !1,
  tt = !1,
  dP = typeof WeakSet == "function" ? WeakSet : Set,
  F = null;

function Pi(e, t) {
  var n = e.ref;
  if (n !== null)
      if (typeof n == "function") try {
          n(null)
      } catch (r) {
          Ne(e, t, r)
      } else n.current = null
}

function tf(e, t, n) {
  try {
      n()
  } catch (r) {
      Ne(e, t, r)
  }
}
var Vy = !1;

function hP(e, t) {
  if ($h = Tc, e = Kx(), Vp(e)) {
      if ("selectionStart" in e) var n = {
          start: e.selectionStart,
          end: e.selectionEnd
      };
      else e: {
          n = (n = e.ownerDocument) && n.defaultView || window;
          var r = n.getSelection && n.getSelection();
          if (r && r.rangeCount !== 0) {
              n = r.anchorNode;
              var s = r.anchorOffset,
                  i = r.focusNode;
              r = r.focusOffset;
              try {
                  n.nodeType, i.nodeType
              } catch {
                  n = null;
                  break e
              }
              var o = 0,
                  a = -1,
                  l = -1,
                  c = 0,
                  u = 0,
                  d = e,
                  h = null;
              t: for (;;) {
                  for (var f; d !== n || s !== 0 && d.nodeType !== 3 || (a = o + s), d !== i || r !== 0 && d.nodeType !== 3 || (l = o + r), d.nodeType === 3 && (o += d.nodeValue.length), (f = d.firstChild) !== null;) h = d, d = f;
                  for (;;) {
                      if (d === e) break t;
                      if (h === n && ++c === s && (a = o), h === i && ++u === r && (l = o), (f = d.nextSibling) !== null) break;
                      d = h, h = d.parentNode
                  }
                  d = f
              }
              n = a === -1 || l === -1 ? null : {
                  start: a,
                  end: l
              }
          } else n = null
      }
      n = n || {
          start: 0,
          end: 0
      }
  } else n = null;
  for (Fh = {
          focusedElem: e,
          selectionRange: n
      }, Tc = !1, F = t; F !== null;)
      if (t = F, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, F = e;
      else
          for (; F !== null;) {
              t = F;
              try {
                  var x = t.alternate;
                  if (t.flags & 1024) switch (t.tag) {
                      case 0:
                      case 11:
                      case 15:
                          break;
                      case 1:
                          if (x !== null) {
                              var m = x.memoizedProps,
                                  b = x.memoizedState,
                                  v = t.stateNode,
                                  y = v.getSnapshotBeforeUpdate(t.elementType === t.type ? m : nn(t.type, m), b);
                              v.__reactInternalSnapshotBeforeUpdate = y
                          }
                          break;
                      case 3:
                          var w = t.stateNode.containerInfo;
                          w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
                          break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                          break;
                      default:
                          throw Error(O(163))
                  }
              } catch (S) {
                  Ne(t, t.return, S)
              }
              if (e = t.sibling, e !== null) {
                  e.return = t.return, F = e;
                  break
              }
              F = t.return
          }
  return x = Vy, Vy = !1, x
}

function ia(e, t, n) {
  var r = t.updateQueue;
  if (r = r !== null ? r.lastEffect : null, r !== null) {
      var s = r = r.next;
      do {
          if ((s.tag & e) === e) {
              var i = s.destroy;
              s.destroy = void 0, i !== void 0 && tf(t, n, i)
          }
          s = s.next
      } while (s !== r)
  }
}

function bu(e, t) {
  if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
      var n = t = t.next;
      do {
          if ((n.tag & e) === e) {
              var r = n.create;
              n.destroy = r()
          }
          n = n.next
      } while (n !== t)
  }
}

function nf(e) {
  var t = e.ref;
  if (t !== null) {
      var n = e.stateNode;
      switch (e.tag) {
          case 5:
              e = n;
              break;
          default:
              e = n
      }
      typeof t == "function" ? t(e) : t.current = e
  }
}

function Bb(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, Bb(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[_n], delete t[Ca], delete t[Bh], delete t[GR], delete t[QR])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
}

function zb(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}

function By(e) {
  e: for (;;) {
      for (; e.sibling === null;) {
          if (e.return === null || zb(e.return)) return null;
          e = e.return
      }
      for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
          if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
          e.child.return = e, e = e.child
      }
      if (!(e.flags & 2)) return e.stateNode
  }
}

function rf(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Pc));
  else if (r !== 4 && (e = e.child, e !== null))
      for (rf(e, t, n), e = e.sibling; e !== null;) rf(e, t, n), e = e.sibling
}

function sf(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && (e = e.child, e !== null))
      for (sf(e, t, n), e = e.sibling; e !== null;) sf(e, t, n), e = e.sibling
}
var qe = null,
  an = !1;

function ur(e, t, n) {
  for (n = n.child; n !== null;) Wb(e, t, n), n = n.sibling
}

function Wb(e, t, n) {
  if (Tn && typeof Tn.onCommitFiberUnmount == "function") try {
      Tn.onCommitFiberUnmount(fu, n)
  } catch {}
  switch (n.tag) {
      case 5:
          tt || Pi(n, t);
      case 6:
          var r = qe,
              s = an;
          qe = null, ur(e, t, n), qe = r, an = s, qe !== null && (an ? (e = qe, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : qe.removeChild(n.stateNode));
          break;
      case 18:
          qe !== null && (an ? (e = qe, n = n.stateNode, e.nodeType === 8 ? bd(e.parentNode, n) : e.nodeType === 1 && bd(e, n), xa(e)) : bd(qe, n.stateNode));
          break;
      case 4:
          r = qe, s = an, qe = n.stateNode.containerInfo, an = !0, ur(e, t, n), qe = r, an = s;
          break;
      case 0:
      case 11:
      case 14:
      case 15:
          if (!tt && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
              s = r = r.next;
              do {
                  var i = s,
                      o = i.destroy;
                  i = i.tag, o !== void 0 && (i & 2 || i & 4) && tf(n, t, o), s = s.next
              } while (s !== r)
          }
          ur(e, t, n);
          break;
      case 1:
          if (!tt && (Pi(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
              r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
          } catch (a) {
              Ne(n, t, a)
          }
          ur(e, t, n);
          break;
      case 21:
          ur(e, t, n);
          break;
      case 22:
          n.mode & 1 ? (tt = (r = tt) || n.memoizedState !== null, ur(e, t, n), tt = r) : ur(e, t, n);
          break;
      default:
          ur(e, t, n)
  }
}

function zy(e) {
  var t = e.updateQueue;
  if (t !== null) {
      e.updateQueue = null;
      var n = e.stateNode;
      n === null && (n = e.stateNode = new dP), t.forEach(function(r) {
          var s = bP.bind(null, e, r);
          n.has(r) || (n.add(r), r.then(s, s))
      })
  }
}

function Yt(e, t) {
  var n = t.deletions;
  if (n !== null)
      for (var r = 0; r < n.length; r++) {
          var s = n[r];
          try {
              var i = e,
                  o = t,
                  a = o;
              e: for (; a !== null;) {
                  switch (a.tag) {
                      case 5:
                          qe = a.stateNode, an = !1;
                          break e;
                      case 3:
                          qe = a.stateNode.containerInfo, an = !0;
                          break e;
                      case 4:
                          qe = a.stateNode.containerInfo, an = !0;
                          break e
                  }
                  a = a.return
              }
              if (qe === null) throw Error(O(160));
              Wb(i, o, s), qe = null, an = !1;
              var l = s.alternate;
              l !== null && (l.return = null), s.return = null
          } catch (c) {
              Ne(s, t, c)
          }
      }
  if (t.subtreeFlags & 12854)
      for (t = t.child; t !== null;) Hb(t, e), t = t.sibling
}

function Hb(e, t) {
  var n = e.alternate,
      r = e.flags;
  switch (e.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
          if (Yt(t, e), vn(e), r & 4) {
              try {
                  ia(3, e, e.return), bu(3, e)
              } catch (m) {
                  Ne(e, e.return, m)
              }
              try {
                  ia(5, e, e.return)
              } catch (m) {
                  Ne(e, e.return, m)
              }
          }
          break;
      case 1:
          Yt(t, e), vn(e), r & 512 && n !== null && Pi(n, n.return);
          break;
      case 5:
          if (Yt(t, e), vn(e), r & 512 && n !== null && Pi(n, n.return), e.flags & 32) {
              var s = e.stateNode;
              try {
                  ga(s, "")
              } catch (m) {
                  Ne(e, e.return, m)
              }
          }
          if (r & 4 && (s = e.stateNode, s != null)) {
              var i = e.memoizedProps,
                  o = n !== null ? n.memoizedProps : i,
                  a = e.type,
                  l = e.updateQueue;
              if (e.updateQueue = null, l !== null) try {
                  a === "input" && i.type === "radio" && i.name != null && fx(s, i), Rh(a, o);
                  var c = Rh(a, i);
                  for (o = 0; o < l.length; o += 2) {
                      var u = l[o],
                          d = l[o + 1];
                      u === "style" ? vx(s, d) : u === "dangerouslySetInnerHTML" ? gx(s, d) : u === "children" ? ga(s, d) : Rp(s, u, d, c)
                  }
                  switch (a) {
                      case "input":
                          _h(s, i);
                          break;
                      case "textarea":
                          px(s, i);
                          break;
                      case "select":
                          var h = s._wrapperState.wasMultiple;
                          s._wrapperState.wasMultiple = !!i.multiple;
                          var f = i.value;
                          f != null ? Li(s, !!i.multiple, f, !1) : h !== !!i.multiple && (i.defaultValue != null ? Li(s, !!i.multiple, i.defaultValue, !0) : Li(s, !!i.multiple, i.multiple ? [] : "", !1))
                  }
                  s[Ca] = i
              } catch (m) {
                  Ne(e, e.return, m)
              }
          }
          break;
      case 6:
          if (Yt(t, e), vn(e), r & 4) {
              if (e.stateNode === null) throw Error(O(162));
              s = e.stateNode, i = e.memoizedProps;
              try {
                  s.nodeValue = i
              } catch (m) {
                  Ne(e, e.return, m)
              }
          }
          break;
      case 3:
          if (Yt(t, e), vn(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
              xa(t.containerInfo)
          } catch (m) {
              Ne(e, e.return, m)
          }
          break;
      case 4:
          Yt(t, e), vn(e);
          break;
      case 13:
          Yt(t, e), vn(e), s = e.child, s.flags & 8192 && (i = s.memoizedState !== null, s.stateNode.isHidden = i, !i || s.alternate !== null && s.alternate.memoizedState !== null || (am = je())), r & 4 && zy(e);
          break;
      case 22:
          if (u = n !== null && n.memoizedState !== null, e.mode & 1 ? (tt = (c = tt) || u, Yt(t, e), tt = c) : Yt(t, e), vn(e), r & 8192) {
              if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && e.mode & 1)
                  for (F = e, u = e.child; u !== null;) {
                      for (d = F = u; F !== null;) {
                          switch (h = F, f = h.child, h.tag) {
                              case 0:
                              case 11:
                              case 14:
                              case 15:
                                  ia(4, h, h.return);
                                  break;
                              case 1:
                                  Pi(h, h.return);
                                  var x = h.stateNode;
                                  if (typeof x.componentWillUnmount == "function") {
                                      r = h, n = h.return;
                                      try {
                                          t = r, x.props = t.memoizedProps, x.state = t.memoizedState, x.componentWillUnmount()
                                      } catch (m) {
                                          Ne(r, n, m)
                                      }
                                  }
                                  break;
                              case 5:
                                  Pi(h, h.return);
                                  break;
                              case 22:
                                  if (h.memoizedState !== null) {
                                      Hy(d);
                                      continue
                                  }
                          }
                          f !== null ? (f.return = h, F = f) : Hy(d)
                      }
                      u = u.sibling
                  }
              e: for (u = null, d = e;;) {
                  if (d.tag === 5) {
                      if (u === null) {
                          u = d;
                          try {
                              s = d.stateNode, c ? (i = s.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = yx("display", o))
                          } catch (m) {
                              Ne(e, e.return, m)
                          }
                      }
                  } else if (d.tag === 6) {
                      if (u === null) try {
                          d.stateNode.nodeValue = c ? "" : d.memoizedProps
                      } catch (m) {
                          Ne(e, e.return, m)
                      }
                  } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) {
                      d.child.return = d, d = d.child;
                      continue
                  }
                  if (d === e) break e;
                  for (; d.sibling === null;) {
                      if (d.return === null || d.return === e) break e;
                      u === d && (u = null), d = d.return
                  }
                  u === d && (u = null), d.sibling.return = d.return, d = d.sibling
              }
          }
          break;
      case 19:
          Yt(t, e), vn(e), r & 4 && zy(e);
          break;
      case 21:
          break;
      default:
          Yt(t, e), vn(e)
  }
}

function vn(e) {
  var t = e.flags;
  if (t & 2) {
      try {
          e: {
              for (var n = e.return; n !== null;) {
                  if (zb(n)) {
                      var r = n;
                      break e
                  }
                  n = n.return
              }
              throw Error(O(160))
          }
          switch (r.tag) {
              case 5:
                  var s = r.stateNode;
                  r.flags & 32 && (ga(s, ""), r.flags &= -33);
                  var i = By(e);
                  sf(e, i, s);
                  break;
              case 3:
              case 4:
                  var o = r.stateNode.containerInfo,
                      a = By(e);
                  rf(e, a, o);
                  break;
              default:
                  throw Error(O(161))
          }
      }
      catch (l) {
          Ne(e, e.return, l)
      }
      e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}

function fP(e, t, n) {
  F = e, Kb(e)
}

function Kb(e, t, n) {
  for (var r = (e.mode & 1) !== 0; F !== null;) {
      var s = F,
          i = s.child;
      if (s.tag === 22 && r) {
          var o = s.memoizedState !== null || Ol;
          if (!o) {
              var a = s.alternate,
                  l = a !== null && a.memoizedState !== null || tt;
              a = Ol;
              var c = tt;
              if (Ol = o, (tt = l) && !c)
                  for (F = s; F !== null;) o = F, l = o.child, o.tag === 22 && o.memoizedState !== null ? Ky(s) : l !== null ? (l.return = o, F = l) : Ky(s);
              for (; i !== null;) F = i, Kb(i), i = i.sibling;
              F = s, Ol = a, tt = c
          }
          Wy(e)
      } else s.subtreeFlags & 8772 && i !== null ? (i.return = s, F = i) : Wy(e)
  }
}

function Wy(e) {
  for (; F !== null;) {
      var t = F;
      if (t.flags & 8772) {
          var n = t.alternate;
          try {
              if (t.flags & 8772) switch (t.tag) {
                  case 0:
                  case 11:
                  case 15:
                      tt || bu(5, t);
                      break;
                  case 1:
                      var r = t.stateNode;
                      if (t.flags & 4 && !tt)
                          if (n === null) r.componentDidMount();
                          else {
                              var s = t.elementType === t.type ? n.memoizedProps : nn(t.type, n.memoizedProps);
                              r.componentDidUpdate(s, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                          } var i = t.updateQueue;
                      i !== null && Ry(t, i, r);
                      break;
                  case 3:
                      var o = t.updateQueue;
                      if (o !== null) {
                          if (n = null, t.child !== null) switch (t.child.tag) {
                              case 5:
                                  n = t.child.stateNode;
                                  break;
                              case 1:
                                  n = t.child.stateNode
                          }
                          Ry(t, o, n)
                      }
                      break;
                  case 5:
                      var a = t.stateNode;
                      if (n === null && t.flags & 4) {
                          n = a;
                          var l = t.memoizedProps;
                          switch (t.type) {
                              case "button":
                              case "input":
                              case "select":
                              case "textarea":
                                  l.autoFocus && n.focus();
                                  break;
                              case "img":
                                  l.src && (n.src = l.src)
                          }
                      }
                      break;
                  case 6:
                      break;
                  case 4:
                      break;
                  case 12:
                      break;
                  case 13:
                      if (t.memoizedState === null) {
                          var c = t.alternate;
                          if (c !== null) {
                              var u = c.memoizedState;
                              if (u !== null) {
                                  var d = u.dehydrated;
                                  d !== null && xa(d)
                              }
                          }
                      }
                      break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                      break;
                  default:
                      throw Error(O(163))
              }
              tt || t.flags & 512 && nf(t)
          } catch (h) {
              Ne(t, t.return, h)
          }
      }
      if (t === e) {
          F = null;
          break
      }
      if (n = t.sibling, n !== null) {
          n.return = t.return, F = n;
          break
      }
      F = t.return
  }
}

function Hy(e) {
  for (; F !== null;) {
      var t = F;
      if (t === e) {
          F = null;
          break
      }
      var n = t.sibling;
      if (n !== null) {
          n.return = t.return, F = n;
          break
      }
      F = t.return
  }
}

function Ky(e) {
  for (; F !== null;) {
      var t = F;
      try {
          switch (t.tag) {
              case 0:
              case 11:
              case 15:
                  var n = t.return;
                  try {
                      bu(4, t)
                  } catch (l) {
                      Ne(t, n, l)
                  }
                  break;
              case 1:
                  var r = t.stateNode;
                  if (typeof r.componentDidMount == "function") {
                      var s = t.return;
                      try {
                          r.componentDidMount()
                      } catch (l) {
                          Ne(t, s, l)
                      }
                  }
                  var i = t.return;
                  try {
                      nf(t)
                  } catch (l) {
                      Ne(t, i, l)
                  }
                  break;
              case 5:
                  var o = t.return;
                  try {
                      nf(t)
                  } catch (l) {
                      Ne(t, o, l)
                  }
          }
      } catch (l) {
          Ne(t, t.return, l)
      }
      if (t === e) {
          F = null;
          break
      }
      var a = t.sibling;
      if (a !== null) {
          a.return = t.return, F = a;
          break
      }
      F = t.return
  }
}
var pP = Math.ceil,
  Uc = er.ReactCurrentDispatcher,
  im = er.ReactCurrentOwner,
  Bt = er.ReactCurrentBatchConfig,
  le = 0,
  We = null,
  Me = null,
  Qe = 0,
  Et = 0,
  Ai = ns(0),
  Be = 0,
  Na = null,
  Ws = 0,
  Su = 0,
  om = 0,
  oa = null,
  gt = null,
  am = 0,
  mo = 1 / 0,
  Ln = null,
  Vc = !1,
  of = null,
  zr = null,
  Il = !1,
  Mr = null,
  Bc = 0,
  aa = 0,
  af = null,
  lc = -1,
  cc = 0;

function ct() {
  return le & 6 ? je() : lc !== -1 ? lc : lc = je()
}

function Wr(e) {
  return e.mode & 1 ? le & 2 && Qe !== 0 ? Qe & -Qe : JR.transition !== null ? (cc === 0 && (cc = Ax()), cc) : (e = he, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Lx(e.type)), e) : 1
}

function dn(e, t, n, r) {
  if (50 < aa) throw aa = 0, af = null, Error(O(185));
  el(e, n, r), (!(le & 2) || e !== We) && (e === We && (!(le & 2) && (Su |= n), Be === 4 && Sr(e, Qe)), St(e, r), n === 1 && le === 0 && !(t.mode & 1) && (mo = je() + 500, vu && rs()))
}

function St(e, t) {
  var n = e.callbackNode;
  Jk(e, t);
  var r = Cc(e, e === We ? Qe : 0);
  if (r === 0) n !== null && ty(n), e.callbackNode = null, e.callbackPriority = 0;
  else if (t = r & -r, e.callbackPriority !== t) {
      if (n != null && ty(n), t === 1) e.tag === 0 ? YR(qy.bind(null, e)) : nb(qy.bind(null, e)), KR(function() {
          !(le & 6) && rs()
      }), n = null;
      else {
          switch (Nx(r)) {
              case 1:
                  n = Op;
                  break;
              case 4:
                  n = Rx;
                  break;
              case 16:
                  n = Ec;
                  break;
              case 536870912:
                  n = Px;
                  break;
              default:
                  n = Ec
          }
          n = e1(n, qb.bind(null, e))
      }
      e.callbackPriority = t, e.callbackNode = n
  }
}

function qb(e, t) {
  if (lc = -1, cc = 0, le & 6) throw Error(O(327));
  var n = e.callbackNode;
  if (Bi() && e.callbackNode !== n) return null;
  var r = Cc(e, e === We ? Qe : 0);
  if (r === 0) return null;
  if (r & 30 || r & e.expiredLanes || t) t = zc(e, r);
  else {
      t = r;
      var s = le;
      le |= 2;
      var i = Qb();
      (We !== e || Qe !== t) && (Ln = null, mo = je() + 500, Ls(e, t));
      do try {
          yP();
          break
      } catch (a) {
          Gb(e, a)
      }
      while (!0);
      Kp(), Uc.current = i, le = s, Me !== null ? t = 0 : (We = null, Qe = 0, t = Be)
  }
  if (t !== 0) {
      if (t === 2 && (s = Oh(e), s !== 0 && (r = s, t = lf(e, s))), t === 1) throw n = Na, Ls(e, 0), Sr(e, r), St(e, je()), n;
      if (t === 6) Sr(e, r);
      else {
          if (s = e.current.alternate, !(r & 30) && !mP(s) && (t = zc(e, r), t === 2 && (i = Oh(e), i !== 0 && (r = i, t = lf(e, i))), t === 1)) throw n = Na, Ls(e, 0), Sr(e, r), St(e, je()), n;
          switch (e.finishedWork = s, e.finishedLanes = r, t) {
              case 0:
              case 1:
                  throw Error(O(345));
              case 2:
                  fs(e, gt, Ln);
                  break;
              case 3:
                  if (Sr(e, r), (r & 130023424) === r && (t = am + 500 - je(), 10 < t)) {
                      if (Cc(e, 0) !== 0) break;
                      if (s = e.suspendedLanes, (s & r) !== r) {
                          ct(), e.pingedLanes |= e.suspendedLanes & s;
                          break
                      }
                      e.timeoutHandle = Vh(fs.bind(null, e, gt, Ln), t);
                      break
                  }
                  fs(e, gt, Ln);
                  break;
              case 4:
                  if (Sr(e, r), (r & 4194240) === r) break;
                  for (t = e.eventTimes, s = -1; 0 < r;) {
                      var o = 31 - un(r);
                      i = 1 << o, o = t[o], o > s && (s = o), r &= ~i
                  }
                  if (r = s, r = je() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * pP(r / 1960)) - r, 10 < r) {
                      e.timeoutHandle = Vh(fs.bind(null, e, gt, Ln), r);
                      break
                  }
                  fs(e, gt, Ln);
                  break;
              case 5:
                  fs(e, gt, Ln);
                  break;
              default:
                  throw Error(O(329))
          }
      }
  }
  return St(e, je()), e.callbackNode === n ? qb.bind(null, e) : null
}

function lf(e, t) {
  var n = oa;
  return e.current.memoizedState.isDehydrated && (Ls(e, t).flags |= 256), e = zc(e, t), e !== 2 && (t = gt, gt = n, t !== null && cf(t)), e
}

function cf(e) {
  gt === null ? gt = e : gt.push.apply(gt, e)
}

function mP(e) {
  for (var t = e;;) {
      if (t.flags & 16384) {
          var n = t.updateQueue;
          if (n !== null && (n = n.stores, n !== null))
              for (var r = 0; r < n.length; r++) {
                  var s = n[r],
                      i = s.getSnapshot;
                  s = s.value;
                  try {
                      if (!hn(i(), s)) return !1
                  } catch {
                      return !1
                  }
              }
      }
      if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
      else {
          if (t === e) break;
          for (; t.sibling === null;) {
              if (t.return === null || t.return === e) return !0;
              t = t.return
          }
          t.sibling.return = t.return, t = t.sibling
      }
  }
  return !0
}

function Sr(e, t) {
  for (t &= ~om, t &= ~Su, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
      var n = 31 - un(t),
          r = 1 << n;
      e[n] = -1, t &= ~r
  }
}

function qy(e) {
  if (le & 6) throw Error(O(327));
  Bi();
  var t = Cc(e, 0);
  if (!(t & 1)) return St(e, je()), null;
  var n = zc(e, t);
  if (e.tag !== 0 && n === 2) {
      var r = Oh(e);
      r !== 0 && (t = r, n = lf(e, r))
  }
  if (n === 1) throw n = Na, Ls(e, 0), Sr(e, t), St(e, je()), n;
  if (n === 6) throw Error(O(345));
  return e.finishedWork = e.current.alternate, e.finishedLanes = t, fs(e, gt, Ln), St(e, je()), null
}

function lm(e, t) {
  var n = le;
  le |= 1;
  try {
      return e(t)
  } finally {
      le = n, le === 0 && (mo = je() + 500, vu && rs())
  }
}

function Hs(e) {
  Mr !== null && Mr.tag === 0 && !(le & 6) && Bi();
  var t = le;
  le |= 1;
  var n = Bt.transition,
      r = he;
  try {
      if (Bt.transition = null, he = 1, e) return e()
  } finally {
      he = r, Bt.transition = n, le = t, !(le & 6) && rs()
  }
}

function cm() {
  Et = Ai.current, ve(Ai)
}

function Ls(e, t) {
  e.finishedWork = null, e.finishedLanes = 0;
  var n = e.timeoutHandle;
  if (n !== -1 && (e.timeoutHandle = -1, HR(n)), Me !== null)
      for (n = Me.return; n !== null;) {
          var r = n;
          switch (zp(r), r.tag) {
              case 1:
                  r = r.type.childContextTypes, r != null && Ac();
                  break;
              case 3:
                  fo(), ve(xt), ve(rt), Xp();
                  break;
              case 5:
                  Jp(r);
                  break;
              case 4:
                  fo();
                  break;
              case 13:
                  ve(Ee);
                  break;
              case 19:
                  ve(Ee);
                  break;
              case 10:
                  qp(r.type._context);
                  break;
              case 22:
              case 23:
                  cm()
          }
          n = n.return
      }
  if (We = e, Me = e = Hr(e.current, null), Qe = Et = t, Be = 0, Na = null, om = Su = Ws = 0, gt = oa = null, _s !== null) {
      for (t = 0; t < _s.length; t++)
          if (n = _s[t], r = n.interleaved, r !== null) {
              n.interleaved = null;
              var s = r.next,
                  i = n.pending;
              if (i !== null) {
                  var o = i.next;
                  i.next = s, r.next = o
              }
              n.pending = r
          } _s = null
  }
  return e
}

function Gb(e, t) {
  do {
      var n = Me;
      try {
          if (Kp(), ic.current = Fc, $c) {
              for (var r = Te.memoizedState; r !== null;) {
                  var s = r.queue;
                  s !== null && (s.pending = null), r = r.next
              }
              $c = !1
          }
          if (zs = 0, ze = Ue = Te = null, sa = !1, Ra = 0, im.current = null, n === null || n.return === null) {
              Be = 1, Na = t, Me = null;
              break
          }
          e: {
              var i = e,
                  o = n.return,
                  a = n,
                  l = t;
              if (t = Qe, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                  var c = l,
                      u = a,
                      d = u.tag;
                  if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                      var h = u.alternate;
                      h ? (u.updateQueue = h.updateQueue, u.memoizedState = h.memoizedState, u.lanes = h.lanes) : (u.updateQueue = null, u.memoizedState = null)
                  }
                  var f = Iy(o);
                  if (f !== null) {
                      f.flags &= -257, Dy(f, o, a, i, t), f.mode & 1 && Oy(i, c, t), t = f, l = c;
                      var x = t.updateQueue;
                      if (x === null) {
                          var m = new Set;
                          m.add(l), t.updateQueue = m
                      } else x.add(l);
                      break e
                  } else {
                      if (!(t & 1)) {
                          Oy(i, c, t), um();
                          break e
                      }
                      l = Error(O(426))
                  }
              } else if (be && a.mode & 1) {
                  var b = Iy(o);
                  if (b !== null) {
                      !(b.flags & 65536) && (b.flags |= 256), Dy(b, o, a, i, t), Wp(po(l, a));
                      break e
                  }
              }
              i = l = po(l, a),
              Be !== 4 && (Be = 2),
              oa === null ? oa = [i] : oa.push(i),
              i = o;do {
                  switch (i.tag) {
                      case 3:
                          i.flags |= 65536, t &= -t, i.lanes |= t;
                          var v = Nb(i, l, t);
                          ky(i, v);
                          break e;
                      case 1:
                          a = l;
                          var y = i.type,
                              w = i.stateNode;
                          if (!(i.flags & 128) && (typeof y.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (zr === null || !zr.has(w)))) {
                              i.flags |= 65536, t &= -t, i.lanes |= t;
                              var S = jb(i, a, t);
                              ky(i, S);
                              break e
                          }
                  }
                  i = i.return
              } while (i !== null)
          }
          Jb(n)
      } catch (_) {
          t = _, Me === n && n !== null && (Me = n = n.return);
          continue
      }
      break
  } while (!0)
}

function Qb() {
  var e = Uc.current;
  return Uc.current = Fc, e === null ? Fc : e
}

function um() {
  (Be === 0 || Be === 3 || Be === 2) && (Be = 4), We === null || !(Ws & 268435455) && !(Su & 268435455) || Sr(We, Qe)
}

function zc(e, t) {
  var n = le;
  le |= 2;
  var r = Qb();
  (We !== e || Qe !== t) && (Ln = null, Ls(e, t));
  do try {
      gP();
      break
  } catch (s) {
      Gb(e, s)
  }
  while (!0);
  if (Kp(), le = n, Uc.current = r, Me !== null) throw Error(O(261));
  return We = null, Qe = 0, Be
}

function gP() {
  for (; Me !== null;) Yb(Me)
}

function yP() {
  for (; Me !== null && !Bk();) Yb(Me)
}

function Yb(e) {
  var t = Zb(e.alternate, e, Et);
  e.memoizedProps = e.pendingProps, t === null ? Jb(e) : Me = t, im.current = null
}

function Jb(e) {
  var t = e;
  do {
      var n = t.alternate;
      if (e = t.return, t.flags & 32768) {
          if (n = uP(n, t), n !== null) {
              n.flags &= 32767, Me = n;
              return
          }
          if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
          else {
              Be = 6, Me = null;
              return
          }
      } else if (n = cP(n, t, Et), n !== null) {
          Me = n;
          return
      }
      if (t = t.sibling, t !== null) {
          Me = t;
          return
      }
      Me = t = e
  } while (t !== null);
  Be === 0 && (Be = 5)
}

function fs(e, t, n) {
  var r = he,
      s = Bt.transition;
  try {
      Bt.transition = null, he = 1, vP(e, t, n, r)
  } finally {
      Bt.transition = s, he = r
  }
  return null
}

function vP(e, t, n, r) {
  do Bi(); while (Mr !== null);
  if (le & 6) throw Error(O(327));
  n = e.finishedWork;
  var s = e.finishedLanes;
  if (n === null) return null;
  if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(O(177));
  e.callbackNode = null, e.callbackPriority = 0;
  var i = n.lanes | n.childLanes;
  if (Xk(e, i), e === We && (Me = We = null, Qe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Il || (Il = !0, e1(Ec, function() {
          return Bi(), null
      })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) {
      i = Bt.transition, Bt.transition = null;
      var o = he;
      he = 1;
      var a = le;
      le |= 4, im.current = null, hP(e, n), Hb(n, e), $R(Fh), Tc = !!$h, Fh = $h = null, e.current = n, fP(n), zk(), le = a, he = o, Bt.transition = i
  } else e.current = n;
  if (Il && (Il = !1, Mr = e, Bc = s), i = e.pendingLanes, i === 0 && (zr = null), Kk(n.stateNode), St(e, je()), t !== null)
      for (r = e.onRecoverableError, n = 0; n < t.length; n++) s = t[n], r(s.value, {
          componentStack: s.stack,
          digest: s.digest
      });
  if (Vc) throw Vc = !1, e = of, of = null, e;
  return Bc & 1 && e.tag !== 0 && Bi(), i = e.pendingLanes, i & 1 ? e === af ? aa++ : (aa = 0, af = e) : aa = 0, rs(), null
}

function Bi() {
  if (Mr !== null) {
      var e = Nx(Bc),
          t = Bt.transition,
          n = he;
      try {
          if (Bt.transition = null, he = 16 > e ? 16 : e, Mr === null) var r = !1;
          else {
              if (e = Mr, Mr = null, Bc = 0, le & 6) throw Error(O(331));
              var s = le;
              for (le |= 4, F = e.current; F !== null;) {
                  var i = F,
                      o = i.child;
                  if (F.flags & 16) {
                      var a = i.deletions;
                      if (a !== null) {
                          for (var l = 0; l < a.length; l++) {
                              var c = a[l];
                              for (F = c; F !== null;) {
                                  var u = F;
                                  switch (u.tag) {
                                      case 0:
                                      case 11:
                                      case 15:
                                          ia(8, u, i)
                                  }
                                  var d = u.child;
                                  if (d !== null) d.return = u, F = d;
                                  else
                                      for (; F !== null;) {
                                          u = F;
                                          var h = u.sibling,
                                              f = u.return;
                                          if (Bb(u), u === c) {
                                              F = null;
                                              break
                                          }
                                          if (h !== null) {
                                              h.return = f, F = h;
                                              break
                                          }
                                          F = f
                                      }
                              }
                          }
                          var x = i.alternate;
                          if (x !== null) {
                              var m = x.child;
                              if (m !== null) {
                                  x.child = null;
                                  do {
                                      var b = m.sibling;
                                      m.sibling = null, m = b
                                  } while (m !== null)
                              }
                          }
                          F = i
                      }
                  }
                  if (i.subtreeFlags & 2064 && o !== null) o.return = i, F = o;
                  else e: for (; F !== null;) {
                      if (i = F, i.flags & 2048) switch (i.tag) {
                          case 0:
                          case 11:
                          case 15:
                              ia(9, i, i.return)
                      }
                      var v = i.sibling;
                      if (v !== null) {
                          v.return = i.return, F = v;
                          break e
                      }
                      F = i.return
                  }
              }
              var y = e.current;
              for (F = y; F !== null;) {
                  o = F;
                  var w = o.child;
                  if (o.subtreeFlags & 2064 && w !== null) w.return = o, F = w;
                  else e: for (o = y; F !== null;) {
                      if (a = F, a.flags & 2048) try {
                          switch (a.tag) {
                              case 0:
                              case 11:
                              case 15:
                                  bu(9, a)
                          }
                      } catch (_) {
                          Ne(a, a.return, _)
                      }
                      if (a === o) {
                          F = null;
                          break e
                      }
                      var S = a.sibling;
                      if (S !== null) {
                          S.return = a.return, F = S;
                          break e
                      }
                      F = a.return
                  }
              }
              if (le = s, rs(), Tn && typeof Tn.onPostCommitFiberRoot == "function") try {
                  Tn.onPostCommitFiberRoot(fu, e)
              } catch {}
              r = !0
          }
          return r
      } finally {
          he = n, Bt.transition = t
      }
  }
  return !1
}

function Gy(e, t, n) {
  t = po(n, t), t = Nb(e, t, 1), e = Br(e, t, 1), t = ct(), e !== null && (el(e, 1, t), St(e, t))
}

function Ne(e, t, n) {
  if (e.tag === 3) Gy(e, e, n);
  else
      for (; t !== null;) {
          if (t.tag === 3) {
              Gy(t, e, n);
              break
          } else if (t.tag === 1) {
              var r = t.stateNode;
              if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (zr === null || !zr.has(r))) {
                  e = po(n, e), e = jb(t, e, 1), t = Br(t, e, 1), e = ct(), t !== null && (el(t, 1, e), St(t, e));
                  break
              }
          }
          t = t.return
      }
}

function wP(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t), t = ct(), e.pingedLanes |= e.suspendedLanes & n, We === e && (Qe & n) === n && (Be === 4 || Be === 3 && (Qe & 130023424) === Qe && 500 > je() - am ? Ls(e, 0) : om |= n), St(e, t)
}

function Xb(e, t) {
  t === 0 && (e.mode & 1 ? (t = El, El <<= 1, !(El & 130023424) && (El = 4194304)) : t = 1);
  var n = ct();
  e = Gn(e, t), e !== null && (el(e, t, n), St(e, n))
}

function xP(e) {
  var t = e.memoizedState,
      n = 0;
  t !== null && (n = t.retryLane), Xb(e, n)
}

function bP(e, t) {
  var n = 0;
  switch (e.tag) {
      case 13:
          var r = e.stateNode,
              s = e.memoizedState;
          s !== null && (n = s.retryLane);
          break;
      case 19:
          r = e.stateNode;
          break;
      default:
          throw Error(O(314))
  }
  r !== null && r.delete(t), Xb(e, n)
}
var Zb;
Zb = function(e, t, n) {
  if (e !== null)
      if (e.memoizedProps !== t.pendingProps || xt.current) vt = !0;
      else {
          if (!(e.lanes & n) && !(t.flags & 128)) return vt = !1, lP(e, t, n);
          vt = !!(e.flags & 131072)
      }
  else vt = !1, be && t.flags & 1048576 && rb(t, Oc, t.index);
  switch (t.lanes = 0, t.tag) {
      case 2:
          var r = t.type;
          ac(e, t), e = t.pendingProps;
          var s = co(t, rt.current);
          Vi(t, n), s = em(null, t, r, e, s, n);
          var i = tm();
          return t.flags |= 1, typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, bt(r) ? (i = !0, Nc(t)) : i = !1, t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, Qp(t), s.updater = xu, t.stateNode = s, s._reactInternals = t, Gh(t, r, e, n), t = Jh(null, t, r, !0, i, n)) : (t.tag = 0, be && i && Bp(t), ot(null, t, s, n), t = t.child), t;
      case 16:
          r = t.elementType;
          e: {
              switch (ac(e, t), e = t.pendingProps, s = r._init, r = s(r._payload), t.type = r, s = t.tag = _P(r), e = nn(r, e), s) {
                  case 0:
                      t = Yh(null, t, r, e, n);
                      break e;
                  case 1:
                      t = $y(null, t, r, e, n);
                      break e;
                  case 11:
                      t = My(null, t, r, e, n);
                      break e;
                  case 14:
                      t = Ly(null, t, r, nn(r.type, e), n);
                      break e
              }
              throw Error(O(306, r, ""))
          }
          return t;
      case 0:
          return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : nn(r, s), Yh(e, t, r, s, n);
      case 1:
          return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : nn(r, s), $y(e, t, r, s, n);
      case 3:
          e: {
              if (Mb(t), e === null) throw Error(O(387));r = t.pendingProps,
              i = t.memoizedState,
              s = i.element,
              cb(e, t),
              Mc(t, r, null, n);
              var o = t.memoizedState;
              if (r = o.element, i.isDehydrated)
                  if (i = {
                          element: r,
                          isDehydrated: !1,
                          cache: o.cache,
                          pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                          transitions: o.transitions
                      }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) {
                      s = po(Error(O(423)), t), t = Fy(e, t, r, n, s);
                      break e
                  } else if (r !== s) {
                  s = po(Error(O(424)), t), t = Fy(e, t, r, n, s);
                  break e
              } else
                  for (Rt = Vr(t.stateNode.containerInfo.firstChild), Pt = t, be = !0, cn = null, n = ab(t, null, r, n), t.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
              else {
                  if (uo(), r === s) {
                      t = Qn(e, t, n);
                      break e
                  }
                  ot(e, t, r, n)
              }
              t = t.child
          }
          return t;
      case 5:
          return ub(t), e === null && Hh(t), r = t.type, s = t.pendingProps, i = e !== null ? e.memoizedProps : null, o = s.children, Uh(r, s) ? o = null : i !== null && Uh(r, i) && (t.flags |= 32), Db(e, t), ot(e, t, o, n), t.child;
      case 6:
          return e === null && Hh(t), null;
      case 13:
          return Lb(e, t, n);
      case 4:
          return Yp(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = ho(t, null, r, n) : ot(e, t, r, n), t.child;
      case 11:
          return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : nn(r, s), My(e, t, r, s, n);
      case 7:
          return ot(e, t, t.pendingProps, n), t.child;
      case 8:
          return ot(e, t, t.pendingProps.children, n), t.child;
      case 12:
          return ot(e, t, t.pendingProps.children, n), t.child;
      case 10:
          e: {
              if (r = t.type._context, s = t.pendingProps, i = t.memoizedProps, o = s.value, me(Ic, r._currentValue), r._currentValue = o, i !== null)
                  if (hn(i.value, o)) {
                      if (i.children === s.children && !xt.current) {
                          t = Qn(e, t, n);
                          break e
                      }
                  } else
                      for (i = t.child, i !== null && (i.return = t); i !== null;) {
                          var a = i.dependencies;
                          if (a !== null) {
                              o = i.child;
                              for (var l = a.firstContext; l !== null;) {
                                  if (l.context === r) {
                                      if (i.tag === 1) {
                                          l = Wn(-1, n & -n), l.tag = 2;
                                          var c = i.updateQueue;
                                          if (c !== null) {
                                              c = c.shared;
                                              var u = c.pending;
                                              u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l
                                          }
                                      }
                                      i.lanes |= n, l = i.alternate, l !== null && (l.lanes |= n), Kh(i.return, n, t), a.lanes |= n;
                                      break
                                  }
                                  l = l.next
                              }
                          } else if (i.tag === 10) o = i.type === t.type ? null : i.child;
                          else if (i.tag === 18) {
                              if (o = i.return, o === null) throw Error(O(341));
                              o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Kh(o, n, t), o = i.sibling
                          } else o = i.child;
                          if (o !== null) o.return = i;
                          else
                              for (o = i; o !== null;) {
                                  if (o === t) {
                                      o = null;
                                      break
                                  }
                                  if (i = o.sibling, i !== null) {
                                      i.return = o.return, o = i;
                                      break
                                  }
                                  o = o.return
                              }
                          i = o
                      }
              ot(e, t, s.children, n),
              t = t.child
          }
          return t;
      case 9:
          return s = t.type, r = t.pendingProps.children, Vi(t, n), s = Wt(s), r = r(s), t.flags |= 1, ot(e, t, r, n), t.child;
      case 14:
          return r = t.type, s = nn(r, t.pendingProps), s = nn(r.type, s), Ly(e, t, r, s, n);
      case 15:
          return Ob(e, t, t.type, t.pendingProps, n);
      case 17:
          return r = t.type, s = t.pendingProps, s = t.elementType === r ? s : nn(r, s), ac(e, t), t.tag = 1, bt(r) ? (e = !0, Nc(t)) : e = !1, Vi(t, n), Ab(t, r, s), Gh(t, r, s, n), Jh(null, t, r, !0, e, n);
      case 19:
          return $b(e, t, n);
      case 22:
          return Ib(e, t, n)
  }
  throw Error(O(156, t.tag))
};

function e1(e, t) {
  return kx(e, t)
}

function SP(e, t, n, r) {
  this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Ut(e, t, n, r) {
  return new SP(e, t, n, r)
}

function dm(e) {
  return e = e.prototype, !(!e || !e.isReactComponent)
}

function _P(e) {
  if (typeof e == "function") return dm(e) ? 1 : 0;
  if (e != null) {
      if (e = e.$$typeof, e === Ap) return 11;
      if (e === Np) return 14
  }
  return 2
}

function Hr(e, t) {
  var n = e.alternate;
  return n === null ? (n = Ut(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
      lanes: t.lanes,
      firstContext: t.firstContext
  }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
}

function uc(e, t, n, r, s, i) {
  var o = 2;
  if (r = e, typeof e == "function") dm(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else e: switch (e) {
      case xi:
          return $s(n.children, s, i, t);
      case Pp:
          o = 8, s |= 8;
          break;
      case vh:
          return e = Ut(12, n, t, s | 2), e.elementType = vh, e.lanes = i, e;
      case wh:
          return e = Ut(13, n, t, s), e.elementType = wh, e.lanes = i, e;
      case xh:
          return e = Ut(19, n, t, s), e.elementType = xh, e.lanes = i, e;
      case ux:
          return _u(n, s, i, t);
      default:
          if (typeof e == "object" && e !== null) switch (e.$$typeof) {
              case lx:
                  o = 10;
                  break e;
              case cx:
                  o = 9;
                  break e;
              case Ap:
                  o = 11;
                  break e;
              case Np:
                  o = 14;
                  break e;
              case vr:
                  o = 16, r = null;
                  break e
          }
          throw Error(O(130, e == null ? e : typeof e, ""))
  }
  return t = Ut(o, n, t, s), t.elementType = e, t.type = r, t.lanes = i, t
}

function $s(e, t, n, r) {
  return e = Ut(7, e, r, t), e.lanes = n, e
}

function _u(e, t, n, r) {
  return e = Ut(22, e, r, t), e.elementType = ux, e.lanes = n, e.stateNode = {
      isHidden: !1
  }, e
}

function Pd(e, t, n) {
  return e = Ut(6, e, null, t), e.lanes = n, e
}

function Ad(e, t, n) {
  return t = Ut(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
  }, t
}

function EP(e, t, n, r, s) {
  this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ud(0), this.expirationTimes = ud(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ud(0), this.identifierPrefix = r, this.onRecoverableError = s, this.mutableSourceEagerHydrationData = null
}

function hm(e, t, n, r, s, i, o, a, l) {
  return e = new EP(e, t, n, a, l), t === 1 ? (t = 1, i === !0 && (t |= 8)) : t = 0, i = Ut(3, null, null, t), e.current = i, i.stateNode = e, i.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
  }, Qp(i), e
}

function CP(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
      $$typeof: wi,
      key: r == null ? null : "" + r,
      children: e,
      containerInfo: t,
      implementation: n
  }
}

function t1(e) {
  if (!e) return Yr;
  e = e._reactInternals;
  e: {
      if (Js(e) !== e || e.tag !== 1) throw Error(O(170));
      var t = e;do {
          switch (t.tag) {
              case 3:
                  t = t.stateNode.context;
                  break e;
              case 1:
                  if (bt(t.type)) {
                      t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                      break e
                  }
          }
          t = t.return
      } while (t !== null);
      throw Error(O(171))
  }
  if (e.tag === 1) {
      var n = e.type;
      if (bt(n)) return tb(e, n, t)
  }
  return t
}

function n1(e, t, n, r, s, i, o, a, l) {
  return e = hm(n, r, !0, e, s, i, o, a, l), e.context = t1(null), n = e.current, r = ct(), s = Wr(n), i = Wn(r, s), i.callback = t ?? null, Br(n, i, s), e.current.lanes = s, el(e, s, r), St(e, r), e
}

function Eu(e, t, n, r) {
  var s = t.current,
      i = ct(),
      o = Wr(s);
  return n = t1(n), t.context === null ? t.context = n : t.pendingContext = n, t = Wn(i, o), t.payload = {
      element: e
  }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Br(s, t, o), e !== null && (dn(e, s, o, i), sc(e, s, o)), o
}

function Wc(e) {
  if (e = e.current, !e.child) return null;
  switch (e.child.tag) {
      case 5:
          return e.child.stateNode;
      default:
          return e.child.stateNode
  }
}

function Qy(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
      var n = e.retryLane;
      e.retryLane = n !== 0 && n < t ? n : t
  }
}

function fm(e, t) {
  Qy(e, t), (e = e.alternate) && Qy(e, t)
}

function TP() {
  return null
}
var r1 = typeof reportError == "function" ? reportError : function(e) {
  console.error(e)
};

function pm(e) {
  this._internalRoot = e
}
Cu.prototype.render = pm.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null) throw Error(O(409));
  Eu(e, t, null, null)
};
Cu.prototype.unmount = pm.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
      this._internalRoot = null;
      var t = e.containerInfo;
      Hs(function() {
          Eu(null, e, null, null)
      }), t[qn] = null
  }
};

function Cu(e) {
  this._internalRoot = e
}
Cu.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
      var t = Ix();
      e = {
          blockedOn: null,
          target: e,
          priority: t
      };
      for (var n = 0; n < br.length && t !== 0 && t < br[n].priority; n++);
      br.splice(n, 0, e), n === 0 && Mx(e)
  }
};

function mm(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}

function Tu(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}

function Yy() {}

function kP(e, t, n, r, s) {
  if (s) {
      if (typeof r == "function") {
          var i = r;
          r = function() {
              var c = Wc(o);
              i.call(c)
          }
      }
      var o = n1(t, r, e, 0, null, !1, !1, "", Yy);
      return e._reactRootContainer = o, e[qn] = o.current, _a(e.nodeType === 8 ? e.parentNode : e), Hs(), o
  }
  for (; s = e.lastChild;) e.removeChild(s);
  if (typeof r == "function") {
      var a = r;
      r = function() {
          var c = Wc(l);
          a.call(c)
      }
  }
  var l = hm(e, 0, !1, null, null, !1, !1, "", Yy);
  return e._reactRootContainer = l, e[qn] = l.current, _a(e.nodeType === 8 ? e.parentNode : e), Hs(function() {
      Eu(t, l, n, r)
  }), l
}

function ku(e, t, n, r, s) {
  var i = n._reactRootContainer;
  if (i) {
      var o = i;
      if (typeof s == "function") {
          var a = s;
          s = function() {
              var l = Wc(o);
              a.call(l)
          }
      }
      Eu(t, o, e, s)
  } else o = kP(n, t, e, s, r);
  return Wc(o)
}
jx = function(e) {
  switch (e.tag) {
      case 3:
          var t = e.stateNode;
          if (t.current.memoizedState.isDehydrated) {
              var n = qo(t.pendingLanes);
              n !== 0 && (Ip(t, n | 1), St(t, je()), !(le & 6) && (mo = je() + 500, rs()))
          }
          break;
      case 13:
          Hs(function() {
              var r = Gn(e, 1);
              if (r !== null) {
                  var s = ct();
                  dn(r, e, 1, s)
              }
          }), fm(e, 1)
  }
};
Dp = function(e) {
  if (e.tag === 13) {
      var t = Gn(e, 134217728);
      if (t !== null) {
          var n = ct();
          dn(t, e, 134217728, n)
      }
      fm(e, 134217728)
  }
};
Ox = function(e) {
  if (e.tag === 13) {
      var t = Wr(e),
          n = Gn(e, t);
      if (n !== null) {
          var r = ct();
          dn(n, e, t, r)
      }
      fm(e, t)
  }
};
Ix = function() {
  return he
};
Dx = function(e, t) {
  var n = he;
  try {
      return he = e, t()
  } finally {
      he = n
  }
};
Ah = function(e, t, n) {
  switch (t) {
      case "input":
          if (_h(e, n), t = n.name, n.type === "radio" && t != null) {
              for (n = e; n.parentNode;) n = n.parentNode;
              for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                  var r = n[t];
                  if (r !== e && r.form === e.form) {
                      var s = yu(r);
                      if (!s) throw Error(O(90));
                      hx(r), _h(r, s)
                  }
              }
          }
          break;
      case "textarea":
          px(e, n);
          break;
      case "select":
          t = n.value, t != null && Li(e, !!n.multiple, t, !1)
  }
};
bx = lm;
Sx = Hs;
var RP = {
      usingClientEntryPoint: !1,
      Events: [nl, Ei, yu, wx, xx, lm]
  },
  Vo = {
      findFiberByHostInstance: Ss,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom"
  },
  PP = {
      bundleType: Vo.bundleType,
      version: Vo.version,
      rendererPackageName: Vo.rendererPackageName,
      rendererConfig: Vo.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: er.ReactCurrentDispatcher,
      findHostInstanceByFiber: function(e) {
          return e = Cx(e), e === null ? null : e.stateNode
      },
      findFiberByHostInstance: Vo.findFiberByHostInstance || TP,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Dl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Dl.isDisabled && Dl.supportsFiber) try {
      fu = Dl.inject(PP), Tn = Dl
  } catch {}
}
jt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = RP;
jt.createPortal = function(e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!mm(t)) throw Error(O(200));
  return CP(e, t, null, n)
};
jt.createRoot = function(e, t) {
  if (!mm(e)) throw Error(O(299));
  var n = !1,
      r = "",
      s = r1;
  return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = hm(e, 1, !1, null, null, n, !1, r, s), e[qn] = t.current, _a(e.nodeType === 8 ? e.parentNode : e), new pm(t)
};
jt.findDOMNode = function(e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0) throw typeof e.render == "function" ? Error(O(188)) : (e = Object.keys(e).join(","), Error(O(268, e)));
  return e = Cx(t), e = e === null ? null : e.stateNode, e
};
jt.flushSync = function(e) {
  return Hs(e)
};
jt.hydrate = function(e, t, n) {
  if (!Tu(t)) throw Error(O(200));
  return ku(null, e, t, !0, n)
};
jt.hydrateRoot = function(e, t, n) {
  if (!mm(e)) throw Error(O(405));
  var r = n != null && n.hydratedSources || null,
      s = !1,
      i = "",
      o = r1;
  if (n != null && (n.unstable_strictMode === !0 && (s = !0), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = n1(t, null, e, 1, n ?? null, s, !1, i, o), e[qn] = t.current, _a(e), r)
      for (e = 0; e < r.length; e++) n = r[e], s = n._getVersion, s = s(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, s] : t.mutableSourceEagerHydrationData.push(n, s);
  return new Cu(t)
};
jt.render = function(e, t, n) {
  if (!Tu(t)) throw Error(O(200));
  return ku(null, e, t, !1, n)
};
jt.unmountComponentAtNode = function(e) {
  if (!Tu(e)) throw Error(O(40));
  return e._reactRootContainer ? (Hs(function() {
      ku(null, null, e, !1, function() {
          e._reactRootContainer = null, e[qn] = null
      })
  }), !0) : !1
};
jt.unstable_batchedUpdates = lm;
jt.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
  if (!Tu(n)) throw Error(O(200));
  if (e == null || e._reactInternals === void 0) throw Error(O(38));
  return ku(e, t, n, !1, r)
};
jt.version = "18.3.1-next-f1338f8080-20240426";

function s1() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s1)
  } catch (e) {
      console.error(e)
  }
}
s1(), sx.exports = jt;
var sl = sx.exports;
const i1 = Kw(sl);
var o1, Jy = sl;
o1 = Jy.createRoot, Jy.hydrateRoot;
const AP = 1,
  NP = 1e6;
let Nd = 0;

function jP() {
  return Nd = (Nd + 1) % Number.MAX_SAFE_INTEGER, Nd.toString()
}
const jd = new Map,
  Xy = e => {
      if (jd.has(e)) return;
      const t = setTimeout(() => {
          jd.delete(e), la({
              type: "REMOVE_TOAST",
              toastId: e
          })
      }, NP);
      jd.set(e, t)
  },
  OP = (e, t) => {
      switch (t.type) {
          case "ADD_TOAST":
              return {
                  ...e, toasts: [t.toast, ...e.toasts].slice(0, AP)
              };
          case "UPDATE_TOAST":
              return {
                  ...e, toasts: e.toasts.map(n => n.id === t.toast.id ? {
                      ...n,
                      ...t.toast
                  } : n)
              };
          case "DISMISS_TOAST": {
              const {
                  toastId: n
              } = t;
              return n ? Xy(n) : e.toasts.forEach(r => {
                  Xy(r.id)
              }), {
                  ...e,
                  toasts: e.toasts.map(r => r.id === n || n === void 0 ? {
                      ...r,
                      open: !1
                  } : r)
              }
          }
          case "REMOVE_TOAST":
              return t.toastId === void 0 ? {
                  ...e,
                  toasts: []
              } : {
                  ...e,
                  toasts: e.toasts.filter(n => n.id !== t.toastId)
              }
      }
  },
  dc = [];
let hc = {
  toasts: []
};

function la(e) {
  hc = OP(hc, e), dc.forEach(t => {
      t(hc)
  })
}

function IP({
  ...e
}) {
  const t = jP(),
      n = s => la({
          type: "UPDATE_TOAST",
          toast: {
              ...s,
              id: t
          }
      }),
      r = () => la({
          type: "DISMISS_TOAST",
          toastId: t
      });
  return la({
      type: "ADD_TOAST",
      toast: {
          ...e,
          id: t,
          open: !0,
          onOpenChange: s => {
              s || r()
          }
      }
  }), {
      id: t,
      dismiss: r,
      update: n
  }
}

function Ru() {
  const [e, t] = g.useState(hc);
  return g.useEffect(() => (dc.push(t), () => {
      const n = dc.indexOf(t);
      n > -1 && dc.splice(n, 1)
  }), [e]), {
      ...e,
      toast: IP,
      dismiss: n => la({
          type: "DISMISS_TOAST",
          toastId: n
      })
  }
}

function ne(e, t, {
  checkForDefaultPrevented: n = !0
} = {}) {
  return function(s) {
      if (e == null || e(s), n === !1 || !s.defaultPrevented) return t == null ? void 0 : t(s)
  }
}

function Zy(e, t) {
  if (typeof e == "function") return e(t);
  e != null && (e.current = t)
}

function a1(...e) {
  return t => {
      let n = !1;
      const r = e.map(s => {
          const i = Zy(s, t);
          return !n && typeof i == "function" && (n = !0), i
      });
      if (n) return () => {
          for (let s = 0; s < r.length; s++) {
              const i = r[s];
              typeof i == "function" ? i() : Zy(e[s], null)
          }
      }
  }
}

function we(...e) {
  return g.useCallback(a1(...e), e)
}

function DP(e, t) {
  const n = g.createContext(t),
      r = i => {
          const {
              children: o,
              ...a
          } = i, l = g.useMemo(() => a, Object.values(a));
          return p.jsx(n.Provider, {
              value: l,
              children: o
          })
      };
  r.displayName = e + "Provider";

  function s(i) {
      const o = g.useContext(n);
      if (o) return o;
      if (t !== void 0) return t;
      throw new Error(`\`${i}\` must be used within \`${e}\``)
  }
  return [r, s]
}

function Kt(e, t = []) {
  let n = [];

  function r(i, o) {
      const a = g.createContext(o),
          l = n.length;
      n = [...n, o];
      const c = d => {
          var v;
          const {
              scope: h,
              children: f,
              ...x
          } = d, m = ((v = h == null ? void 0 : h[e]) == null ? void 0 : v[l]) || a, b = g.useMemo(() => x, Object.values(x));
          return p.jsx(m.Provider, {
              value: b,
              children: f
          })
      };
      c.displayName = i + "Provider";

      function u(d, h) {
          var m;
          const f = ((m = h == null ? void 0 : h[e]) == null ? void 0 : m[l]) || a,
              x = g.useContext(f);
          if (x) return x;
          if (o !== void 0) return o;
          throw new Error(`\`${d}\` must be used within \`${i}\``)
      }
      return [c, u]
  }
  const s = () => {
      const i = n.map(o => g.createContext(o));
      return function(a) {
          const l = (a == null ? void 0 : a[e]) || i;
          return g.useMemo(() => ({
              [`__scope${e}`]: {
                  ...a,
                  [e]: l
              }
          }), [a, l])
      }
  };
  return s.scopeName = e, [r, MP(s, ...t)]
}

function MP(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
      const r = e.map(s => ({
          useScope: s(),
          scopeName: s.scopeName
      }));
      return function(i) {
          const o = r.reduce((a, {
              useScope: l,
              scopeName: c
          }) => {
              const d = l(i)[`__scope${c}`];
              return {
                  ...a,
                  ...d
              }
          }, {});
          return g.useMemo(() => ({
              [`__scope${t.scopeName}`]: o
          }), [o])
      }
  };
  return n.scopeName = t.scopeName, n
}

function ja(e) {
  const t = $P(e),
      n = g.forwardRef((r, s) => {
          const {
              children: i,
              ...o
          } = r, a = g.Children.toArray(i), l = a.find(FP);
          if (l) {
              const c = l.props.children,
                  u = a.map(d => d === l ? g.Children.count(c) > 1 ? g.Children.only(null) : g.isValidElement(c) ? c.props.children : null : d);
              return p.jsx(t, {
                  ...o,
                  ref: s,
                  children: g.isValidElement(c) ? g.cloneElement(c, void 0, u) : null
              })
          }
          return p.jsx(t, {
              ...o,
              ref: s,
              children: i
          })
      });
  return n.displayName = `${e}.Slot`, n
}
var LP = ja("Slot");

function $P(e) {
  const t = g.forwardRef((n, r) => {
      const {
          children: s,
          ...i
      } = n;
      if (g.isValidElement(s)) {
          const o = VP(s),
              a = UP(i, s.props);
          return s.type !== g.Fragment && (a.ref = r ? a1(r, o) : o), g.cloneElement(s, a)
      }
      return g.Children.count(s) > 1 ? g.Children.only(null) : null
  });
  return t.displayName = `${e}.SlotClone`, t
}
var l1 = Symbol("radix.slottable");

function c1(e) {
  const t = ({
      children: n
  }) => p.jsx(p.Fragment, {
      children: n
  });
  return t.displayName = `${e}.Slottable`, t.__radixId = l1, t
}

function FP(e) {
  return g.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === l1
}

function UP(e, t) {
  const n = {
      ...t
  };
  for (const r in t) {
      const s = e[r],
          i = t[r];
      /^on[A-Z]/.test(r) ? s && i ? n[r] = (...a) => {
          const l = i(...a);
          return s(...a), l
      } : s && (n[r] = s) : r === "style" ? n[r] = {
          ...s,
          ...i
      } : r === "className" && (n[r] = [s, i].filter(Boolean).join(" "))
  }
  return {
      ...e,
      ...n
  }
}

function VP(e) {
  var r, s;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get,
      n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref)
}

function gm(e) {
  const t = e + "CollectionProvider",
      [n, r] = Kt(t),
      [s, i] = n(t, {
          collectionRef: {
              current: null
          },
          itemMap: new Map
      }),
      o = m => {
          const {
              scope: b,
              children: v
          } = m, y = j.useRef(null), w = j.useRef(new Map).current;
          return p.jsx(s, {
              scope: b,
              itemMap: w,
              collectionRef: y,
              children: v
          })
      };
  o.displayName = t;
  const a = e + "CollectionSlot",
      l = ja(a),
      c = j.forwardRef((m, b) => {
          const {
              scope: v,
              children: y
          } = m, w = i(a, v), S = we(b, w.collectionRef);
          return p.jsx(l, {
              ref: S,
              children: y
          })
      });
  c.displayName = a;
  const u = e + "CollectionItemSlot",
      d = "data-radix-collection-item",
      h = ja(u),
      f = j.forwardRef((m, b) => {
          const {
              scope: v,
              children: y,
              ...w
          } = m, S = j.useRef(null), _ = we(b, S), E = i(u, v);
          return j.useEffect(() => (E.itemMap.set(S, {
              ref: S,
              ...w
          }), () => void E.itemMap.delete(S))), p.jsx(h, {
              [d]: "",
              ref: _,
              children: y
          })
      });
  f.displayName = u;

  function x(m) {
      const b = i(e + "CollectionConsumer", m);
      return j.useCallback(() => {
          const y = b.collectionRef.current;
          if (!y) return [];
          const w = Array.from(y.querySelectorAll(`[${d}]`));
          return Array.from(b.itemMap.values()).sort((E, T) => w.indexOf(E.ref.current) - w.indexOf(T.ref.current))
      }, [b.collectionRef, b.itemMap])
  }
  return [{
      Provider: o,
      Slot: c,
      ItemSlot: f
  }, x, r]
}
var BP = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"],
  ae = BP.reduce((e, t) => {
      const n = ja(`Primitive.${t}`),
          r = g.forwardRef((s, i) => {
              const {
                  asChild: o,
                  ...a
              } = s, l = o ? n : t;
              return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), p.jsx(l, {
                  ...a,
                  ref: i
              })
          });
      return r.displayName = `Primitive.${t}`, {
          ...e,
          [t]: r
      }
  }, {});

function u1(e, t) {
  e && sl.flushSync(() => e.dispatchEvent(t))
}

function fn(e) {
  const t = g.useRef(e);
  return g.useEffect(() => {
      t.current = e
  }), g.useMemo(() => (...n) => {
      var r;
      return (r = t.current) == null ? void 0 : r.call(t, ...n)
  }, [])
}

function zP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fn(e);
  g.useEffect(() => {
      const r = s => {
          s.key === "Escape" && n(s)
      };
      return t.addEventListener("keydown", r, {
          capture: !0
      }), () => t.removeEventListener("keydown", r, {
          capture: !0
      })
  }, [n, t])
}
var WP = "DismissableLayer",
  uf = "dismissableLayer.update",
  HP = "dismissableLayer.pointerDownOutside",
  KP = "dismissableLayer.focusOutside",
  ev, d1 = g.createContext({
      layers: new Set,
      layersWithOutsidePointerEventsDisabled: new Set,
      branches: new Set
  }),
  Pu = g.forwardRef((e, t) => {
      const {
          disableOutsidePointerEvents: n = !1,
          onEscapeKeyDown: r,
          onPointerDownOutside: s,
          onFocusOutside: i,
          onInteractOutside: o,
          onDismiss: a,
          ...l
      } = e, c = g.useContext(d1), [u, d] = g.useState(null), h = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, f] = g.useState({}), x = we(t, T => d(T)), m = Array.from(c.layers), [b] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), v = m.indexOf(b), y = u ? m.indexOf(u) : -1, w = c.layersWithOutsidePointerEventsDisabled.size > 0, S = y >= v, _ = GP(T => {
          const k = T.target,
              P = [...c.branches].some(A => A.contains(k));
          !S || P || (s == null || s(T), o == null || o(T), T.defaultPrevented || a == null || a())
      }, h), E = QP(T => {
          const k = T.target;
          [...c.branches].some(A => A.contains(k)) || (i == null || i(T), o == null || o(T), T.defaultPrevented || a == null || a())
      }, h);
      return zP(T => {
          y === c.layers.size - 1 && (r == null || r(T), !T.defaultPrevented && a && (T.preventDefault(), a()))
      }, h), g.useEffect(() => {
          if (u) return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (ev = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), tv(), () => {
              n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = ev)
          }
      }, [u, h, n, c]), g.useEffect(() => () => {
          u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), tv())
      }, [u, c]), g.useEffect(() => {
          const T = () => f({});
          return document.addEventListener(uf, T), () => document.removeEventListener(uf, T)
      }, []), p.jsx(ae.div, {
          ...l,
          ref: x,
          style: {
              pointerEvents: w ? S ? "auto" : "none" : void 0,
              ...e.style
          },
          onFocusCapture: ne(e.onFocusCapture, E.onFocusCapture),
          onBlurCapture: ne(e.onBlurCapture, E.onBlurCapture),
          onPointerDownCapture: ne(e.onPointerDownCapture, _.onPointerDownCapture)
      })
  });
Pu.displayName = WP;
var qP = "DismissableLayerBranch",
  h1 = g.forwardRef((e, t) => {
      const n = g.useContext(d1),
          r = g.useRef(null),
          s = we(t, r);
      return g.useEffect(() => {
          const i = r.current;
          if (i) return n.branches.add(i), () => {
              n.branches.delete(i)
          }
      }, [n.branches]), p.jsx(ae.div, {
          ...e,
          ref: s
      })
  });
h1.displayName = qP;

function GP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fn(e),
      r = g.useRef(!1),
      s = g.useRef(() => {});
  return g.useEffect(() => {
      const i = a => {
              if (a.target && !r.current) {
                  let l = function() {
                      f1(HP, n, c, {
                          discrete: !0
                      })
                  };
                  const c = {
                      originalEvent: a
                  };
                  a.pointerType === "touch" ? (t.removeEventListener("click", s.current), s.current = l, t.addEventListener("click", s.current, {
                      once: !0
                  })) : l()
              } else t.removeEventListener("click", s.current);
              r.current = !1
          },
          o = window.setTimeout(() => {
              t.addEventListener("pointerdown", i)
          }, 0);
      return () => {
          window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", s.current)
      }
  }, [t, n]), {
      onPointerDownCapture: () => r.current = !0
  }
}

function QP(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fn(e),
      r = g.useRef(!1);
  return g.useEffect(() => {
      const s = i => {
          i.target && !r.current && f1(KP, n, {
              originalEvent: i
          }, {
              discrete: !1
          })
      };
      return t.addEventListener("focusin", s), () => t.removeEventListener("focusin", s)
  }, [t, n]), {
      onFocusCapture: () => r.current = !0,
      onBlurCapture: () => r.current = !1
  }
}

function tv() {
  const e = new CustomEvent(uf);
  document.dispatchEvent(e)
}

function f1(e, t, n, {
  discrete: r
}) {
  const s = n.originalEvent.target,
      i = new CustomEvent(e, {
          bubbles: !1,
          cancelable: !0,
          detail: n
      });
  t && s.addEventListener(e, t, {
      once: !0
  }), r ? u1(s, i) : s.dispatchEvent(i)
}
var YP = Pu,
  JP = h1,
  jn = globalThis != null && globalThis.document ? g.useLayoutEffect : () => {},
  XP = "Portal",
  ym = g.forwardRef((e, t) => {
      var a;
      const {
          container: n,
          ...r
      } = e, [s, i] = g.useState(!1);
      jn(() => i(!0), []);
      const o = n || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
      return o ? i1.createPortal(p.jsx(ae.div, {
          ...r,
          ref: t
      }), o) : null
  });
ym.displayName = XP;

function ZP(e, t) {
  return g.useReducer((n, r) => t[n][r] ?? n, e)
}
var tr = e => {
  const {
      present: t,
      children: n
  } = e, r = eA(t), s = typeof n == "function" ? n({
      present: r.isPresent
  }) : g.Children.only(n), i = we(r.ref, tA(s));
  return typeof n == "function" || r.isPresent ? g.cloneElement(s, {
      ref: i
  }) : null
};
tr.displayName = "Presence";

function eA(e) {
  const [t, n] = g.useState(), r = g.useRef(null), s = g.useRef(e), i = g.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = ZP(o, {
      mounted: {
          UNMOUNT: "unmounted",
          ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
          MOUNT: "mounted",
          ANIMATION_END: "unmounted"
      },
      unmounted: {
          MOUNT: "mounted"
      }
  });
  return g.useEffect(() => {
      const c = Ml(r.current);
      i.current = a === "mounted" ? c : "none"
  }, [a]), jn(() => {
      const c = r.current,
          u = s.current;
      if (u !== e) {
          const h = i.current,
              f = Ml(c);
          e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && h !== f ? "ANIMATION_OUT" : "UNMOUNT"), s.current = e
      }
  }, [e, l]), jn(() => {
      if (t) {
          let c;
          const u = t.ownerDocument.defaultView ?? window,
              d = f => {
                  const m = Ml(r.current).includes(f.animationName);
                  if (f.target === t && m && (l("ANIMATION_END"), !s.current)) {
                      const b = t.style.animationFillMode;
                      t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
                          t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b)
                      })
                  }
              },
              h = f => {
                  f.target === t && (i.current = Ml(r.current))
              };
          return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", d), t.addEventListener("animationend", d), () => {
              u.clearTimeout(c), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", d), t.removeEventListener("animationend", d)
          }
      } else l("ANIMATION_END")
  }, [t, l]), {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: g.useCallback(c => {
          r.current = c ? getComputedStyle(c) : null, n(c)
      }, [])
  }
}

function Ml(e) {
  return (e == null ? void 0 : e.animationName) || "none"
}

function tA(e) {
  var r, s;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get,
      n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (s = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : s.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref)
}
var nA = Cp[" useInsertionEffect ".trim().toString()] || jn;

function ss({
  prop: e,
  defaultProp: t,
  onChange: n = () => {},
  caller: r
}) {
  const [s, i, o] = rA({
      defaultProp: t,
      onChange: n
  }), a = e !== void 0, l = a ? e : s;
  {
      const u = g.useRef(e !== void 0);
      g.useEffect(() => {
          const d = u.current;
          d !== a && console.warn(`${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), u.current = a
      }, [a, r])
  }
  const c = g.useCallback(u => {
      var d;
      if (a) {
          const h = sA(u) ? u(e) : u;
          h !== e && ((d = o.current) == null || d.call(o, h))
      } else i(u)
  }, [a, e, i, o]);
  return [l, c]
}

function rA({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = g.useState(e), s = g.useRef(n), i = g.useRef(t);
  return nA(() => {
      i.current = t
  }, [t]), g.useEffect(() => {
      var o;
      s.current !== n && ((o = i.current) == null || o.call(i, n), s.current = n)
  }, [n, s]), [n, r, i]
}

function sA(e) {
  return typeof e == "function"
}
var iA = Object.freeze({
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal"
  }),
  oA = "VisuallyHidden",
  Au = g.forwardRef((e, t) => p.jsx(ae.span, {
      ...e,
      ref: t,
      style: {
          ...iA,
          ...e.style
      }
  }));
Au.displayName = oA;
var aA = Au,
  vm = "ToastProvider",
  [wm, lA, cA] = gm("Toast"),
  [p1, qV] = Kt("Toast", [cA]),
  [uA, Nu] = p1(vm),
  m1 = e => {
      const {
          __scopeToast: t,
          label: n = "Notification",
          duration: r = 5e3,
          swipeDirection: s = "right",
          swipeThreshold: i = 50,
          children: o
      } = e, [a, l] = g.useState(null), [c, u] = g.useState(0), d = g.useRef(!1), h = g.useRef(!1);
      return n.trim() || console.error(`Invalid prop \`label\` supplied to \`${vm}\`. Expected non-empty \`string\`.`), p.jsx(wm.Provider, {
          scope: t,
          children: p.jsx(uA, {
              scope: t,
              label: n,
              duration: r,
              swipeDirection: s,
              swipeThreshold: i,
              toastCount: c,
              viewport: a,
              onViewportChange: l,
              onToastAdd: g.useCallback(() => u(f => f + 1), []),
              onToastRemove: g.useCallback(() => u(f => f - 1), []),
              isFocusedToastEscapeKeyDownRef: d,
              isClosePausedRef: h,
              children: o
          })
      })
  };
m1.displayName = vm;
var g1 = "ToastViewport",
  dA = ["F8"],
  df = "toast.viewportPause",
  hf = "toast.viewportResume",
  y1 = g.forwardRef((e, t) => {
      const {
          __scopeToast: n,
          hotkey: r = dA,
          label: s = "Notifications ({hotkey})",
          ...i
      } = e, o = Nu(g1, n), a = lA(n), l = g.useRef(null), c = g.useRef(null), u = g.useRef(null), d = g.useRef(null), h = we(t, d, o.onViewportChange), f = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), x = o.toastCount > 0;
      g.useEffect(() => {
          const b = v => {
              var w;
              r.length !== 0 && r.every(S => v[S] || v.code === S) && ((w = d.current) == null || w.focus())
          };
          return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b)
      }, [r]), g.useEffect(() => {
          const b = l.current,
              v = d.current;
          if (x && b && v) {
              const y = () => {
                      if (!o.isClosePausedRef.current) {
                          const E = new CustomEvent(df);
                          v.dispatchEvent(E), o.isClosePausedRef.current = !0
                      }
                  },
                  w = () => {
                      if (o.isClosePausedRef.current) {
                          const E = new CustomEvent(hf);
                          v.dispatchEvent(E), o.isClosePausedRef.current = !1
                      }
                  },
                  S = E => {
                      !b.contains(E.relatedTarget) && w()
                  },
                  _ = () => {
                      b.contains(document.activeElement) || w()
                  };
              return b.addEventListener("focusin", y), b.addEventListener("focusout", S), b.addEventListener("pointermove", y), b.addEventListener("pointerleave", _), window.addEventListener("blur", y), window.addEventListener("focus", w), () => {
                  b.removeEventListener("focusin", y), b.removeEventListener("focusout", S), b.removeEventListener("pointermove", y), b.removeEventListener("pointerleave", _), window.removeEventListener("blur", y), window.removeEventListener("focus", w)
              }
          }
      }, [x, o.isClosePausedRef]);
      const m = g.useCallback(({
          tabbingDirection: b
      }) => {
          const y = a().map(w => {
              const S = w.ref.current,
                  _ = [S, ...EA(S)];
              return b === "forwards" ? _ : _.reverse()
          });
          return (b === "forwards" ? y.reverse() : y).flat()
      }, [a]);
      return g.useEffect(() => {
          const b = d.current;
          if (b) {
              const v = y => {
                  var _, E, T;
                  const w = y.altKey || y.ctrlKey || y.metaKey;
                  if (y.key === "Tab" && !w) {
                      const k = document.activeElement,
                          P = y.shiftKey;
                      if (y.target === b && P) {
                          (_ = c.current) == null || _.focus();
                          return
                      }
                      const I = m({
                              tabbingDirection: P ? "backwards" : "forwards"
                          }),
                          G = I.findIndex(D => D === k);
                      Od(I.slice(G + 1)) ? y.preventDefault() : P ? (E = c.current) == null || E.focus() : (T = u.current) == null || T.focus()
                  }
              };
              return b.addEventListener("keydown", v), () => b.removeEventListener("keydown", v)
          }
      }, [a, m]), p.jsxs(JP, {
          ref: l,
          role: "region",
          "aria-label": s.replace("{hotkey}", f),
          tabIndex: -1,
          style: {
              pointerEvents: x ? void 0 : "none"
          },
          children: [x && p.jsx(ff, {
              ref: c,
              onFocusFromOutsideViewport: () => {
                  const b = m({
                      tabbingDirection: "forwards"
                  });
                  Od(b)
              }
          }), p.jsx(wm.Slot, {
              scope: n,
              children: p.jsx(ae.ol, {
                  tabIndex: -1,
                  ...i,
                  ref: h
              })
          }), x && p.jsx(ff, {
              ref: u,
              onFocusFromOutsideViewport: () => {
                  const b = m({
                      tabbingDirection: "backwards"
                  });
                  Od(b)
              }
          })]
      })
  });
y1.displayName = g1;
var v1 = "ToastFocusProxy",
  ff = g.forwardRef((e, t) => {
      const {
          __scopeToast: n,
          onFocusFromOutsideViewport: r,
          ...s
      } = e, i = Nu(v1, n);
      return p.jsx(Au, {
          "aria-hidden": !0,
          tabIndex: 0,
          ...s,
          ref: t,
          style: {
              position: "fixed"
          },
          onFocus: o => {
              var c;
              const a = o.relatedTarget;
              !((c = i.viewport) != null && c.contains(a)) && r()
          }
      })
  });
ff.displayName = v1;
var il = "Toast",
  hA = "toast.swipeStart",
  fA = "toast.swipeMove",
  pA = "toast.swipeCancel",
  mA = "toast.swipeEnd",
  w1 = g.forwardRef((e, t) => {
      const {
          forceMount: n,
          open: r,
          defaultOpen: s,
          onOpenChange: i,
          ...o
      } = e, [a, l] = ss({
          prop: r,
          defaultProp: s ?? !0,
          onChange: i,
          caller: il
      });
      return p.jsx(tr, {
          present: n || a,
          children: p.jsx(vA, {
              open: a,
              ...o,
              ref: t,
              onClose: () => l(!1),
              onPause: fn(e.onPause),
              onResume: fn(e.onResume),
              onSwipeStart: ne(e.onSwipeStart, c => {
                  c.currentTarget.setAttribute("data-swipe", "start")
              }),
              onSwipeMove: ne(e.onSwipeMove, c => {
                  const {
                      x: u,
                      y: d
                  } = c.detail.delta;
                  c.currentTarget.setAttribute("data-swipe", "move"), c.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${u}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`)
              }),
              onSwipeCancel: ne(e.onSwipeCancel, c => {
                  c.currentTarget.setAttribute("data-swipe", "cancel"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
              }),
              onSwipeEnd: ne(e.onSwipeEnd, c => {
                  const {
                      x: u,
                      y: d
                  } = c.detail.delta;
                  c.currentTarget.setAttribute("data-swipe", "end"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${u}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), l(!1)
              })
          })
      })
  });
w1.displayName = il;
var [gA, yA] = p1(il, {
  onClose() {}
}), vA = g.forwardRef((e, t) => {
  const {
      __scopeToast: n,
      type: r = "foreground",
      duration: s,
      open: i,
      onClose: o,
      onEscapeKeyDown: a,
      onPause: l,
      onResume: c,
      onSwipeStart: u,
      onSwipeMove: d,
      onSwipeCancel: h,
      onSwipeEnd: f,
      ...x
  } = e, m = Nu(il, n), [b, v] = g.useState(null), y = we(t, D => v(D)), w = g.useRef(null), S = g.useRef(null), _ = s || m.duration, E = g.useRef(0), T = g.useRef(_), k = g.useRef(0), {
      onToastAdd: P,
      onToastRemove: A
  } = m, $ = fn(() => {
      var X;
      (b == null ? void 0 : b.contains(document.activeElement)) && ((X = m.viewport) == null || X.focus()), o()
  }), I = g.useCallback(D => {
      !D || D === 1 / 0 || (window.clearTimeout(k.current), E.current = new Date().getTime(), k.current = window.setTimeout($, D))
  }, [$]);
  g.useEffect(() => {
      const D = m.viewport;
      if (D) {
          const X = () => {
                  I(T.current), c == null || c()
              },
              B = () => {
                  const U = new Date().getTime() - E.current;
                  T.current = T.current - U, window.clearTimeout(k.current), l == null || l()
              };
          return D.addEventListener(df, B), D.addEventListener(hf, X), () => {
              D.removeEventListener(df, B), D.removeEventListener(hf, X)
          }
      }
  }, [m.viewport, _, l, c, I]), g.useEffect(() => {
      i && !m.isClosePausedRef.current && I(_)
  }, [i, _, m.isClosePausedRef, I]), g.useEffect(() => (P(), () => A()), [P, A]);
  const G = g.useMemo(() => b ? T1(b) : null, [b]);
  return m.viewport ? p.jsxs(p.Fragment, {
      children: [G && p.jsx(wA, {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: G
      }), p.jsx(gA, {
          scope: n,
          onClose: $,
          children: sl.createPortal(p.jsx(wm.ItemSlot, {
              scope: n,
              children: p.jsx(YP, {
                  asChild: !0,
                  onEscapeKeyDown: ne(a, () => {
                      m.isFocusedToastEscapeKeyDownRef.current || $(), m.isFocusedToastEscapeKeyDownRef.current = !1
                  }),
                  children: p.jsx(ae.li, {
                      role: "status",
                      "aria-live": "off",
                      "aria-atomic": !0,
                      tabIndex: 0,
                      "data-state": i ? "open" : "closed",
                      "data-swipe-direction": m.swipeDirection,
                      ...x,
                      ref: y,
                      style: {
                          userSelect: "none",
                          touchAction: "none",
                          ...e.style
                      },
                      onKeyDown: ne(e.onKeyDown, D => {
                          D.key === "Escape" && (a == null || a(D.nativeEvent), D.nativeEvent.defaultPrevented || (m.isFocusedToastEscapeKeyDownRef.current = !0, $()))
                      }),
                      onPointerDown: ne(e.onPointerDown, D => {
                          D.button === 0 && (w.current = {
                              x: D.clientX,
                              y: D.clientY
                          })
                      }),
                      onPointerMove: ne(e.onPointerMove, D => {
                          if (!w.current) return;
                          const X = D.clientX - w.current.x,
                              B = D.clientY - w.current.y,
                              U = !!S.current,
                              R = ["left", "right"].includes(m.swipeDirection),
                              N = ["left", "up"].includes(m.swipeDirection) ? Math.min : Math.max,
                              M = R ? N(0, X) : 0,
                              Q = R ? 0 : N(0, B),
                              W = D.pointerType === "touch" ? 10 : 2,
                              re = {
                                  x: M,
                                  y: Q
                              },
                              ie = {
                                  originalEvent: D,
                                  delta: re
                              };
                          U ? (S.current = re, Ll(fA, d, ie, {
                              discrete: !1
                          })) : nv(re, m.swipeDirection, W) ? (S.current = re, Ll(hA, u, ie, {
                              discrete: !1
                          }), D.target.setPointerCapture(D.pointerId)) : (Math.abs(X) > W || Math.abs(B) > W) && (w.current = null)
                      }),
                      onPointerUp: ne(e.onPointerUp, D => {
                          const X = S.current,
                              B = D.target;
                          if (B.hasPointerCapture(D.pointerId) && B.releasePointerCapture(D.pointerId), S.current = null, w.current = null, X) {
                              const U = D.currentTarget,
                                  R = {
                                      originalEvent: D,
                                      delta: X
                                  };
                              nv(X, m.swipeDirection, m.swipeThreshold) ? Ll(mA, f, R, {
                                  discrete: !0
                              }) : Ll(pA, h, R, {
                                  discrete: !0
                              }), U.addEventListener("click", N => N.preventDefault(), {
                                  once: !0
                              })
                          }
                      })
                  })
              })
          }), m.viewport)
      })]
  }) : null
}), wA = e => {
  const {
      __scopeToast: t,
      children: n,
      ...r
  } = e, s = Nu(il, t), [i, o] = g.useState(!1), [a, l] = g.useState(!1);
  return SA(() => o(!0)), g.useEffect(() => {
      const c = window.setTimeout(() => l(!0), 1e3);
      return () => window.clearTimeout(c)
  }, []), a ? null : p.jsx(ym, {
      asChild: !0,
      children: p.jsx(Au, {
          ...r,
          children: i && p.jsxs(p.Fragment, {
              children: [s.label, " ", n]
          })
      })
  })
}, xA = "ToastTitle", x1 = g.forwardRef((e, t) => {
  const {
      __scopeToast: n,
      ...r
  } = e;
  return p.jsx(ae.div, {
      ...r,
      ref: t
  })
});
x1.displayName = xA;
var bA = "ToastDescription",
  b1 = g.forwardRef((e, t) => {
      const {
          __scopeToast: n,
          ...r
      } = e;
      return p.jsx(ae.div, {
          ...r,
          ref: t
      })
  });
b1.displayName = bA;
var S1 = "ToastAction",
  _1 = g.forwardRef((e, t) => {
      const {
          altText: n,
          ...r
      } = e;
      return n.trim() ? p.jsx(C1, {
          altText: n,
          asChild: !0,
          children: p.jsx(xm, {
              ...r,
              ref: t
          })
      }) : (console.error(`Invalid prop \`altText\` supplied to \`${S1}\`. Expected non-empty \`string\`.`), null)
  });
_1.displayName = S1;
var E1 = "ToastClose",
  xm = g.forwardRef((e, t) => {
      const {
          __scopeToast: n,
          ...r
      } = e, s = yA(E1, n);
      return p.jsx(C1, {
          asChild: !0,
          children: p.jsx(ae.button, {
              type: "button",
              ...r,
              ref: t,
              onClick: ne(e.onClick, s.onClose)
          })
      })
  });
xm.displayName = E1;
var C1 = g.forwardRef((e, t) => {
  const {
      __scopeToast: n,
      altText: r,
      ...s
  } = e;
  return p.jsx(ae.div, {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...s,
      ref: t
  })
});

function T1(e) {
  const t = [];
  return Array.from(e.childNodes).forEach(r => {
      if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), _A(r)) {
          const s = r.ariaHidden || r.hidden || r.style.display === "none",
              i = r.dataset.radixToastAnnounceExclude === "";
          if (!s)
              if (i) {
                  const o = r.dataset.radixToastAnnounceAlt;
                  o && t.push(o)
              } else t.push(...T1(r))
      }
  }), t
}

function Ll(e, t, n, {
  discrete: r
}) {
  const s = n.originalEvent.currentTarget,
      i = new CustomEvent(e, {
          bubbles: !0,
          cancelable: !0,
          detail: n
      });
  t && s.addEventListener(e, t, {
      once: !0
  }), r ? u1(s, i) : s.dispatchEvent(i)
}
var nv = (e, t, n = 0) => {
  const r = Math.abs(e.x),
      s = Math.abs(e.y),
      i = r > s;
  return t === "left" || t === "right" ? i && r > n : !i && s > n
};

function SA(e = () => {}) {
  const t = fn(e);
  jn(() => {
      let n = 0,
          r = 0;
      return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
          window.cancelAnimationFrame(n), window.cancelAnimationFrame(r)
      }
  }, [t])
}

function _A(e) {
  return e.nodeType === e.ELEMENT_NODE
}

function EA(e) {
  const t = [],
      n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
          acceptNode: r => {
              const s = r.tagName === "INPUT" && r.type === "hidden";
              return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
          }
      });
  for (; n.nextNode();) t.push(n.currentNode);
  return t
}

function Od(e) {
  const t = document.activeElement;
  return e.some(n => n === t ? !0 : (n.focus(), document.activeElement !== t))
}
var CA = m1,
  k1 = y1,
  R1 = w1,
  P1 = x1,
  A1 = b1,
  N1 = _1,
  j1 = xm;

function O1(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
      if (Array.isArray(e)) {
          var s = e.length;
          for (t = 0; t < s; t++) e[t] && (n = O1(e[t])) && (r && (r += " "), r += n)
      } else
          for (n in e) e[n] && (r && (r += " "), r += n);
  return r
}

function I1() {
  for (var e, t, n = 0, r = "", s = arguments.length; n < s; n++)(e = arguments[n]) && (t = O1(e)) && (r && (r += " "), r += t);
  return r
}
const rv = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e,
  sv = I1,
  ju = (e, t) => n => {
      var r;
      if ((t == null ? void 0 : t.variants) == null) return sv(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
      const {
          variants: s,
          defaultVariants: i
      } = t, o = Object.keys(s).map(c => {
          const u = n == null ? void 0 : n[c],
              d = i == null ? void 0 : i[c];
          if (u === null) return null;
          const h = rv(u) || rv(d);
          return s[c][h]
      }), a = n && Object.entries(n).reduce((c, u) => {
          let [d, h] = u;
          return h === void 0 || (c[d] = h), c
      }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, u) => {
          let {
              class: d,
              className: h,
              ...f
          } = u;
          return Object.entries(f).every(x => {
              let [m, b] = x;
              return Array.isArray(b) ? b.includes({
                  ...i,
                  ...a
              } [m]) : {
                  ...i,
                  ...a
              } [m] === b
          }) ? [...c, d, h] : c
      }, []);
      return sv(e, o, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className)
  };
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const TA = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  D1 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var kA = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const RA = g.forwardRef(({
  color: e = "currentColor",
  size: t = 24,
  strokeWidth: n = 2,
  absoluteStrokeWidth: r,
  className: s = "",
  children: i,
  iconNode: o,
  ...a
}, l) => g.createElement("svg", {
  ref: l,
  ...kA,
  width: t,
  height: t,
  stroke: e,
  strokeWidth: r ? Number(n) * 24 / Number(t) : n,
  className: D1("lucide", s),
  ...a
}, [...o.map(([c, u]) => g.createElement(c, u)), ...Array.isArray(i) ? i : [i]]));
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const ce = (e, t) => {
  const n = g.forwardRef(({
      className: r,
      ...s
  }, i) => g.createElement(RA, {
      ref: i,
      iconNode: t,
      className: D1(`lucide-${TA(e)}`, r),
      ...s
  }));
  return n.displayName = `${e}`, n
};
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const PA = ce("Bed", [
  ["path", {
      d: "M2 4v16",
      key: "vw9hq8"
  }],
  ["path", {
      d: "M2 8h18a2 2 0 0 1 2 2v10",
      key: "1dgv2r"
  }],
  ["path", {
      d: "M2 17h20",
      key: "18nfp3"
  }],
  ["path", {
      d: "M6 8v9",
      key: "1yriud"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const AA = ce("CalendarPlus", [
  ["path", {
      d: "M8 2v4",
      key: "1cmpym"
  }],
  ["path", {
      d: "M16 2v4",
      key: "4m81vk"
  }],
  ["path", {
      d: "M21 13V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8",
      key: "3spt84"
  }],
  ["path", {
      d: "M3 10h18",
      key: "8toen8"
  }],
  ["path", {
      d: "M16 19h6",
      key: "xwg31i"
  }],
  ["path", {
      d: "M19 16v6",
      key: "tddt3s"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const NA = ce("Calendar", [
  ["path", {
      d: "M8 2v4",
      key: "1cmpym"
  }],
  ["path", {
      d: "M16 2v4",
      key: "4m81vk"
  }],
  ["rect", {
      width: "18",
      height: "18",
      x: "3",
      y: "4",
      rx: "2",
      key: "1hopcy"
  }],
  ["path", {
      d: "M3 10h18",
      key: "8toen8"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const jA = ce("Check", [
  ["path", {
      d: "M20 6 9 17l-5-5",
      key: "1gmf2c"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const bm = ce("ChevronDown", [
  ["path", {
      d: "m6 9 6 6 6-6",
      key: "qrunsl"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const OA = ce("CircleCheckBig", [
  ["path", {
      d: "M21.801 10A10 10 0 1 1 17 3.335",
      key: "yps3ct"
  }],
  ["path", {
      d: "m9 11 3 3L22 4",
      key: "1pflzl"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const IA = ce("CircleHelp", [
  ["circle", {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay"
  }],
  ["path", {
      d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3",
      key: "1u773s"
  }],
  ["path", {
      d: "M12 17h.01",
      key: "p32p05"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const DA = ce("CircleX", [
  ["circle", {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay"
  }],
  ["path", {
      d: "m15 9-6 6",
      key: "1uzhvr"
  }],
  ["path", {
      d: "m9 9 6 6",
      key: "z0biqf"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const MA = ce("Circle", [
  ["circle", {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const M1 = ce("Clock", [
  ["circle", {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay"
  }],
  ["polyline", {
      points: "12 6 12 12 16 14",
      key: "68esgv"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const LA = ce("Download", [
  ["path", {
      d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
      key: "ih7n3h"
  }],
  ["polyline", {
      points: "7 10 12 15 17 10",
      key: "2ggqvy"
  }],
  ["line", {
      x1: "12",
      x2: "12",
      y1: "15",
      y2: "3",
      key: "1vk2je"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const $A = ce("ExternalLink", [
  ["path", {
      d: "M15 3h6v6",
      key: "1q9fwt"
  }],
  ["path", {
      d: "M10 14 21 3",
      key: "gplh6r"
  }],
  ["path", {
      d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
      key: "a6xqqp"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const FA = ce("EyeOff", [
  ["path", {
      d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",
      key: "ct8e1f"
  }],
  ["path", {
      d: "M14.084 14.158a3 3 0 0 1-4.242-4.242",
      key: "151rxh"
  }],
  ["path", {
      d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",
      key: "13bj9a"
  }],
  ["path", {
      d: "m2 2 20 20",
      key: "1ooewy"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const UA = ce("Eye", [
  ["path", {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
  }],
  ["circle", {
      cx: "12",
      cy: "12",
      r: "3",
      key: "1v7zrd"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const L1 = ce("Flower2", [
  ["path", {
      d: "M12 5a3 3 0 1 1 3 3m-3-3a3 3 0 1 0-3 3m3-3v1M9 8a3 3 0 1 0 3 3M9 8h1m5 0a3 3 0 1 1-3 3m3-3h-1m-2 3v-1",
      key: "3pnvol"
  }],
  ["circle", {
      cx: "12",
      cy: "8",
      r: "2",
      key: "1822b1"
  }],
  ["path", {
      d: "M12 10v12",
      key: "6ubwww"
  }],
  ["path", {
      d: "M12 22c4.2 0 7-1.667 7-5-4.2 0-7 1.667-7 5Z",
      key: "9hd38g"
  }],
  ["path", {
      d: "M12 22c-4.2 0-7-1.667-7-5 4.2 0 7 1.667 7 5Z",
      key: "ufn41s"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const VA = ce("Heart", [
  ["path", {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const BA = ce("House", [
  ["path", {
      d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",
      key: "5wwlr5"
  }],
  ["path", {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const zA = ce("Lock", [
  ["rect", {
      width: "18",
      height: "11",
      x: "3",
      y: "11",
      rx: "2",
      ry: "2",
      key: "1w4ew1"
  }],
  ["path", {
      d: "M7 11V7a5 5 0 0 1 10 0v4",
      key: "fwvmzm"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const WA = ce("Mail", [
  ["rect", {
      width: "20",
      height: "16",
      x: "2",
      y: "4",
      rx: "2",
      key: "18n3k1"
  }],
  ["path", {
      d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7",
      key: "1ocrg3"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const Hc = ce("MapPin", [
  ["path", {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z"
  }],
  ["circle", {
      cx: "12",
      cy: "10",
      r: "3",
      key: "ilqhr7"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const HA = ce("Music", [
  ["path", {
      d: "M9 18V5l12-2v13",
      key: "1jmyc2"
  }],
  ["circle", {
      cx: "6",
      cy: "18",
      r: "3",
      key: "fqmcym"
  }],
  ["circle", {
      cx: "18",
      cy: "16",
      r: "3",
      key: "1hluhg"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const KA = ce("Send", [
  ["path", {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
  }],
  ["path", {
      d: "m21.854 2.147-10.94 10.939",
      key: "12cjpa"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const qA = ce("Sparkles", [
  ["path", {
      d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
      key: "4pj2yx"
  }],
  ["path", {
      d: "M20 3v4",
      key: "1olli1"
  }],
  ["path", {
      d: "M22 5h-4",
      key: "1gvqau"
  }],
  ["path", {
      d: "M4 17v2",
      key: "vumght"
  }],
  ["path", {
      d: "M5 18H3",
      key: "zchphs"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const GA = ce("Trash2", [
  ["path", {
      d: "M3 6h18",
      key: "d0wm0j"
  }],
  ["path", {
      d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
      key: "4alrt4"
  }],
  ["path", {
      d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
      key: "v07s0e"
  }],
  ["line", {
      x1: "10",
      x2: "10",
      y1: "11",
      y2: "17",
      key: "1uufr5"
  }],
  ["line", {
      x1: "14",
      x2: "14",
      y1: "11",
      y2: "17",
      key: "xtxkd"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const QA = ce("TriangleAlert", [
  ["path", {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
  }],
  ["path", {
      d: "M12 9v4",
      key: "juzpu7"
  }],
  ["path", {
      d: "M12 17h.01",
      key: "p32p05"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const iv = ce("Users", [
  ["path", {
      d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
      key: "1yyitq"
  }],
  ["circle", {
      cx: "9",
      cy: "7",
      r: "4",
      key: "nufk8"
  }],
  ["path", {
      d: "M22 21v-2a4 4 0 0 0-3-3.87",
      key: "kshegd"
  }],
  ["path", {
      d: "M16 3.13a4 4 0 0 1 0 7.75",
      key: "1da9ce"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const YA = ce("UtensilsCrossed", [
  ["path", {
      d: "m16 2-2.3 2.3a3 3 0 0 0 0 4.2l1.8 1.8a3 3 0 0 0 4.2 0L22 8",
      key: "n7qcjb"
  }],
  ["path", {
      d: "M15 15 3.3 3.3a4.2 4.2 0 0 0 0 6l7.3 7.3c.7.7 2 .7 2.8 0L15 15Zm0 0 7 7",
      key: "d0u48b"
  }],
  ["path", {
      d: "m2.1 21.8 6.4-6.3",
      key: "yn04lh"
  }],
  ["path", {
      d: "m19 5-7 7",
      key: "194lzd"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const JA = ce("Volume2", [
  ["path", {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
  }],
  ["path", {
      d: "M16 9a5 5 0 0 1 0 6",
      key: "1q6k2b"
  }],
  ["path", {
      d: "M19.364 18.364a9 9 0 0 0 0-12.728",
      key: "ijwkga"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const XA = ce("VolumeX", [
  ["path", {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw"
  }],
  ["line", {
      x1: "22",
      x2: "16",
      y1: "9",
      y2: "15",
      key: "1ewh16"
  }],
  ["line", {
      x1: "16",
      x2: "22",
      y1: "9",
      y2: "15",
      key: "5ykzw1"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const ZA = ce("Wine", [
  ["path", {
      d: "M8 22h8",
      key: "rmew8v"
  }],
  ["path", {
      d: "M7 10h10",
      key: "1101jm"
  }],
  ["path", {
      d: "M12 15v7",
      key: "t2xh3l"
  }],
  ["path", {
      d: "M12 15a5 5 0 0 0 5-5c0-2-.5-4-2-8H9c-1.5 4-2 6-2 8a5 5 0 0 0 5 5Z",
      key: "10ffi3"
  }]
]);
/**
* @license lucide-react v0.462.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const eN = ce("X", [
      ["path", {
          d: "M18 6 6 18",
          key: "1bl5f8"
      }],
      ["path", {
          d: "m6 6 12 12",
          key: "d8bk6v"
      }]
  ]),
  Sm = "-",
  tN = e => {
      const t = rN(e),
          {
              conflictingClassGroups: n,
              conflictingClassGroupModifiers: r
          } = e;
      return {
          getClassGroupId: o => {
              const a = o.split(Sm);
              return a[0] === "" && a.length !== 1 && a.shift(), $1(a, t) || nN(o)
          },
          getConflictingClassGroupIds: (o, a) => {
              const l = n[o] || [];
              return a && r[o] ? [...l, ...r[o]] : l
          }
      }
  },
  $1 = (e, t) => {
      var o;
      if (e.length === 0) return t.classGroupId;
      const n = e[0],
          r = t.nextPart.get(n),
          s = r ? $1(e.slice(1), r) : void 0;
      if (s) return s;
      if (t.validators.length === 0) return;
      const i = e.join(Sm);
      return (o = t.validators.find(({
          validator: a
      }) => a(i))) == null ? void 0 : o.classGroupId
  },
  ov = /^\[(.+)\]$/,
  nN = e => {
      if (ov.test(e)) {
          const t = ov.exec(e)[1],
              n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
          if (n) return "arbitrary.." + n
      }
  },
  rN = e => {
      const {
          theme: t,
          prefix: n
      } = e, r = {
          nextPart: new Map,
          validators: []
      };
      return iN(Object.entries(e.classGroups), n).forEach(([i, o]) => {
          pf(o, r, i, t)
      }), r
  },
  pf = (e, t, n, r) => {
      e.forEach(s => {
          if (typeof s == "string") {
              const i = s === "" ? t : av(t, s);
              i.classGroupId = n;
              return
          }
          if (typeof s == "function") {
              if (sN(s)) {
                  pf(s(r), t, n, r);
                  return
              }
              t.validators.push({
                  validator: s,
                  classGroupId: n
              });
              return
          }
          Object.entries(s).forEach(([i, o]) => {
              pf(o, av(t, i), n, r)
          })
      })
  },
  av = (e, t) => {
      let n = e;
      return t.split(Sm).forEach(r => {
          n.nextPart.has(r) || n.nextPart.set(r, {
              nextPart: new Map,
              validators: []
          }), n = n.nextPart.get(r)
      }), n
  },
  sN = e => e.isThemeGetter,
  iN = (e, t) => t ? e.map(([n, r]) => {
      const s = r.map(i => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, a]) => [t + o, a])) : i);
      return [n, s]
  }) : e,
  oN = e => {
      if (e < 1) return {
          get: () => {},
          set: () => {}
      };
      let t = 0,
          n = new Map,
          r = new Map;
      const s = (i, o) => {
          n.set(i, o), t++, t > e && (t = 0, r = n, n = new Map)
      };
      return {
          get(i) {
              let o = n.get(i);
              if (o !== void 0) return o;
              if ((o = r.get(i)) !== void 0) return s(i, o), o
          },
          set(i, o) {
              n.has(i) ? n.set(i, o) : s(i, o)
          }
      }
  },
  F1 = "!",
  aN = e => {
      const {
          separator: t,
          experimentalParseClassName: n
      } = e, r = t.length === 1, s = t[0], i = t.length, o = a => {
          const l = [];
          let c = 0,
              u = 0,
              d;
          for (let b = 0; b < a.length; b++) {
              let v = a[b];
              if (c === 0) {
                  if (v === s && (r || a.slice(b, b + i) === t)) {
                      l.push(a.slice(u, b)), u = b + i;
                      continue
                  }
                  if (v === "/") {
                      d = b;
                      continue
                  }
              }
              v === "[" ? c++ : v === "]" && c--
          }
          const h = l.length === 0 ? a : a.substring(u),
              f = h.startsWith(F1),
              x = f ? h.substring(1) : h,
              m = d && d > u ? d - u : void 0;
          return {
              modifiers: l,
              hasImportantModifier: f,
              baseClassName: x,
              maybePostfixModifierPosition: m
          }
      };
      return n ? a => n({
          className: a,
          parseClassName: o
      }) : o
  },
  lN = e => {
      if (e.length <= 1) return e;
      const t = [];
      let n = [];
      return e.forEach(r => {
          r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r)
      }), t.push(...n.sort()), t
  },
  cN = e => ({
      cache: oN(e.cacheSize),
      parseClassName: aN(e),
      ...tN(e)
  }),
  uN = /\s+/,
  dN = (e, t) => {
      const {
          parseClassName: n,
          getClassGroupId: r,
          getConflictingClassGroupIds: s
      } = t, i = [], o = e.trim().split(uN);
      let a = "";
      for (let l = o.length - 1; l >= 0; l -= 1) {
          const c = o[l],
              {
                  modifiers: u,
                  hasImportantModifier: d,
                  baseClassName: h,
                  maybePostfixModifierPosition: f
              } = n(c);
          let x = !!f,
              m = r(x ? h.substring(0, f) : h);
          if (!m) {
              if (!x) {
                  a = c + (a.length > 0 ? " " + a : a);
                  continue
              }
              if (m = r(h), !m) {
                  a = c + (a.length > 0 ? " " + a : a);
                  continue
              }
              x = !1
          }
          const b = lN(u).join(":"),
              v = d ? b + F1 : b,
              y = v + m;
          if (i.includes(y)) continue;
          i.push(y);
          const w = s(m, x);
          for (let S = 0; S < w.length; ++S) {
              const _ = w[S];
              i.push(v + _)
          }
          a = c + (a.length > 0 ? " " + a : a)
      }
      return a
  };

function hN() {
  let e = 0,
      t, n, r = "";
  for (; e < arguments.length;)(t = arguments[e++]) && (n = U1(t)) && (r && (r += " "), r += n);
  return r
}
const U1 = e => {
  if (typeof e == "string") return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++) e[r] && (t = U1(e[r])) && (n && (n += " "), n += t);
  return n
};

function fN(e, ...t) {
  let n, r, s, i = o;

  function o(l) {
      const c = t.reduce((u, d) => d(u), e());
      return n = cN(c), r = n.cache.get, s = n.cache.set, i = a, a(l)
  }

  function a(l) {
      const c = r(l);
      if (c) return c;
      const u = dN(l, n);
      return s(l, u), u
  }
  return function() {
      return i(hN.apply(null, arguments))
  }
}
const ge = e => {
      const t = n => n[e] || [];
      return t.isThemeGetter = !0, t
  },
  V1 = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  pN = /^\d+\/\d+$/,
  mN = new Set(["px", "full", "screen"]),
  gN = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  yN = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  vN = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  wN = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  xN = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Dn = e => zi(e) || mN.has(e) || pN.test(e),
  dr = e => _o(e, "length", RN),
  zi = e => !!e && !Number.isNaN(Number(e)),
  Id = e => _o(e, "number", zi),
  Bo = e => !!e && Number.isInteger(Number(e)),
  bN = e => e.endsWith("%") && zi(e.slice(0, -1)),
  Z = e => V1.test(e),
  hr = e => gN.test(e),
  SN = new Set(["length", "size", "percentage"]),
  _N = e => _o(e, SN, B1),
  EN = e => _o(e, "position", B1),
  CN = new Set(["image", "url"]),
  TN = e => _o(e, CN, AN),
  kN = e => _o(e, "", PN),
  zo = () => !0,
  _o = (e, t, n) => {
      const r = V1.exec(e);
      return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1
  },
  RN = e => yN.test(e) && !vN.test(e),
  B1 = () => !1,
  PN = e => wN.test(e),
  AN = e => xN.test(e),
  NN = () => {
      const e = ge("colors"),
          t = ge("spacing"),
          n = ge("blur"),
          r = ge("brightness"),
          s = ge("borderColor"),
          i = ge("borderRadius"),
          o = ge("borderSpacing"),
          a = ge("borderWidth"),
          l = ge("contrast"),
          c = ge("grayscale"),
          u = ge("hueRotate"),
          d = ge("invert"),
          h = ge("gap"),
          f = ge("gradientColorStops"),
          x = ge("gradientColorStopPositions"),
          m = ge("inset"),
          b = ge("margin"),
          v = ge("opacity"),
          y = ge("padding"),
          w = ge("saturate"),
          S = ge("scale"),
          _ = ge("sepia"),
          E = ge("skew"),
          T = ge("space"),
          k = ge("translate"),
          P = () => ["auto", "contain", "none"],
          A = () => ["auto", "hidden", "clip", "visible", "scroll"],
          $ = () => ["auto", Z, t],
          I = () => [Z, t],
          G = () => ["", Dn, dr],
          D = () => ["auto", zi, Z],
          X = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"],
          B = () => ["solid", "dashed", "dotted", "double", "none"],
          U = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
          R = () => ["start", "end", "center", "between", "around", "evenly", "stretch"],
          N = () => ["", "0", Z],
          M = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"],
          Q = () => [zi, Z];
      return {
          cacheSize: 500,
          separator: ":",
          theme: {
              colors: [zo],
              spacing: [Dn, dr],
              blur: ["none", "", hr, Z],
              brightness: Q(),
              borderColor: [e],
              borderRadius: ["none", "", "full", hr, Z],
              borderSpacing: I(),
              borderWidth: G(),
              contrast: Q(),
              grayscale: N(),
              hueRotate: Q(),
              invert: N(),
              gap: I(),
              gradientColorStops: [e],
              gradientColorStopPositions: [bN, dr],
              inset: $(),
              margin: $(),
              opacity: Q(),
              padding: I(),
              saturate: Q(),
              scale: Q(),
              sepia: N(),
              skew: Q(),
              space: I(),
              translate: I()
          },
          classGroups: {
              aspect: [{
                  aspect: ["auto", "square", "video", Z]
              }],
              container: ["container"],
              columns: [{
                  columns: [hr]
              }],
              "break-after": [{
                  "break-after": M()
              }],
              "break-before": [{
                  "break-before": M()
              }],
              "break-inside": [{
                  "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
              }],
              "box-decoration": [{
                  "box-decoration": ["slice", "clone"]
              }],
              box: [{
                  box: ["border", "content"]
              }],
              display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
              float: [{
                  float: ["right", "left", "none", "start", "end"]
              }],
              clear: [{
                  clear: ["left", "right", "both", "none", "start", "end"]
              }],
              isolation: ["isolate", "isolation-auto"],
              "object-fit": [{
                  object: ["contain", "cover", "fill", "none", "scale-down"]
              }],
              "object-position": [{
                  object: [...X(), Z]
              }],
              overflow: [{
                  overflow: A()
              }],
              "overflow-x": [{
                  "overflow-x": A()
              }],
              "overflow-y": [{
                  "overflow-y": A()
              }],
              overscroll: [{
                  overscroll: P()
              }],
              "overscroll-x": [{
                  "overscroll-x": P()
              }],
              "overscroll-y": [{
                  "overscroll-y": P()
              }],
              position: ["static", "fixed", "absolute", "relative", "sticky"],
              inset: [{
                  inset: [m]
              }],
              "inset-x": [{
                  "inset-x": [m]
              }],
              "inset-y": [{
                  "inset-y": [m]
              }],
              start: [{
                  start: [m]
              }],
              end: [{
                  end: [m]
              }],
              top: [{
                  top: [m]
              }],
              right: [{
                  right: [m]
              }],
              bottom: [{
                  bottom: [m]
              }],
              left: [{
                  left: [m]
              }],
              visibility: ["visible", "invisible", "collapse"],
              z: [{
                  z: ["auto", Bo, Z]
              }],
              basis: [{
                  basis: $()
              }],
              "flex-direction": [{
                  flex: ["row", "row-reverse", "col", "col-reverse"]
              }],
              "flex-wrap": [{
                  flex: ["wrap", "wrap-reverse", "nowrap"]
              }],
              flex: [{
                  flex: ["1", "auto", "initial", "none", Z]
              }],
              grow: [{
                  grow: N()
              }],
              shrink: [{
                  shrink: N()
              }],
              order: [{
                  order: ["first", "last", "none", Bo, Z]
              }],
              "grid-cols": [{
                  "grid-cols": [zo]
              }],
              "col-start-end": [{
                  col: ["auto", {
                      span: ["full", Bo, Z]
                  }, Z]
              }],
              "col-start": [{
                  "col-start": D()
              }],
              "col-end": [{
                  "col-end": D()
              }],
              "grid-rows": [{
                  "grid-rows": [zo]
              }],
              "row-start-end": [{
                  row: ["auto", {
                      span: [Bo, Z]
                  }, Z]
              }],
              "row-start": [{
                  "row-start": D()
              }],
              "row-end": [{
                  "row-end": D()
              }],
              "grid-flow": [{
                  "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
              }],
              "auto-cols": [{
                  "auto-cols": ["auto", "min", "max", "fr", Z]
              }],
              "auto-rows": [{
                  "auto-rows": ["auto", "min", "max", "fr", Z]
              }],
              gap: [{
                  gap: [h]
              }],
              "gap-x": [{
                  "gap-x": [h]
              }],
              "gap-y": [{
                  "gap-y": [h]
              }],
              "justify-content": [{
                  justify: ["normal", ...R()]
              }],
              "justify-items": [{
                  "justify-items": ["start", "end", "center", "stretch"]
              }],
              "justify-self": [{
                  "justify-self": ["auto", "start", "end", "center", "stretch"]
              }],
              "align-content": [{
                  content: ["normal", ...R(), "baseline"]
              }],
              "align-items": [{
                  items: ["start", "end", "center", "baseline", "stretch"]
              }],
              "align-self": [{
                  self: ["auto", "start", "end", "center", "stretch", "baseline"]
              }],
              "place-content": [{
                  "place-content": [...R(), "baseline"]
              }],
              "place-items": [{
                  "place-items": ["start", "end", "center", "baseline", "stretch"]
              }],
              "place-self": [{
                  "place-self": ["auto", "start", "end", "center", "stretch"]
              }],
              p: [{
                  p: [y]
              }],
              px: [{
                  px: [y]
              }],
              py: [{
                  py: [y]
              }],
              ps: [{
                  ps: [y]
              }],
              pe: [{
                  pe: [y]
              }],
              pt: [{
                  pt: [y]
              }],
              pr: [{
                  pr: [y]
              }],
              pb: [{
                  pb: [y]
              }],
              pl: [{
                  pl: [y]
              }],
              m: [{
                  m: [b]
              }],
              mx: [{
                  mx: [b]
              }],
              my: [{
                  my: [b]
              }],
              ms: [{
                  ms: [b]
              }],
              me: [{
                  me: [b]
              }],
              mt: [{
                  mt: [b]
              }],
              mr: [{
                  mr: [b]
              }],
              mb: [{
                  mb: [b]
              }],
              ml: [{
                  ml: [b]
              }],
              "space-x": [{
                  "space-x": [T]
              }],
              "space-x-reverse": ["space-x-reverse"],
              "space-y": [{
                  "space-y": [T]
              }],
              "space-y-reverse": ["space-y-reverse"],
              w: [{
                  w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Z, t]
              }],
              "min-w": [{
                  "min-w": [Z, t, "min", "max", "fit"]
              }],
              "max-w": [{
                  "max-w": [Z, t, "none", "full", "min", "max", "fit", "prose", {
                      screen: [hr]
                  }, hr]
              }],
              h: [{
                  h: [Z, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
              }],
              "min-h": [{
                  "min-h": [Z, t, "min", "max", "fit", "svh", "lvh", "dvh"]
              }],
              "max-h": [{
                  "max-h": [Z, t, "min", "max", "fit", "svh", "lvh", "dvh"]
              }],
              size: [{
                  size: [Z, t, "auto", "min", "max", "fit"]
              }],
              "font-size": [{
                  text: ["base", hr, dr]
              }],
              "font-smoothing": ["antialiased", "subpixel-antialiased"],
              "font-style": ["italic", "not-italic"],
              "font-weight": [{
                  font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Id]
              }],
              "font-family": [{
                  font: [zo]
              }],
              "fvn-normal": ["normal-nums"],
              "fvn-ordinal": ["ordinal"],
              "fvn-slashed-zero": ["slashed-zero"],
              "fvn-figure": ["lining-nums", "oldstyle-nums"],
              "fvn-spacing": ["proportional-nums", "tabular-nums"],
              "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
              tracking: [{
                  tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Z]
              }],
              "line-clamp": [{
                  "line-clamp": ["none", zi, Id]
              }],
              leading: [{
                  leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Dn, Z]
              }],
              "list-image": [{
                  "list-image": ["none", Z]
              }],
              "list-style-type": [{
                  list: ["none", "disc", "decimal", Z]
              }],
              "list-style-position": [{
                  list: ["inside", "outside"]
              }],
              "placeholder-color": [{
                  placeholder: [e]
              }],
              "placeholder-opacity": [{
                  "placeholder-opacity": [v]
              }],
              "text-alignment": [{
                  text: ["left", "center", "right", "justify", "start", "end"]
              }],
              "text-color": [{
                  text: [e]
              }],
              "text-opacity": [{
                  "text-opacity": [v]
              }],
              "text-decoration": ["underline", "overline", "line-through", "no-underline"],
              "text-decoration-style": [{
                  decoration: [...B(), "wavy"]
              }],
              "text-decoration-thickness": [{
                  decoration: ["auto", "from-font", Dn, dr]
              }],
              "underline-offset": [{
                  "underline-offset": ["auto", Dn, Z]
              }],
              "text-decoration-color": [{
                  decoration: [e]
              }],
              "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
              "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
              "text-wrap": [{
                  text: ["wrap", "nowrap", "balance", "pretty"]
              }],
              indent: [{
                  indent: I()
              }],
              "vertical-align": [{
                  align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Z]
              }],
              whitespace: [{
                  whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
              }],
              break: [{
                  break: ["normal", "words", "all", "keep"]
              }],
              hyphens: [{
                  hyphens: ["none", "manual", "auto"]
              }],
              content: [{
                  content: ["none", Z]
              }],
              "bg-attachment": [{
                  bg: ["fixed", "local", "scroll"]
              }],
              "bg-clip": [{
                  "bg-clip": ["border", "padding", "content", "text"]
              }],
              "bg-opacity": [{
                  "bg-opacity": [v]
              }],
              "bg-origin": [{
                  "bg-origin": ["border", "padding", "content"]
              }],
              "bg-position": [{
                  bg: [...X(), EN]
              }],
              "bg-repeat": [{
                  bg: ["no-repeat", {
                      repeat: ["", "x", "y", "round", "space"]
                  }]
              }],
              "bg-size": [{
                  bg: ["auto", "cover", "contain", _N]
              }],
              "bg-image": [{
                  bg: ["none", {
                      "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                  }, TN]
              }],
              "bg-color": [{
                  bg: [e]
              }],
              "gradient-from-pos": [{
                  from: [x]
              }],
              "gradient-via-pos": [{
                  via: [x]
              }],
              "gradient-to-pos": [{
                  to: [x]
              }],
              "gradient-from": [{
                  from: [f]
              }],
              "gradient-via": [{
                  via: [f]
              }],
              "gradient-to": [{
                  to: [f]
              }],
              rounded: [{
                  rounded: [i]
              }],
              "rounded-s": [{
                  "rounded-s": [i]
              }],
              "rounded-e": [{
                  "rounded-e": [i]
              }],
              "rounded-t": [{
                  "rounded-t": [i]
              }],
              "rounded-r": [{
                  "rounded-r": [i]
              }],
              "rounded-b": [{
                  "rounded-b": [i]
              }],
              "rounded-l": [{
                  "rounded-l": [i]
              }],
              "rounded-ss": [{
                  "rounded-ss": [i]
              }],
              "rounded-se": [{
                  "rounded-se": [i]
              }],
              "rounded-ee": [{
                  "rounded-ee": [i]
              }],
              "rounded-es": [{
                  "rounded-es": [i]
              }],
              "rounded-tl": [{
                  "rounded-tl": [i]
              }],
              "rounded-tr": [{
                  "rounded-tr": [i]
              }],
              "rounded-br": [{
                  "rounded-br": [i]
              }],
              "rounded-bl": [{
                  "rounded-bl": [i]
              }],
              "border-w": [{
                  border: [a]
              }],
              "border-w-x": [{
                  "border-x": [a]
              }],
              "border-w-y": [{
                  "border-y": [a]
              }],
              "border-w-s": [{
                  "border-s": [a]
              }],
              "border-w-e": [{
                  "border-e": [a]
              }],
              "border-w-t": [{
                  "border-t": [a]
              }],
              "border-w-r": [{
                  "border-r": [a]
              }],
              "border-w-b": [{
                  "border-b": [a]
              }],
              "border-w-l": [{
                  "border-l": [a]
              }],
              "border-opacity": [{
                  "border-opacity": [v]
              }],
              "border-style": [{
                  border: [...B(), "hidden"]
              }],
              "divide-x": [{
                  "divide-x": [a]
              }],
              "divide-x-reverse": ["divide-x-reverse"],
              "divide-y": [{
                  "divide-y": [a]
              }],
              "divide-y-reverse": ["divide-y-reverse"],
              "divide-opacity": [{
                  "divide-opacity": [v]
              }],
              "divide-style": [{
                  divide: B()
              }],
              "border-color": [{
                  border: [s]
              }],
              "border-color-x": [{
                  "border-x": [s]
              }],
              "border-color-y": [{
                  "border-y": [s]
              }],
              "border-color-s": [{
                  "border-s": [s]
              }],
              "border-color-e": [{
                  "border-e": [s]
              }],
              "border-color-t": [{
                  "border-t": [s]
              }],
              "border-color-r": [{
                  "border-r": [s]
              }],
              "border-color-b": [{
                  "border-b": [s]
              }],
              "border-color-l": [{
                  "border-l": [s]
              }],
              "divide-color": [{
                  divide: [s]
              }],
              "outline-style": [{
                  outline: ["", ...B()]
              }],
              "outline-offset": [{
                  "outline-offset": [Dn, Z]
              }],
              "outline-w": [{
                  outline: [Dn, dr]
              }],
              "outline-color": [{
                  outline: [e]
              }],
              "ring-w": [{
                  ring: G()
              }],
              "ring-w-inset": ["ring-inset"],
              "ring-color": [{
                  ring: [e]
              }],
              "ring-opacity": [{
                  "ring-opacity": [v]
              }],
              "ring-offset-w": [{
                  "ring-offset": [Dn, dr]
              }],
              "ring-offset-color": [{
                  "ring-offset": [e]
              }],
              shadow: [{
                  shadow: ["", "inner", "none", hr, kN]
              }],
              "shadow-color": [{
                  shadow: [zo]
              }],
              opacity: [{
                  opacity: [v]
              }],
              "mix-blend": [{
                  "mix-blend": [...U(), "plus-lighter", "plus-darker"]
              }],
              "bg-blend": [{
                  "bg-blend": U()
              }],
              filter: [{
                  filter: ["", "none"]
              }],
              blur: [{
                  blur: [n]
              }],
              brightness: [{
                  brightness: [r]
              }],
              contrast: [{
                  contrast: [l]
              }],
              "drop-shadow": [{
                  "drop-shadow": ["", "none", hr, Z]
              }],
              grayscale: [{
                  grayscale: [c]
              }],
              "hue-rotate": [{
                  "hue-rotate": [u]
              }],
              invert: [{
                  invert: [d]
              }],
              saturate: [{
                  saturate: [w]
              }],
              sepia: [{
                  sepia: [_]
              }],
              "backdrop-filter": [{
                  "backdrop-filter": ["", "none"]
              }],
              "backdrop-blur": [{
                  "backdrop-blur": [n]
              }],
              "backdrop-brightness": [{
                  "backdrop-brightness": [r]
              }],
              "backdrop-contrast": [{
                  "backdrop-contrast": [l]
              }],
              "backdrop-grayscale": [{
                  "backdrop-grayscale": [c]
              }],
              "backdrop-hue-rotate": [{
                  "backdrop-hue-rotate": [u]
              }],
              "backdrop-invert": [{
                  "backdrop-invert": [d]
              }],
              "backdrop-opacity": [{
                  "backdrop-opacity": [v]
              }],
              "backdrop-saturate": [{
                  "backdrop-saturate": [w]
              }],
              "backdrop-sepia": [{
                  "backdrop-sepia": [_]
              }],
              "border-collapse": [{
                  border: ["collapse", "separate"]
              }],
              "border-spacing": [{
                  "border-spacing": [o]
              }],
              "border-spacing-x": [{
                  "border-spacing-x": [o]
              }],
              "border-spacing-y": [{
                  "border-spacing-y": [o]
              }],
              "table-layout": [{
                  table: ["auto", "fixed"]
              }],
              caption: [{
                  caption: ["top", "bottom"]
              }],
              transition: [{
                  transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Z]
              }],
              duration: [{
                  duration: Q()
              }],
              ease: [{
                  ease: ["linear", "in", "out", "in-out", Z]
              }],
              delay: [{
                  delay: Q()
              }],
              animate: [{
                  animate: ["none", "spin", "ping", "pulse", "bounce", Z]
              }],
              transform: [{
                  transform: ["", "gpu", "none"]
              }],
              scale: [{
                  scale: [S]
              }],
              "scale-x": [{
                  "scale-x": [S]
              }],
              "scale-y": [{
                  "scale-y": [S]
              }],
              rotate: [{
                  rotate: [Bo, Z]
              }],
              "translate-x": [{
                  "translate-x": [k]
              }],
              "translate-y": [{
                  "translate-y": [k]
              }],
              "skew-x": [{
                  "skew-x": [E]
              }],
              "skew-y": [{
                  "skew-y": [E]
              }],
              "transform-origin": [{
                  origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Z]
              }],
              accent: [{
                  accent: ["auto", e]
              }],
              appearance: [{
                  appearance: ["none", "auto"]
              }],
              cursor: [{
                  cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Z]
              }],
              "caret-color": [{
                  caret: [e]
              }],
              "pointer-events": [{
                  "pointer-events": ["none", "auto"]
              }],
              resize: [{
                  resize: ["none", "y", "x", ""]
              }],
              "scroll-behavior": [{
                  scroll: ["auto", "smooth"]
              }],
              "scroll-m": [{
                  "scroll-m": I()
              }],
              "scroll-mx": [{
                  "scroll-mx": I()
              }],
              "scroll-my": [{
                  "scroll-my": I()
              }],
              "scroll-ms": [{
                  "scroll-ms": I()
              }],
              "scroll-me": [{
                  "scroll-me": I()
              }],
              "scroll-mt": [{
                  "scroll-mt": I()
              }],
              "scroll-mr": [{
                  "scroll-mr": I()
              }],
              "scroll-mb": [{
                  "scroll-mb": I()
              }],
              "scroll-ml": [{
                  "scroll-ml": I()
              }],
              "scroll-p": [{
                  "scroll-p": I()
              }],
              "scroll-px": [{
                  "scroll-px": I()
              }],
              "scroll-py": [{
                  "scroll-py": I()
              }],
              "scroll-ps": [{
                  "scroll-ps": I()
              }],
              "scroll-pe": [{
                  "scroll-pe": I()
              }],
              "scroll-pt": [{
                  "scroll-pt": I()
              }],
              "scroll-pr": [{
                  "scroll-pr": I()
              }],
              "scroll-pb": [{
                  "scroll-pb": I()
              }],
              "scroll-pl": [{
                  "scroll-pl": I()
              }],
              "snap-align": [{
                  snap: ["start", "end", "center", "align-none"]
              }],
              "snap-stop": [{
                  snap: ["normal", "always"]
              }],
              "snap-type": [{
                  snap: ["none", "x", "y", "both"]
              }],
              "snap-strictness": [{
                  snap: ["mandatory", "proximity"]
              }],
              touch: [{
                  touch: ["auto", "none", "manipulation"]
              }],
              "touch-x": [{
                  "touch-pan": ["x", "left", "right"]
              }],
              "touch-y": [{
                  "touch-pan": ["y", "up", "down"]
              }],
              "touch-pz": ["touch-pinch-zoom"],
              select: [{
                  select: ["none", "text", "all", "auto"]
              }],
              "will-change": [{
                  "will-change": ["auto", "scroll", "contents", "transform", Z]
              }],
              fill: [{
                  fill: [e, "none"]
              }],
              "stroke-w": [{
                  stroke: [Dn, dr, Id]
              }],
              stroke: [{
                  stroke: [e, "none"]
              }],
              sr: ["sr-only", "not-sr-only"],
              "forced-color-adjust": [{
                  "forced-color-adjust": ["auto", "none"]
              }]
          },
          conflictingClassGroups: {
              overflow: ["overflow-x", "overflow-y"],
              overscroll: ["overscroll-x", "overscroll-y"],
              inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
              "inset-x": ["right", "left"],
              "inset-y": ["top", "bottom"],
              flex: ["basis", "grow", "shrink"],
              gap: ["gap-x", "gap-y"],
              p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
              px: ["pr", "pl"],
              py: ["pt", "pb"],
              m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
              mx: ["mr", "ml"],
              my: ["mt", "mb"],
              size: ["w", "h"],
              "font-size": ["leading"],
              "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
              "fvn-ordinal": ["fvn-normal"],
              "fvn-slashed-zero": ["fvn-normal"],
              "fvn-figure": ["fvn-normal"],
              "fvn-spacing": ["fvn-normal"],
              "fvn-fraction": ["fvn-normal"],
              "line-clamp": ["display", "overflow"],
              rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
              "rounded-s": ["rounded-ss", "rounded-es"],
              "rounded-e": ["rounded-se", "rounded-ee"],
              "rounded-t": ["rounded-tl", "rounded-tr"],
              "rounded-r": ["rounded-tr", "rounded-br"],
              "rounded-b": ["rounded-br", "rounded-bl"],
              "rounded-l": ["rounded-tl", "rounded-bl"],
              "border-spacing": ["border-spacing-x", "border-spacing-y"],
              "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
              "border-w-x": ["border-w-r", "border-w-l"],
              "border-w-y": ["border-w-t", "border-w-b"],
              "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
              "border-color-x": ["border-color-r", "border-color-l"],
              "border-color-y": ["border-color-t", "border-color-b"],
              "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
              "scroll-mx": ["scroll-mr", "scroll-ml"],
              "scroll-my": ["scroll-mt", "scroll-mb"],
              "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
              "scroll-px": ["scroll-pr", "scroll-pl"],
              "scroll-py": ["scroll-pt", "scroll-pb"],
              touch: ["touch-x", "touch-y", "touch-pz"],
              "touch-x": ["touch"],
              "touch-y": ["touch"],
              "touch-pz": ["touch"]
          },
          conflictingClassGroupModifiers: {
              "font-size": ["leading"]
          }
      }
  },
  jN = fN(NN);

function ee(...e) {
  return jN(I1(e))
}
const ON = CA,
  z1 = g.forwardRef(({
      className: e,
      ...t
  }, n) => p.jsx(k1, {
      ref: n,
      className: ee("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", e),
      ...t
  }));
z1.displayName = k1.displayName;
const IN = ju("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
      variants: {
          variant: {
              default: "border bg-background text-foreground",
              destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
          }
      },
      defaultVariants: {
          variant: "default"
      }
  }),
  W1 = g.forwardRef(({
      className: e,
      variant: t,
      ...n
  }, r) => p.jsx(R1, {
      ref: r,
      className: ee(IN({
          variant: t
      }), e),
      ...n
  }));
W1.displayName = R1.displayName;
const DN = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(N1, {
  ref: n,
  className: ee("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50", e),
  ...t
}));
DN.displayName = N1.displayName;
const H1 = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(j1, {
  ref: n,
  className: ee("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", e),
  "toast-close": "",
  ...t,
  children: p.jsx(eN, {
      className: "h-4 w-4"
  })
}));
H1.displayName = j1.displayName;
const K1 = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(P1, {
  ref: n,
  className: ee("text-sm font-semibold", e),
  ...t
}));
K1.displayName = P1.displayName;
const q1 = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(A1, {
  ref: n,
  className: ee("text-sm opacity-90", e),
  ...t
}));
q1.displayName = A1.displayName;

function MN() {
  const {
      toasts: e
  } = Ru();
  return p.jsxs(ON, {
      children: [e.map(function({
          id: t,
          title: n,
          description: r,
          action: s,
          ...i
      }) {
          return p.jsxs(W1, {
              ...i,
              children: [p.jsxs("div", {
                  className: "grid gap-1",
                  children: [n && p.jsx(K1, {
                      children: n
                  }), r && p.jsx(q1, {
                      children: r
                  })]
              }), s, p.jsx(H1, {})]
          }, t)
      }), p.jsx(z1, {})]
  })
}
var lv = ["light", "dark"],
  LN = "(prefers-color-scheme: dark)",
  $N = g.createContext(void 0),
  FN = {
      setTheme: e => {},
      themes: []
  },
  UN = () => {
      var e;
      return (e = g.useContext($N)) != null ? e : FN
  };
g.memo(({
  forcedTheme: e,
  storageKey: t,
  attribute: n,
  enableSystem: r,
  enableColorScheme: s,
  defaultTheme: i,
  value: o,
  attrs: a,
  nonce: l
}) => {
  let c = i === "system",
      u = n === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${a.map(x => `'${x}'`).join(",")})`};` : `var d=document.documentElement,n='${n}',s='setAttribute';`,
      d = s ? lv.includes(i) && i ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "",
      h = (x, m = !1, b = !0) => {
          let v = o ? o[x] : x,
              y = m ? x + "|| ''" : `'${v}'`,
              w = "";
          return s && b && !m && lv.includes(x) && (w += `d.style.colorScheme = '${x}';`), n === "class" ? m || v ? w += `c.add(${y})` : w += "null" : v && (w += `d[s](n,${y})`), w
      },
      f = e ? `!function(){${u}${h(e)}}()` : r ? `!function(){try{${u}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${c})){var t='${LN}',m=window.matchMedia(t);if(m.media!==t||m.matches){${h("dark")}}else{${h("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${h(o ? "x[e]" : "e", !0)}}${c ? "" : "else{" + h(i, !1, !1) + "}"}${d}}catch(e){}}()` : `!function(){try{${u}var e=localStorage.getItem('${t}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${h(o ? "x[e]" : "e", !0)}}else{${h(i, !1, !1)};}${d}}catch(t){}}();`;
  return g.createElement("script", {
      nonce: l,
      dangerouslySetInnerHTML: {
          __html: f
      }
  })
});
var VN = e => {
      switch (e) {
          case "success":
              return WN;
          case "info":
              return KN;
          case "warning":
              return HN;
          case "error":
              return qN;
          default:
              return null
      }
  },
  BN = Array(12).fill(0),
  zN = ({
      visible: e,
      className: t
  }) => j.createElement("div", {
      className: ["sonner-loading-wrapper", t].filter(Boolean).join(" "),
      "data-visible": e
  }, j.createElement("div", {
      className: "sonner-spinner"
  }, BN.map((n, r) => j.createElement("div", {
      className: "sonner-loading-bar",
      key: `spinner-bar-${r}`
  })))),
  WN = j.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20"
  }, j.createElement("path", {
      fillRule: "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
      clipRule: "evenodd"
  })),
  HN = j.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      height: "20",
      width: "20"
  }, j.createElement("path", {
      fillRule: "evenodd",
      d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
      clipRule: "evenodd"
  })),
  KN = j.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20"
  }, j.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
      clipRule: "evenodd"
  })),
  qN = j.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20"
  }, j.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
      clipRule: "evenodd"
  })),
  GN = j.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "12",
      height: "12",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
  }, j.createElement("line", {
      x1: "18",
      y1: "6",
      x2: "6",
      y2: "18"
  }), j.createElement("line", {
      x1: "6",
      y1: "6",
      x2: "18",
      y2: "18"
  })),
  QN = () => {
      let [e, t] = j.useState(document.hidden);
      return j.useEffect(() => {
          let n = () => {
              t(document.hidden)
          };
          return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n)
      }, []), e
  },
  mf = 1,
  YN = class {
      constructor() {
          this.subscribe = e => (this.subscribers.push(e), () => {
              let t = this.subscribers.indexOf(e);
              this.subscribers.splice(t, 1)
          }), this.publish = e => {
              this.subscribers.forEach(t => t(e))
          }, this.addToast = e => {
              this.publish(e), this.toasts = [...this.toasts, e]
          }, this.create = e => {
              var t;
              let {
                  message: n,
                  ...r
              } = e, s = typeof(e == null ? void 0 : e.id) == "number" || ((t = e.id) == null ? void 0 : t.length) > 0 ? e.id : mf++, i = this.toasts.find(a => a.id === s), o = e.dismissible === void 0 ? !0 : e.dismissible;
              return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s), i ? this.toasts = this.toasts.map(a => a.id === s ? (this.publish({
                  ...a,
                  ...e,
                  id: s,
                  title: n
              }), {
                  ...a,
                  ...e,
                  id: s,
                  dismissible: o,
                  title: n
              }) : a) : this.addToast({
                  title: n,
                  ...r,
                  dismissible: o,
                  id: s
              }), s
          }, this.dismiss = e => (this.dismissedToasts.add(e), e || this.toasts.forEach(t => {
              this.subscribers.forEach(n => n({
                  id: t.id,
                  dismiss: !0
              }))
          }), this.subscribers.forEach(t => t({
              id: e,
              dismiss: !0
          })), e), this.message = (e, t) => this.create({
              ...t,
              message: e
          }), this.error = (e, t) => this.create({
              ...t,
              message: e,
              type: "error"
          }), this.success = (e, t) => this.create({
              ...t,
              type: "success",
              message: e
          }), this.info = (e, t) => this.create({
              ...t,
              type: "info",
              message: e
          }), this.warning = (e, t) => this.create({
              ...t,
              type: "warning",
              message: e
          }), this.loading = (e, t) => this.create({
              ...t,
              type: "loading",
              message: e
          }), this.promise = (e, t) => {
              if (!t) return;
              let n;
              t.loading !== void 0 && (n = this.create({
                  ...t,
                  promise: e,
                  type: "loading",
                  message: t.loading,
                  description: typeof t.description != "function" ? t.description : void 0
              }));
              let r = e instanceof Promise ? e : e(),
                  s = n !== void 0,
                  i, o = r.then(async l => {
                      if (i = ["resolve", l], j.isValidElement(l)) s = !1, this.create({
                          id: n,
                          type: "default",
                          message: l
                      });
                      else if (XN(l) && !l.ok) {
                          s = !1;
                          let c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${l.status}`) : t.error,
                              u = typeof t.description == "function" ? await t.description(`HTTP error! status: ${l.status}`) : t.description;
                          this.create({
                              id: n,
                              type: "error",
                              message: c,
                              description: u
                          })
                      } else if (t.success !== void 0) {
                          s = !1;
                          let c = typeof t.success == "function" ? await t.success(l) : t.success,
                              u = typeof t.description == "function" ? await t.description(l) : t.description;
                          this.create({
                              id: n,
                              type: "success",
                              message: c,
                              description: u
                          })
                      }
                  }).catch(async l => {
                      if (i = ["reject", l], t.error !== void 0) {
                          s = !1;
                          let c = typeof t.error == "function" ? await t.error(l) : t.error,
                              u = typeof t.description == "function" ? await t.description(l) : t.description;
                          this.create({
                              id: n,
                              type: "error",
                              message: c,
                              description: u
                          })
                      }
                  }).finally(() => {
                      var l;
                      s && (this.dismiss(n), n = void 0), (l = t.finally) == null || l.call(t)
                  }),
                  a = () => new Promise((l, c) => o.then(() => i[0] === "reject" ? c(i[1]) : l(i[1])).catch(c));
              return typeof n != "string" && typeof n != "number" ? {
                  unwrap: a
              } : Object.assign(n, {
                  unwrap: a
              })
          }, this.custom = (e, t) => {
              let n = (t == null ? void 0 : t.id) || mf++;
              return this.create({
                  jsx: e(n),
                  id: n,
                  ...t
              }), n
          }, this.getActiveToasts = () => this.toasts.filter(e => !this.dismissedToasts.has(e.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set
      }
  },
  mt = new YN,
  JN = (e, t) => {
      let n = (t == null ? void 0 : t.id) || mf++;
      return mt.addToast({
          title: e,
          ...t,
          id: n
      }), n
  },
  XN = e => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number",
  ZN = JN,
  ej = () => mt.toasts,
  tj = () => mt.getActiveToasts();
Object.assign(ZN, {
  success: mt.success,
  info: mt.info,
  warning: mt.warning,
  error: mt.error,
  custom: mt.custom,
  message: mt.message,
  promise: mt.promise,
  dismiss: mt.dismiss,
  loading: mt.loading
}, {
  getHistory: ej,
  getToasts: tj
});

function nj(e, {
  insertAt: t
} = {}) {
  if (typeof document > "u") return;
  let n = document.head || document.getElementsByTagName("head")[0],
      r = document.createElement("style");
  r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e))
}
nj(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);

function $l(e) {
  return e.label !== void 0
}
var rj = 3,
  sj = "32px",
  ij = "16px",
  cv = 4e3,
  oj = 356,
  aj = 14,
  lj = 20,
  cj = 200;

function Jt(...e) {
  return e.filter(Boolean).join(" ")
}

function uj(e) {
  let [t, n] = e.split("-"), r = [];
  return t && r.push(t), n && r.push(n), r
}
var dj = e => {
  var t, n, r, s, i, o, a, l, c, u, d;
  let {
      invert: h,
      toast: f,
      unstyled: x,
      interacting: m,
      setHeights: b,
      visibleToasts: v,
      heights: y,
      index: w,
      toasts: S,
      expanded: _,
      removeToast: E,
      defaultRichColors: T,
      closeButton: k,
      style: P,
      cancelButtonStyle: A,
      actionButtonStyle: $,
      className: I = "",
      descriptionClassName: G = "",
      duration: D,
      position: X,
      gap: B,
      loadingIcon: U,
      expandByDefault: R,
      classNames: N,
      icons: M,
      closeButtonAriaLabel: Q = "Close toast",
      pauseWhenPageIsHidden: W
  } = e, [re, ie] = j.useState(null), [Oe, Je] = j.useState(null), [ue, ei] = j.useState(!1), [sr, os] = j.useState(!1), [ir, ti] = j.useState(!1), [or, ml] = j.useState(!1), [ed, gl] = j.useState(!1), [td, jo] = j.useState(0), [ni, Mg] = j.useState(0), Oo = j.useRef(f.duration || D || cv), Lg = j.useRef(null), as = j.useRef(null), QT = w === 0, YT = w + 1 <= v, It = f.type, ri = f.dismissible !== !1, JT = f.className || "", XT = f.descriptionClassName || "", yl = j.useMemo(() => y.findIndex(J => J.toastId === f.id) || 0, [y, f.id]), ZT = j.useMemo(() => {
      var J;
      return (J = f.closeButton) != null ? J : k
  }, [f.closeButton, k]), $g = j.useMemo(() => f.duration || D || cv, [f.duration, D]), nd = j.useRef(0), si = j.useRef(0), Fg = j.useRef(0), ii = j.useRef(null), [ek, tk] = X.split("-"), Ug = j.useMemo(() => y.reduce((J, fe, xe) => xe >= yl ? J : J + fe.height, 0), [y, yl]), Vg = QN(), nk = f.invert || h, rd = It === "loading";
  si.current = j.useMemo(() => yl * B + Ug, [yl, Ug]), j.useEffect(() => {
      Oo.current = $g
  }, [$g]), j.useEffect(() => {
      ei(!0)
  }, []), j.useEffect(() => {
      let J = as.current;
      if (J) {
          let fe = J.getBoundingClientRect().height;
          return Mg(fe), b(xe => [{
              toastId: f.id,
              height: fe,
              position: f.position
          }, ...xe]), () => b(xe => xe.filter(qt => qt.toastId !== f.id))
      }
  }, [b, f.id]), j.useLayoutEffect(() => {
      if (!ue) return;
      let J = as.current,
          fe = J.style.height;
      J.style.height = "auto";
      let xe = J.getBoundingClientRect().height;
      J.style.height = fe, Mg(xe), b(qt => qt.find(Gt => Gt.toastId === f.id) ? qt.map(Gt => Gt.toastId === f.id ? {
          ...Gt,
          height: xe
      } : Gt) : [{
          toastId: f.id,
          height: xe,
          position: f.position
      }, ...qt])
  }, [ue, f.title, f.description, b, f.id]);
  let ar = j.useCallback(() => {
      os(!0), jo(si.current), b(J => J.filter(fe => fe.toastId !== f.id)), setTimeout(() => {
          E(f)
      }, cj)
  }, [f, E, b, si]);
  j.useEffect(() => {
      if (f.promise && It === "loading" || f.duration === 1 / 0 || f.type === "loading") return;
      let J;
      return _ || m || W && Vg ? (() => {
          if (Fg.current < nd.current) {
              let fe = new Date().getTime() - nd.current;
              Oo.current = Oo.current - fe
          }
          Fg.current = new Date().getTime()
      })() : Oo.current !== 1 / 0 && (nd.current = new Date().getTime(), J = setTimeout(() => {
          var fe;
          (fe = f.onAutoClose) == null || fe.call(f, f), ar()
      }, Oo.current)), () => clearTimeout(J)
  }, [_, m, f, It, W, Vg, ar]), j.useEffect(() => {
      f.delete && ar()
  }, [ar, f.delete]);

  function rk() {
      var J, fe, xe;
      return M != null && M.loading ? j.createElement("div", {
          className: Jt(N == null ? void 0 : N.loader, (J = f == null ? void 0 : f.classNames) == null ? void 0 : J.loader, "sonner-loader"),
          "data-visible": It === "loading"
      }, M.loading) : U ? j.createElement("div", {
          className: Jt(N == null ? void 0 : N.loader, (fe = f == null ? void 0 : f.classNames) == null ? void 0 : fe.loader, "sonner-loader"),
          "data-visible": It === "loading"
      }, U) : j.createElement(zN, {
          className: Jt(N == null ? void 0 : N.loader, (xe = f == null ? void 0 : f.classNames) == null ? void 0 : xe.loader),
          visible: It === "loading"
      })
  }
  return j.createElement("li", {
      tabIndex: 0,
      ref: as,
      className: Jt(I, JT, N == null ? void 0 : N.toast, (t = f == null ? void 0 : f.classNames) == null ? void 0 : t.toast, N == null ? void 0 : N.default, N == null ? void 0 : N[It], (n = f == null ? void 0 : f.classNames) == null ? void 0 : n[It]),
      "data-sonner-toast": "",
      "data-rich-colors": (r = f.richColors) != null ? r : T,
      "data-styled": !(f.jsx || f.unstyled || x),
      "data-mounted": ue,
      "data-promise": !!f.promise,
      "data-swiped": ed,
      "data-removed": sr,
      "data-visible": YT,
      "data-y-position": ek,
      "data-x-position": tk,
      "data-index": w,
      "data-front": QT,
      "data-swiping": ir,
      "data-dismissible": ri,
      "data-type": It,
      "data-invert": nk,
      "data-swipe-out": or,
      "data-swipe-direction": Oe,
      "data-expanded": !!(_ || R && ue),
      style: {
          "--index": w,
          "--toasts-before": w,
          "--z-index": S.length - w,
          "--offset": `${sr ? td : si.current}px`,
          "--initial-height": R ? "auto" : `${ni}px`,
          ...P,
          ...f.style
      },
      onDragEnd: () => {
          ti(!1), ie(null), ii.current = null
      },
      onPointerDown: J => {
          rd || !ri || (Lg.current = new Date, jo(si.current), J.target.setPointerCapture(J.pointerId), J.target.tagName !== "BUTTON" && (ti(!0), ii.current = {
              x: J.clientX,
              y: J.clientY
          }))
      },
      onPointerUp: () => {
          var J, fe, xe, qt;
          if (or || !ri) return;
          ii.current = null;
          let Gt = Number(((J = as.current) == null ? void 0 : J.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0),
              lr = Number(((fe = as.current) == null ? void 0 : fe.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0),
              ls = new Date().getTime() - ((xe = Lg.current) == null ? void 0 : xe.getTime()),
              Qt = re === "x" ? Gt : lr,
              cr = Math.abs(Qt) / ls;
          if (Math.abs(Qt) >= lj || cr > .11) {
              jo(si.current), (qt = f.onDismiss) == null || qt.call(f, f), Je(re === "x" ? Gt > 0 ? "right" : "left" : lr > 0 ? "down" : "up"), ar(), ml(!0), gl(!1);
              return
          }
          ti(!1), ie(null)
      },
      onPointerMove: J => {
          var fe, xe, qt, Gt;
          if (!ii.current || !ri || ((fe = window.getSelection()) == null ? void 0 : fe.toString().length) > 0) return;
          let lr = J.clientY - ii.current.y,
              ls = J.clientX - ii.current.x,
              Qt = (xe = e.swipeDirections) != null ? xe : uj(X);
          !re && (Math.abs(ls) > 1 || Math.abs(lr) > 1) && ie(Math.abs(ls) > Math.abs(lr) ? "x" : "y");
          let cr = {
              x: 0,
              y: 0
          };
          re === "y" ? (Qt.includes("top") || Qt.includes("bottom")) && (Qt.includes("top") && lr < 0 || Qt.includes("bottom") && lr > 0) && (cr.y = lr) : re === "x" && (Qt.includes("left") || Qt.includes("right")) && (Qt.includes("left") && ls < 0 || Qt.includes("right") && ls > 0) && (cr.x = ls), (Math.abs(cr.x) > 0 || Math.abs(cr.y) > 0) && gl(!0), (qt = as.current) == null || qt.style.setProperty("--swipe-amount-x", `${cr.x}px`), (Gt = as.current) == null || Gt.style.setProperty("--swipe-amount-y", `${cr.y}px`)
      }
  }, ZT && !f.jsx ? j.createElement("button", {
      "aria-label": Q,
      "data-disabled": rd,
      "data-close-button": !0,
      onClick: rd || !ri ? () => {} : () => {
          var J;
          ar(), (J = f.onDismiss) == null || J.call(f, f)
      },
      className: Jt(N == null ? void 0 : N.closeButton, (s = f == null ? void 0 : f.classNames) == null ? void 0 : s.closeButton)
  }, (i = M == null ? void 0 : M.close) != null ? i : GN) : null, f.jsx || g.isValidElement(f.title) ? f.jsx ? f.jsx : typeof f.title == "function" ? f.title() : f.title : j.createElement(j.Fragment, null, It || f.icon || f.promise ? j.createElement("div", {
      "data-icon": "",
      className: Jt(N == null ? void 0 : N.icon, (o = f == null ? void 0 : f.classNames) == null ? void 0 : o.icon)
  }, f.promise || f.type === "loading" && !f.icon ? f.icon || rk() : null, f.type !== "loading" ? f.icon || (M == null ? void 0 : M[It]) || VN(It) : null) : null, j.createElement("div", {
      "data-content": "",
      className: Jt(N == null ? void 0 : N.content, (a = f == null ? void 0 : f.classNames) == null ? void 0 : a.content)
  }, j.createElement("div", {
      "data-title": "",
      className: Jt(N == null ? void 0 : N.title, (l = f == null ? void 0 : f.classNames) == null ? void 0 : l.title)
  }, typeof f.title == "function" ? f.title() : f.title), f.description ? j.createElement("div", {
      "data-description": "",
      className: Jt(G, XT, N == null ? void 0 : N.description, (c = f == null ? void 0 : f.classNames) == null ? void 0 : c.description)
  }, typeof f.description == "function" ? f.description() : f.description) : null), g.isValidElement(f.cancel) ? f.cancel : f.cancel && $l(f.cancel) ? j.createElement("button", {
      "data-button": !0,
      "data-cancel": !0,
      style: f.cancelButtonStyle || A,
      onClick: J => {
          var fe, xe;
          $l(f.cancel) && ri && ((xe = (fe = f.cancel).onClick) == null || xe.call(fe, J), ar())
      },
      className: Jt(N == null ? void 0 : N.cancelButton, (u = f == null ? void 0 : f.classNames) == null ? void 0 : u.cancelButton)
  }, f.cancel.label) : null, g.isValidElement(f.action) ? f.action : f.action && $l(f.action) ? j.createElement("button", {
      "data-button": !0,
      "data-action": !0,
      style: f.actionButtonStyle || $,
      onClick: J => {
          var fe, xe;
          $l(f.action) && ((xe = (fe = f.action).onClick) == null || xe.call(fe, J), !J.defaultPrevented && ar())
      },
      className: Jt(N == null ? void 0 : N.actionButton, (d = f == null ? void 0 : f.classNames) == null ? void 0 : d.actionButton)
  }, f.action.label) : null))
};

function uv() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  let e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e
}

function hj(e, t) {
  let n = {};
  return [e, t].forEach((r, s) => {
      let i = s === 1,
          o = i ? "--mobile-offset" : "--offset",
          a = i ? ij : sj;

      function l(c) {
          ["top", "right", "bottom", "left"].forEach(u => {
              n[`${o}-${u}`] = typeof c == "number" ? `${c}px` : c
          })
      }
      typeof r == "number" || typeof r == "string" ? l(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(c => {
          r[c] === void 0 ? n[`${o}-${c}`] = a : n[`${o}-${c}`] = typeof r[c] == "number" ? `${r[c]}px` : r[c]
      }) : l(a)
  }), n
}
var fj = g.forwardRef(function(e, t) {
  let {
      invert: n,
      position: r = "bottom-right",
      hotkey: s = ["altKey", "KeyT"],
      expand: i,
      closeButton: o,
      className: a,
      offset: l,
      mobileOffset: c,
      theme: u = "light",
      richColors: d,
      duration: h,
      style: f,
      visibleToasts: x = rj,
      toastOptions: m,
      dir: b = uv(),
      gap: v = aj,
      loadingIcon: y,
      icons: w,
      containerAriaLabel: S = "Notifications",
      pauseWhenPageIsHidden: _
  } = e, [E, T] = j.useState([]), k = j.useMemo(() => Array.from(new Set([r].concat(E.filter(W => W.position).map(W => W.position)))), [E, r]), [P, A] = j.useState([]), [$, I] = j.useState(!1), [G, D] = j.useState(!1), [X, B] = j.useState(u !== "system" ? u : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), U = j.useRef(null), R = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), N = j.useRef(null), M = j.useRef(!1), Q = j.useCallback(W => {
      T(re => {
          var ie;
          return (ie = re.find(Oe => Oe.id === W.id)) != null && ie.delete || mt.dismiss(W.id), re.filter(({
              id: Oe
          }) => Oe !== W.id)
      })
  }, []);
  return j.useEffect(() => mt.subscribe(W => {
      if (W.dismiss) {
          T(re => re.map(ie => ie.id === W.id ? {
              ...ie,
              delete: !0
          } : ie));
          return
      }
      setTimeout(() => {
          i1.flushSync(() => {
              T(re => {
                  let ie = re.findIndex(Oe => Oe.id === W.id);
                  return ie !== -1 ? [...re.slice(0, ie), {
                      ...re[ie],
                      ...W
                  }, ...re.slice(ie + 1)] : [W, ...re]
              })
          })
      })
  }), []), j.useEffect(() => {
      if (u !== "system") {
          B(u);
          return
      }
      if (u === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? B("dark") : B("light")), typeof window > "u") return;
      let W = window.matchMedia("(prefers-color-scheme: dark)");
      try {
          W.addEventListener("change", ({
              matches: re
          }) => {
              B(re ? "dark" : "light")
          })
      } catch {
          W.addListener(({
              matches: ie
          }) => {
              try {
                  B(ie ? "dark" : "light")
              } catch (Oe) {
                  console.error(Oe)
              }
          })
      }
  }, [u]), j.useEffect(() => {
      E.length <= 1 && I(!1)
  }, [E]), j.useEffect(() => {
      let W = re => {
          var ie, Oe;
          s.every(Je => re[Je] || re.code === Je) && (I(!0), (ie = U.current) == null || ie.focus()), re.code === "Escape" && (document.activeElement === U.current || (Oe = U.current) != null && Oe.contains(document.activeElement)) && I(!1)
      };
      return document.addEventListener("keydown", W), () => document.removeEventListener("keydown", W)
  }, [s]), j.useEffect(() => {
      if (U.current) return () => {
          N.current && (N.current.focus({
              preventScroll: !0
          }), N.current = null, M.current = !1)
      }
  }, [U.current]), j.createElement("section", {
      ref: t,
      "aria-label": `${S} ${R}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false",
      suppressHydrationWarning: !0
  }, k.map((W, re) => {
      var ie;
      let [Oe, Je] = W.split("-");
      return E.length ? j.createElement("ol", {
          key: W,
          dir: b === "auto" ? uv() : b,
          tabIndex: -1,
          ref: U,
          className: a,
          "data-sonner-toaster": !0,
          "data-theme": X,
          "data-y-position": Oe,
          "data-lifted": $ && E.length > 1 && !i,
          "data-x-position": Je,
          style: {
              "--front-toast-height": `${((ie = P[0]) == null ? void 0 : ie.height) || 0}px`,
              "--width": `${oj}px`,
              "--gap": `${v}px`,
              ...f,
              ...hj(l, c)
          },
          onBlur: ue => {
              M.current && !ue.currentTarget.contains(ue.relatedTarget) && (M.current = !1, N.current && (N.current.focus({
                  preventScroll: !0
              }), N.current = null))
          },
          onFocus: ue => {
              ue.target instanceof HTMLElement && ue.target.dataset.dismissible === "false" || M.current || (M.current = !0, N.current = ue.relatedTarget)
          },
          onMouseEnter: () => I(!0),
          onMouseMove: () => I(!0),
          onMouseLeave: () => {
              G || I(!1)
          },
          onDragEnd: () => I(!1),
          onPointerDown: ue => {
              ue.target instanceof HTMLElement && ue.target.dataset.dismissible === "false" || D(!0)
          },
          onPointerUp: () => D(!1)
      }, E.filter(ue => !ue.position && re === 0 || ue.position === W).map((ue, ei) => {
          var sr, os;
          return j.createElement(dj, {
              key: ue.id,
              icons: w,
              index: ei,
              toast: ue,
              defaultRichColors: d,
              duration: (sr = m == null ? void 0 : m.duration) != null ? sr : h,
              className: m == null ? void 0 : m.className,
              descriptionClassName: m == null ? void 0 : m.descriptionClassName,
              invert: n,
              visibleToasts: x,
              closeButton: (os = m == null ? void 0 : m.closeButton) != null ? os : o,
              interacting: G,
              position: W,
              style: m == null ? void 0 : m.style,
              unstyled: m == null ? void 0 : m.unstyled,
              classNames: m == null ? void 0 : m.classNames,
              cancelButtonStyle: m == null ? void 0 : m.cancelButtonStyle,
              actionButtonStyle: m == null ? void 0 : m.actionButtonStyle,
              removeToast: Q,
              toasts: E.filter(ir => ir.position == ue.position),
              heights: P.filter(ir => ir.position == ue.position),
              setHeights: A,
              expandByDefault: i,
              gap: v,
              loadingIcon: y,
              expanded: $,
              pauseWhenPageIsHidden: _,
              swipeDirections: e.swipeDirections
          })
      })) : null
  }))
});
const pj = ({
  ...e
}) => {
  const {
      theme: t = "system"
  } = UN();
  return p.jsx(fj, {
      theme: t,
      className: "toaster group",
      toastOptions: {
          classNames: {
              toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
              description: "group-[.toast]:text-muted-foreground",
              actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
              cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
          }
      },
      ...e
  })
};
var mj = Cp[" useId ".trim().toString()] || (() => {}),
  gj = 0;

function Wi(e) {
  const [t, n] = g.useState(mj());
  return jn(() => {
      n(r => r ?? String(gj++))
  }, [e]), t ? `radix-${t}` : ""
}
const yj = ["top", "right", "bottom", "left"],
  Jr = Math.min,
  Ct = Math.max,
  Kc = Math.round,
  Fl = Math.floor,
  Rn = e => ({
      x: e,
      y: e
  }),
  vj = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
  },
  wj = {
      start: "end",
      end: "start"
  };

function gf(e, t, n) {
  return Ct(e, Jr(t, n))
}

function Yn(e, t) {
  return typeof e == "function" ? e(t) : e
}

function Jn(e) {
  return e.split("-")[0]
}

function Eo(e) {
  return e.split("-")[1]
}

function _m(e) {
  return e === "x" ? "y" : "x"
}

function Em(e) {
  return e === "y" ? "height" : "width"
}
const xj = new Set(["top", "bottom"]);

function Cn(e) {
  return xj.has(Jn(e)) ? "y" : "x"
}

function Cm(e) {
  return _m(Cn(e))
}

function bj(e, t, n) {
  n === void 0 && (n = !1);
  const r = Eo(e),
      s = Cm(e),
      i = Em(s);
  let o = s === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (o = qc(o)), [o, qc(o)]
}

function Sj(e) {
  const t = qc(e);
  return [yf(e), t, yf(t)]
}

function yf(e) {
  return e.replace(/start|end/g, t => wj[t])
}
const dv = ["left", "right"],
  hv = ["right", "left"],
  _j = ["top", "bottom"],
  Ej = ["bottom", "top"];

function Cj(e, t, n) {
  switch (e) {
      case "top":
      case "bottom":
          return n ? t ? hv : dv : t ? dv : hv;
      case "left":
      case "right":
          return t ? _j : Ej;
      default:
          return []
  }
}

function Tj(e, t, n, r) {
  const s = Eo(e);
  let i = Cj(Jn(e), n === "start", r);
  return s && (i = i.map(o => o + "-" + s), t && (i = i.concat(i.map(yf)))), i
}

function qc(e) {
  return e.replace(/left|right|bottom|top/g, t => vj[t])
}

function kj(e) {
  return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
  }
}

function G1(e) {
  return typeof e != "number" ? kj(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
  }
}

function Gc(e) {
  const {
      x: t,
      y: n,
      width: r,
      height: s
  } = e;
  return {
      width: r,
      height: s,
      top: n,
      left: t,
      right: t + r,
      bottom: n + s,
      x: t,
      y: n
  }
}

function fv(e, t, n) {
  let {
      reference: r,
      floating: s
  } = e;
  const i = Cn(t),
      o = Cm(t),
      a = Em(o),
      l = Jn(t),
      c = i === "y",
      u = r.x + r.width / 2 - s.width / 2,
      d = r.y + r.height / 2 - s.height / 2,
      h = r[a] / 2 - s[a] / 2;
  let f;
  switch (l) {
      case "top":
          f = {
              x: u,
              y: r.y - s.height
          };
          break;
      case "bottom":
          f = {
              x: u,
              y: r.y + r.height
          };
          break;
      case "right":
          f = {
              x: r.x + r.width,
              y: d
          };
          break;
      case "left":
          f = {
              x: r.x - s.width,
              y: d
          };
          break;
      default:
          f = {
              x: r.x,
              y: r.y
          }
  }
  switch (Eo(t)) {
      case "start":
          f[o] -= h * (n && c ? -1 : 1);
          break;
      case "end":
          f[o] += h * (n && c ? -1 : 1);
          break
  }
  return f
}
const Rj = async (e, t, n) => {
  const {
      placement: r = "bottom",
      strategy: s = "absolute",
      middleware: i = [],
      platform: o
  } = n, a = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
          reference: e,
          floating: t,
          strategy: s
      }),
      {
          x: u,
          y: d
      } = fv(c, r, l),
      h = r,
      f = {},
      x = 0;
  for (let m = 0; m < a.length; m++) {
      const {
          name: b,
          fn: v
      } = a[m], {
          x: y,
          y: w,
          data: S,
          reset: _
      } = await v({
          x: u,
          y: d,
          initialPlacement: r,
          placement: h,
          strategy: s,
          middlewareData: f,
          rects: c,
          platform: o,
          elements: {
              reference: e,
              floating: t
          }
      });
      u = y ?? u, d = w ?? d, f = {
          ...f,
          [b]: {
              ...f[b],
              ...S
          }
      }, _ && x <= 50 && (x++, typeof _ == "object" && (_.placement && (h = _.placement), _.rects && (c = _.rects === !0 ? await o.getElementRects({
          reference: e,
          floating: t,
          strategy: s
      }) : _.rects), {
          x: u,
          y: d
      } = fv(c, h, l)), m = -1)
  }
  return {
      x: u,
      y: d,
      placement: h,
      strategy: s,
      middlewareData: f
  }
};
async function Oa(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
      x: r,
      y: s,
      platform: i,
      rects: o,
      elements: a,
      strategy: l
  } = e, {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: h = !1,
      padding: f = 0
  } = Yn(t, e), x = G1(f), b = a[h ? d === "floating" ? "reference" : "floating" : d], v = Gc(await i.getClippingRect({
      element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
      boundary: c,
      rootBoundary: u,
      strategy: l
  })), y = d === "floating" ? {
      x: r,
      y: s,
      width: o.floating.width,
      height: o.floating.height
  } : o.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), S = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
      x: 1,
      y: 1
  } : {
      x: 1,
      y: 1
  }, _ = Gc(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: a,
      rect: y,
      offsetParent: w,
      strategy: l
  }) : y);
  return {
      top: (v.top - _.top + x.top) / S.y,
      bottom: (_.bottom - v.bottom + x.bottom) / S.y,
      left: (v.left - _.left + x.left) / S.x,
      right: (_.right - v.right + x.right) / S.x
  }
}
const Pj = e => ({
      name: "arrow",
      options: e,
      async fn(t) {
          const {
              x: n,
              y: r,
              placement: s,
              rects: i,
              platform: o,
              elements: a,
              middlewareData: l
          } = t, {
              element: c,
              padding: u = 0
          } = Yn(e, t) || {};
          if (c == null) return {};
          const d = G1(u),
              h = {
                  x: n,
                  y: r
              },
              f = Cm(s),
              x = Em(f),
              m = await o.getDimensions(c),
              b = f === "y",
              v = b ? "top" : "left",
              y = b ? "bottom" : "right",
              w = b ? "clientHeight" : "clientWidth",
              S = i.reference[x] + i.reference[f] - h[f] - i.floating[x],
              _ = h[f] - i.reference[f],
              E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
          let T = E ? E[w] : 0;
          (!T || !await (o.isElement == null ? void 0 : o.isElement(E))) && (T = a.floating[w] || i.floating[x]);
          const k = S / 2 - _ / 2,
              P = T / 2 - m[x] / 2 - 1,
              A = Jr(d[v], P),
              $ = Jr(d[y], P),
              I = A,
              G = T - m[x] - $,
              D = T / 2 - m[x] / 2 + k,
              X = gf(I, D, G),
              B = !l.arrow && Eo(s) != null && D !== X && i.reference[x] / 2 - (D < I ? A : $) - m[x] / 2 < 0,
              U = B ? D < I ? D - I : D - G : 0;
          return {
              [f]: h[f] + U,
              data: {
                  [f]: X,
                  centerOffset: D - X - U,
                  ...B && {
                      alignmentOffset: U
                  }
              },
              reset: B
          }
      }
  }),
  Aj = function(e) {
      return e === void 0 && (e = {}), {
          name: "flip",
          options: e,
          async fn(t) {
              var n, r;
              const {
                  placement: s,
                  middlewareData: i,
                  rects: o,
                  initialPlacement: a,
                  platform: l,
                  elements: c
              } = t, {
                  mainAxis: u = !0,
                  crossAxis: d = !0,
                  fallbackPlacements: h,
                  fallbackStrategy: f = "bestFit",
                  fallbackAxisSideDirection: x = "none",
                  flipAlignment: m = !0,
                  ...b
              } = Yn(e, t);
              if ((n = i.arrow) != null && n.alignmentOffset) return {};
              const v = Jn(s),
                  y = Cn(a),
                  w = Jn(a) === a,
                  S = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
                  _ = h || (w || !m ? [qc(a)] : Sj(a)),
                  E = x !== "none";
              !h && E && _.push(...Tj(a, m, x, S));
              const T = [a, ..._],
                  k = await Oa(t, b),
                  P = [];
              let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
              if (u && P.push(k[v]), d) {
                  const D = bj(s, o, S);
                  P.push(k[D[0]], k[D[1]])
              }
              if (A = [...A, {
                      placement: s,
                      overflows: P
                  }], !P.every(D => D <= 0)) {
                  var $, I;
                  const D = ((($ = i.flip) == null ? void 0 : $.index) || 0) + 1,
                      X = T[D];
                  if (X && (!(d === "alignment" ? y !== Cn(X) : !1) || A.every(R => R.overflows[0] > 0 && Cn(R.placement) === y))) return {
                      data: {
                          index: D,
                          overflows: A
                      },
                      reset: {
                          placement: X
                      }
                  };
                  let B = (I = A.filter(U => U.overflows[0] <= 0).sort((U, R) => U.overflows[1] - R.overflows[1])[0]) == null ? void 0 : I.placement;
                  if (!B) switch (f) {
                      case "bestFit": {
                          var G;
                          const U = (G = A.filter(R => {
                              if (E) {
                                  const N = Cn(R.placement);
                                  return N === y || N === "y"
                              }
                              return !0
                          }).map(R => [R.placement, R.overflows.filter(N => N > 0).reduce((N, M) => N + M, 0)]).sort((R, N) => R[1] - N[1])[0]) == null ? void 0 : G[0];
                          U && (B = U);
                          break
                      }
                      case "initialPlacement":
                          B = a;
                          break
                  }
                  if (s !== B) return {
                      reset: {
                          placement: B
                      }
                  }
              }
              return {}
          }
      }
  };

function pv(e, t) {
  return {
      top: e.top - t.height,
      right: e.right - t.width,
      bottom: e.bottom - t.height,
      left: e.left - t.width
  }
}

function mv(e) {
  return yj.some(t => e[t] >= 0)
}
const Nj = function(e) {
      return e === void 0 && (e = {}), {
          name: "hide",
          options: e,
          async fn(t) {
              const {
                  rects: n
              } = t, {
                  strategy: r = "referenceHidden",
                  ...s
              } = Yn(e, t);
              switch (r) {
                  case "referenceHidden": {
                      const i = await Oa(t, {
                              ...s,
                              elementContext: "reference"
                          }),
                          o = pv(i, n.reference);
                      return {
                          data: {
                              referenceHiddenOffsets: o,
                              referenceHidden: mv(o)
                          }
                      }
                  }
                  case "escaped": {
                      const i = await Oa(t, {
                              ...s,
                              altBoundary: !0
                          }),
                          o = pv(i, n.floating);
                      return {
                          data: {
                              escapedOffsets: o,
                              escaped: mv(o)
                          }
                      }
                  }
                  default:
                      return {}
              }
          }
      }
  },
  Q1 = new Set(["left", "top"]);
async function jj(e, t) {
  const {
      placement: n,
      platform: r,
      elements: s
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(s.floating)), o = Jn(n), a = Eo(n), l = Cn(n) === "y", c = Q1.has(o) ? -1 : 1, u = i && l ? -1 : 1, d = Yn(t, e);
  let {
      mainAxis: h,
      crossAxis: f,
      alignmentAxis: x
  } = typeof d == "number" ? {
      mainAxis: d,
      crossAxis: 0,
      alignmentAxis: null
  } : {
      mainAxis: d.mainAxis || 0,
      crossAxis: d.crossAxis || 0,
      alignmentAxis: d.alignmentAxis
  };
  return a && typeof x == "number" && (f = a === "end" ? x * -1 : x), l ? {
      x: f * u,
      y: h * c
  } : {
      x: h * c,
      y: f * u
  }
}
const Oj = function(e) {
      return e === void 0 && (e = 0), {
          name: "offset",
          options: e,
          async fn(t) {
              var n, r;
              const {
                  x: s,
                  y: i,
                  placement: o,
                  middlewareData: a
              } = t, l = await jj(t, e);
              return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
                  x: s + l.x,
                  y: i + l.y,
                  data: {
                      ...l,
                      placement: o
                  }
              }
          }
      }
  },
  Ij = function(e) {
      return e === void 0 && (e = {}), {
          name: "shift",
          options: e,
          async fn(t) {
              const {
                  x: n,
                  y: r,
                  placement: s
              } = t, {
                  mainAxis: i = !0,
                  crossAxis: o = !1,
                  limiter: a = {
                      fn: b => {
                          let {
                              x: v,
                              y
                          } = b;
                          return {
                              x: v,
                              y
                          }
                      }
                  },
                  ...l
              } = Yn(e, t), c = {
                  x: n,
                  y: r
              }, u = await Oa(t, l), d = Cn(Jn(s)), h = _m(d);
              let f = c[h],
                  x = c[d];
              if (i) {
                  const b = h === "y" ? "top" : "left",
                      v = h === "y" ? "bottom" : "right",
                      y = f + u[b],
                      w = f - u[v];
                  f = gf(y, f, w)
              }
              if (o) {
                  const b = d === "y" ? "top" : "left",
                      v = d === "y" ? "bottom" : "right",
                      y = x + u[b],
                      w = x - u[v];
                  x = gf(y, x, w)
              }
              const m = a.fn({
                  ...t,
                  [h]: f,
                  [d]: x
              });
              return {
                  ...m,
                  data: {
                      x: m.x - n,
                      y: m.y - r,
                      enabled: {
                          [h]: i,
                          [d]: o
                      }
                  }
              }
          }
      }
  },
  Dj = function(e) {
      return e === void 0 && (e = {}), {
          options: e,
          fn(t) {
              const {
                  x: n,
                  y: r,
                  placement: s,
                  rects: i,
                  middlewareData: o
              } = t, {
                  offset: a = 0,
                  mainAxis: l = !0,
                  crossAxis: c = !0
              } = Yn(e, t), u = {
                  x: n,
                  y: r
              }, d = Cn(s), h = _m(d);
              let f = u[h],
                  x = u[d];
              const m = Yn(a, t),
                  b = typeof m == "number" ? {
                      mainAxis: m,
                      crossAxis: 0
                  } : {
                      mainAxis: 0,
                      crossAxis: 0,
                      ...m
                  };
              if (l) {
                  const w = h === "y" ? "height" : "width",
                      S = i.reference[h] - i.floating[w] + b.mainAxis,
                      _ = i.reference[h] + i.reference[w] - b.mainAxis;
                  f < S ? f = S : f > _ && (f = _)
              }
              if (c) {
                  var v, y;
                  const w = h === "y" ? "width" : "height",
                      S = Q1.has(Jn(s)),
                      _ = i.reference[d] - i.floating[w] + (S && ((v = o.offset) == null ? void 0 : v[d]) || 0) + (S ? 0 : b.crossAxis),
                      E = i.reference[d] + i.reference[w] + (S ? 0 : ((y = o.offset) == null ? void 0 : y[d]) || 0) - (S ? b.crossAxis : 0);
                  x < _ ? x = _ : x > E && (x = E)
              }
              return {
                  [h]: f,
                  [d]: x
              }
          }
      }
  },
  Mj = function(e) {
      return e === void 0 && (e = {}), {
          name: "size",
          options: e,
          async fn(t) {
              var n, r;
              const {
                  placement: s,
                  rects: i,
                  platform: o,
                  elements: a
              } = t, {
                  apply: l = () => {},
                  ...c
              } = Yn(e, t), u = await Oa(t, c), d = Jn(s), h = Eo(s), f = Cn(s) === "y", {
                  width: x,
                  height: m
              } = i.floating;
              let b, v;
              d === "top" || d === "bottom" ? (b = d, v = h === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (v = d, b = h === "end" ? "top" : "bottom");
              const y = m - u.top - u.bottom,
                  w = x - u.left - u.right,
                  S = Jr(m - u[b], y),
                  _ = Jr(x - u[v], w),
                  E = !t.middlewareData.shift;
              let T = S,
                  k = _;
              if ((n = t.middlewareData.shift) != null && n.enabled.x && (k = w), (r = t.middlewareData.shift) != null && r.enabled.y && (T = y), E && !h) {
                  const A = Ct(u.left, 0),
                      $ = Ct(u.right, 0),
                      I = Ct(u.top, 0),
                      G = Ct(u.bottom, 0);
                  f ? k = x - 2 * (A !== 0 || $ !== 0 ? A + $ : Ct(u.left, u.right)) : T = m - 2 * (I !== 0 || G !== 0 ? I + G : Ct(u.top, u.bottom))
              }
              await l({
                  ...t,
                  availableWidth: k,
                  availableHeight: T
              });
              const P = await o.getDimensions(a.floating);
              return x !== P.width || m !== P.height ? {
                  reset: {
                      rects: !0
                  }
              } : {}
          }
      }
  };

function Ou() {
  return typeof window < "u"
}

function Co(e) {
  return Y1(e) ? (e.nodeName || "").toLowerCase() : "#document"
}

function At(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}

function In(e) {
  var t;
  return (t = (Y1(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement
}

function Y1(e) {
  return Ou() ? e instanceof Node || e instanceof At(e).Node : !1
}

function pn(e) {
  return Ou() ? e instanceof Element || e instanceof At(e).Element : !1
}

function On(e) {
  return Ou() ? e instanceof HTMLElement || e instanceof At(e).HTMLElement : !1
}

function gv(e) {
  return !Ou() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof At(e).ShadowRoot
}
const Lj = new Set(["inline", "contents"]);

function ol(e) {
  const {
      overflow: t,
      overflowX: n,
      overflowY: r,
      display: s
  } = mn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Lj.has(s)
}
const $j = new Set(["table", "td", "th"]);

function Fj(e) {
  return $j.has(Co(e))
}
const Uj = [":popover-open", ":modal"];

function Iu(e) {
  return Uj.some(t => {
      try {
          return e.matches(t)
      } catch {
          return !1
      }
  })
}
const Vj = ["transform", "translate", "scale", "rotate", "perspective"],
  Bj = ["transform", "translate", "scale", "rotate", "perspective", "filter"],
  zj = ["paint", "layout", "strict", "content"];

function Tm(e) {
  const t = km(),
      n = pn(e) ? mn(e) : e;
  return Vj.some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Bj.some(r => (n.willChange || "").includes(r)) || zj.some(r => (n.contain || "").includes(r))
}

function Wj(e) {
  let t = Xr(e);
  for (; On(t) && !go(t);) {
      if (Tm(t)) return t;
      if (Iu(t)) return null;
      t = Xr(t)
  }
  return null
}

function km() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
const Hj = new Set(["html", "body", "#document"]);

function go(e) {
  return Hj.has(Co(e))
}

function mn(e) {
  return At(e).getComputedStyle(e)
}

function Du(e) {
  return pn(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
  } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
  }
}

function Xr(e) {
  if (Co(e) === "html") return e;
  const t = e.assignedSlot || e.parentNode || gv(e) && e.host || In(e);
  return gv(t) ? t.host : t
}

function J1(e) {
  const t = Xr(e);
  return go(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : On(t) && ol(t) ? t : J1(t)
}

function Ia(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const s = J1(e),
      i = s === ((r = e.ownerDocument) == null ? void 0 : r.body),
      o = At(s);
  if (i) {
      const a = vf(o);
      return t.concat(o, o.visualViewport || [], ol(s) ? s : [], a && n ? Ia(a) : [])
  }
  return t.concat(s, Ia(s, [], n))
}

function vf(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null
}

function X1(e) {
  const t = mn(e);
  let n = parseFloat(t.width) || 0,
      r = parseFloat(t.height) || 0;
  const s = On(e),
      i = s ? e.offsetWidth : n,
      o = s ? e.offsetHeight : r,
      a = Kc(n) !== i || Kc(r) !== o;
  return a && (n = i, r = o), {
      width: n,
      height: r,
      $: a
  }
}

function Rm(e) {
  return pn(e) ? e : e.contextElement
}

function Hi(e) {
  const t = Rm(e);
  if (!On(t)) return Rn(1);
  const n = t.getBoundingClientRect(),
      {
          width: r,
          height: s,
          $: i
      } = X1(t);
  let o = (i ? Kc(n.width) : n.width) / r,
      a = (i ? Kc(n.height) : n.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
      x: o,
      y: a
  }
}
const Kj = Rn(0);

function Z1(e) {
  const t = At(e);
  return !km() || !t.visualViewport ? Kj : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
  }
}

function qj(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== At(e) ? !1 : t
}

function Ks(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const s = e.getBoundingClientRect(),
      i = Rm(e);
  let o = Rn(1);
  t && (r ? pn(r) && (o = Hi(r)) : o = Hi(e));
  const a = qj(i, n, r) ? Z1(i) : Rn(0);
  let l = (s.left + a.x) / o.x,
      c = (s.top + a.y) / o.y,
      u = s.width / o.x,
      d = s.height / o.y;
  if (i) {
      const h = At(i),
          f = r && pn(r) ? At(r) : r;
      let x = h,
          m = vf(x);
      for (; m && r && f !== x;) {
          const b = Hi(m),
              v = m.getBoundingClientRect(),
              y = mn(m),
              w = v.left + (m.clientLeft + parseFloat(y.paddingLeft)) * b.x,
              S = v.top + (m.clientTop + parseFloat(y.paddingTop)) * b.y;
          l *= b.x, c *= b.y, u *= b.x, d *= b.y, l += w, c += S, x = At(m), m = vf(x)
      }
  }
  return Gc({
      width: u,
      height: d,
      x: l,
      y: c
  })
}

function Pm(e, t) {
  const n = Du(e).scrollLeft;
  return t ? t.left + n : Ks(In(e)).left + n
}

function eS(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(),
      s = r.left + t.scrollLeft - (n ? 0 : Pm(e, r)),
      i = r.top + t.scrollTop;
  return {
      x: s,
      y: i
  }
}

function Gj(e) {
  let {
      elements: t,
      rect: n,
      offsetParent: r,
      strategy: s
  } = e;
  const i = s === "fixed",
      o = In(r),
      a = t ? Iu(t.floating) : !1;
  if (r === o || a && i) return n;
  let l = {
          scrollLeft: 0,
          scrollTop: 0
      },
      c = Rn(1);
  const u = Rn(0),
      d = On(r);
  if ((d || !d && !i) && ((Co(r) !== "body" || ol(o)) && (l = Du(r)), On(r))) {
      const f = Ks(r);
      c = Hi(r), u.x = f.x + r.clientLeft, u.y = f.y + r.clientTop
  }
  const h = o && !d && !i ? eS(o, l, !0) : Rn(0);
  return {
      width: n.width * c.x,
      height: n.height * c.y,
      x: n.x * c.x - l.scrollLeft * c.x + u.x + h.x,
      y: n.y * c.y - l.scrollTop * c.y + u.y + h.y
  }
}

function Qj(e) {
  return Array.from(e.getClientRects())
}

function Yj(e) {
  const t = In(e),
      n = Du(e),
      r = e.ownerDocument.body,
      s = Ct(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
      i = Ct(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + Pm(e);
  const a = -n.scrollTop;
  return mn(r).direction === "rtl" && (o += Ct(t.clientWidth, r.clientWidth) - s), {
      width: s,
      height: i,
      x: o,
      y: a
  }
}

function Jj(e, t) {
  const n = At(e),
      r = In(e),
      s = n.visualViewport;
  let i = r.clientWidth,
      o = r.clientHeight,
      a = 0,
      l = 0;
  if (s) {
      i = s.width, o = s.height;
      const c = km();
      (!c || c && t === "fixed") && (a = s.offsetLeft, l = s.offsetTop)
  }
  return {
      width: i,
      height: o,
      x: a,
      y: l
  }
}
const Xj = new Set(["absolute", "fixed"]);

function Zj(e, t) {
  const n = Ks(e, !0, t === "fixed"),
      r = n.top + e.clientTop,
      s = n.left + e.clientLeft,
      i = On(e) ? Hi(e) : Rn(1),
      o = e.clientWidth * i.x,
      a = e.clientHeight * i.y,
      l = s * i.x,
      c = r * i.y;
  return {
      width: o,
      height: a,
      x: l,
      y: c
  }
}

function yv(e, t, n) {
  let r;
  if (t === "viewport") r = Jj(e, n);
  else if (t === "document") r = Yj(In(e));
  else if (pn(t)) r = Zj(t, n);
  else {
      const s = Z1(e);
      r = {
          x: t.x - s.x,
          y: t.y - s.y,
          width: t.width,
          height: t.height
      }
  }
  return Gc(r)
}

function tS(e, t) {
  const n = Xr(e);
  return n === t || !pn(n) || go(n) ? !1 : mn(n).position === "fixed" || tS(n, t)
}

function eO(e, t) {
  const n = t.get(e);
  if (n) return n;
  let r = Ia(e, [], !1).filter(a => pn(a) && Co(a) !== "body"),
      s = null;
  const i = mn(e).position === "fixed";
  let o = i ? Xr(e) : e;
  for (; pn(o) && !go(o);) {
      const a = mn(o),
          l = Tm(o);
      !l && a.position === "fixed" && (s = null), (i ? !l && !s : !l && a.position === "static" && !!s && Xj.has(s.position) || ol(o) && !l && tS(e, o)) ? r = r.filter(u => u !== o) : s = a, o = Xr(o)
  }
  return t.set(e, r), r
}

function tO(e) {
  let {
      element: t,
      boundary: n,
      rootBoundary: r,
      strategy: s
  } = e;
  const o = [...n === "clippingAncestors" ? Iu(t) ? [] : eO(t, this._c) : [].concat(n), r],
      a = o[0],
      l = o.reduce((c, u) => {
          const d = yv(t, u, s);
          return c.top = Ct(d.top, c.top), c.right = Jr(d.right, c.right), c.bottom = Jr(d.bottom, c.bottom), c.left = Ct(d.left, c.left), c
      }, yv(t, a, s));
  return {
      width: l.right - l.left,
      height: l.bottom - l.top,
      x: l.left,
      y: l.top
  }
}

function nO(e) {
  const {
      width: t,
      height: n
  } = X1(e);
  return {
      width: t,
      height: n
  }
}

function rO(e, t, n) {
  const r = On(t),
      s = In(t),
      i = n === "fixed",
      o = Ks(e, !0, i, t);
  let a = {
      scrollLeft: 0,
      scrollTop: 0
  };
  const l = Rn(0);

  function c() {
      l.x = Pm(s)
  }
  if (r || !r && !i)
      if ((Co(t) !== "body" || ol(s)) && (a = Du(t)), r) {
          const f = Ks(t, !0, i, t);
          l.x = f.x + t.clientLeft, l.y = f.y + t.clientTop
      } else s && c();
  i && !r && s && c();
  const u = s && !r && !i ? eS(s, a) : Rn(0),
      d = o.left + a.scrollLeft - l.x - u.x,
      h = o.top + a.scrollTop - l.y - u.y;
  return {
      x: d,
      y: h,
      width: o.width,
      height: o.height
  }
}

function Dd(e) {
  return mn(e).position === "static"
}

function vv(e, t) {
  if (!On(e) || mn(e).position === "fixed") return null;
  if (t) return t(e);
  let n = e.offsetParent;
  return In(e) === n && (n = n.ownerDocument.body), n
}

function nS(e, t) {
  const n = At(e);
  if (Iu(e)) return n;
  if (!On(e)) {
      let s = Xr(e);
      for (; s && !go(s);) {
          if (pn(s) && !Dd(s)) return s;
          s = Xr(s)
      }
      return n
  }
  let r = vv(e, t);
  for (; r && Fj(r) && Dd(r);) r = vv(r, t);
  return r && go(r) && Dd(r) && !Tm(r) ? n : r || Wj(e) || n
}
const sO = async function(e) {
  const t = this.getOffsetParent || nS,
      n = this.getDimensions,
      r = await n(e.floating);
  return {
      reference: rO(e.reference, await t(e.floating), e.strategy),
      floating: {
          x: 0,
          y: 0,
          width: r.width,
          height: r.height
      }
  }
};

function iO(e) {
  return mn(e).direction === "rtl"
}
const oO = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Gj,
  getDocumentElement: In,
  getClippingRect: tO,
  getOffsetParent: nS,
  getElementRects: sO,
  getClientRects: Qj,
  getDimensions: nO,
  getScale: Hi,
  isElement: pn,
  isRTL: iO
};

function rS(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}

function aO(e, t) {
  let n = null,
      r;
  const s = In(e);

  function i() {
      var a;
      clearTimeout(r), (a = n) == null || a.disconnect(), n = null
  }

  function o(a, l) {
      a === void 0 && (a = !1), l === void 0 && (l = 1), i();
      const c = e.getBoundingClientRect(),
          {
              left: u,
              top: d,
              width: h,
              height: f
          } = c;
      if (a || t(), !h || !f) return;
      const x = Fl(d),
          m = Fl(s.clientWidth - (u + h)),
          b = Fl(s.clientHeight - (d + f)),
          v = Fl(u),
          w = {
              rootMargin: -x + "px " + -m + "px " + -b + "px " + -v + "px",
              threshold: Ct(0, Jr(1, l)) || 1
          };
      let S = !0;

      function _(E) {
          const T = E[0].intersectionRatio;
          if (T !== l) {
              if (!S) return o();
              T ? o(!1, T) : r = setTimeout(() => {
                  o(!1, 1e-7)
              }, 1e3)
          }
          T === 1 && !rS(c, e.getBoundingClientRect()) && o(), S = !1
      }
      try {
          n = new IntersectionObserver(_, {
              ...w,
              root: s.ownerDocument
          })
      } catch {
          n = new IntersectionObserver(_, w)
      }
      n.observe(e)
  }
  return o(!0), i
}

function lO(e, t, n, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: s = !0,
      ancestorResize: i = !0,
      elementResize: o = typeof ResizeObserver == "function",
      layoutShift: a = typeof IntersectionObserver == "function",
      animationFrame: l = !1
  } = r, c = Rm(e), u = s || i ? [...c ? Ia(c) : [], ...Ia(t)] : [];
  u.forEach(v => {
      s && v.addEventListener("scroll", n, {
          passive: !0
      }), i && v.addEventListener("resize", n)
  });
  const d = c && a ? aO(c, n) : null;
  let h = -1,
      f = null;
  o && (f = new ResizeObserver(v => {
      let [y] = v;
      y && y.target === c && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
          var w;
          (w = f) == null || w.observe(t)
      })), n()
  }), c && !l && f.observe(c), f.observe(t));
  let x, m = l ? Ks(e) : null;
  l && b();

  function b() {
      const v = Ks(e);
      m && !rS(m, v) && n(), m = v, x = requestAnimationFrame(b)
  }
  return n(), () => {
      var v;
      u.forEach(y => {
          s && y.removeEventListener("scroll", n), i && y.removeEventListener("resize", n)
      }), d == null || d(), (v = f) == null || v.disconnect(), f = null, l && cancelAnimationFrame(x)
  }
}
const cO = Oj,
  uO = Ij,
  dO = Aj,
  hO = Mj,
  fO = Nj,
  wv = Pj,
  pO = Dj,
  mO = (e, t, n) => {
      const r = new Map,
          s = {
              platform: oO,
              ...n
          },
          i = {
              ...s.platform,
              _c: r
          };
      return Rj(e, t, {
          ...s,
          platform: i
      })
  };
var gO = typeof document < "u",
  yO = function() {},
  fc = gO ? g.useLayoutEffect : yO;

function Qc(e, t) {
  if (e === t) return !0;
  if (typeof e != typeof t) return !1;
  if (typeof e == "function" && e.toString() === t.toString()) return !0;
  let n, r, s;
  if (e && t && typeof e == "object") {
      if (Array.isArray(e)) {
          if (n = e.length, n !== t.length) return !1;
          for (r = n; r-- !== 0;)
              if (!Qc(e[r], t[r])) return !1;
          return !0
      }
      if (s = Object.keys(e), n = s.length, n !== Object.keys(t).length) return !1;
      for (r = n; r-- !== 0;)
          if (!{}.hasOwnProperty.call(t, s[r])) return !1;
      for (r = n; r-- !== 0;) {
          const i = s[r];
          if (!(i === "_owner" && e.$$typeof) && !Qc(e[i], t[i])) return !1
      }
      return !0
  }
  return e !== e && t !== t
}

function sS(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}

function xv(e, t) {
  const n = sS(e);
  return Math.round(t * n) / n
}

function Md(e) {
  const t = g.useRef(e);
  return fc(() => {
      t.current = e
  }), t
}

function vO(e) {
  e === void 0 && (e = {});
  const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: s,
      elements: {
          reference: i,
          floating: o
      } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c
  } = e, [u, d] = g.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1
  }), [h, f] = g.useState(r);
  Qc(h, r) || f(r);
  const [x, m] = g.useState(null), [b, v] = g.useState(null), y = g.useCallback(R => {
      R !== E.current && (E.current = R, m(R))
  }, []), w = g.useCallback(R => {
      R !== T.current && (T.current = R, v(R))
  }, []), S = i || x, _ = o || b, E = g.useRef(null), T = g.useRef(null), k = g.useRef(u), P = l != null, A = Md(l), $ = Md(s), I = Md(c), G = g.useCallback(() => {
      if (!E.current || !T.current) return;
      const R = {
          placement: t,
          strategy: n,
          middleware: h
      };
      $.current && (R.platform = $.current), mO(E.current, T.current, R).then(N => {
          const M = {
              ...N,
              isPositioned: I.current !== !1
          };
          D.current && !Qc(k.current, M) && (k.current = M, sl.flushSync(() => {
              d(M)
          }))
      })
  }, [h, t, n, $, I]);
  fc(() => {
      c === !1 && k.current.isPositioned && (k.current.isPositioned = !1, d(R => ({
          ...R,
          isPositioned: !1
      })))
  }, [c]);
  const D = g.useRef(!1);
  fc(() => (D.current = !0, () => {
      D.current = !1
  }), []), fc(() => {
      if (S && (E.current = S), _ && (T.current = _), S && _) {
          if (A.current) return A.current(S, _, G);
          G()
      }
  }, [S, _, G, A, P]);
  const X = g.useMemo(() => ({
          reference: E,
          floating: T,
          setReference: y,
          setFloating: w
      }), [y, w]),
      B = g.useMemo(() => ({
          reference: S,
          floating: _
      }), [S, _]),
      U = g.useMemo(() => {
          const R = {
              position: n,
              left: 0,
              top: 0
          };
          if (!B.floating) return R;
          const N = xv(B.floating, u.x),
              M = xv(B.floating, u.y);
          return a ? {
              ...R,
              transform: "translate(" + N + "px, " + M + "px)",
              ...sS(B.floating) >= 1.5 && {
                  willChange: "transform"
              }
          } : {
              position: n,
              left: N,
              top: M
          }
      }, [n, a, B.floating, u.x, u.y]);
  return g.useMemo(() => ({
      ...u,
      update: G,
      refs: X,
      elements: B,
      floatingStyles: U
  }), [u, G, X, B, U])
}
const wO = e => {
      function t(n) {
          return {}.hasOwnProperty.call(n, "current")
      }
      return {
          name: "arrow",
          options: e,
          fn(n) {
              const {
                  element: r,
                  padding: s
              } = typeof e == "function" ? e(n) : e;
              return r && t(r) ? r.current != null ? wv({
                  element: r.current,
                  padding: s
              }).fn(n) : {} : r ? wv({
                  element: r,
                  padding: s
              }).fn(n) : {}
          }
      }
  },
  xO = (e, t) => ({
      ...cO(e),
      options: [e, t]
  }),
  bO = (e, t) => ({
      ...uO(e),
      options: [e, t]
  }),
  SO = (e, t) => ({
      ...pO(e),
      options: [e, t]
  }),
  _O = (e, t) => ({
      ...dO(e),
      options: [e, t]
  }),
  EO = (e, t) => ({
      ...hO(e),
      options: [e, t]
  }),
  CO = (e, t) => ({
      ...fO(e),
      options: [e, t]
  }),
  TO = (e, t) => ({
      ...wO(e),
      options: [e, t]
  });
var kO = "Arrow",
  iS = g.forwardRef((e, t) => {
      const {
          children: n,
          width: r = 10,
          height: s = 5,
          ...i
      } = e;
      return p.jsx(ae.svg, {
          ...i,
          ref: t,
          width: r,
          height: s,
          viewBox: "0 0 30 10",
          preserveAspectRatio: "none",
          children: e.asChild ? n : p.jsx("polygon", {
              points: "0,0 30,0 15,10"
          })
      })
  });
iS.displayName = kO;
var RO = iS;

function Am(e) {
  const [t, n] = g.useState(void 0);
  return jn(() => {
      if (e) {
          n({
              width: e.offsetWidth,
              height: e.offsetHeight
          });
          const r = new ResizeObserver(s => {
              if (!Array.isArray(s) || !s.length) return;
              const i = s[0];
              let o, a;
              if ("borderBoxSize" in i) {
                  const l = i.borderBoxSize,
                      c = Array.isArray(l) ? l[0] : l;
                  o = c.inlineSize, a = c.blockSize
              } else o = e.offsetWidth, a = e.offsetHeight;
              n({
                  width: o,
                  height: a
              })
          });
          return r.observe(e, {
              box: "border-box"
          }), () => r.unobserve(e)
      } else n(void 0)
  }, [e]), t
}
var oS = "Popper",
  [aS, lS] = Kt(oS),
  [GV, cS] = aS(oS),
  uS = "PopperAnchor",
  dS = g.forwardRef((e, t) => {
      const {
          __scopePopper: n,
          virtualRef: r,
          ...s
      } = e, i = cS(uS, n), o = g.useRef(null), a = we(t, o);
      return g.useEffect(() => {
          i.onAnchorChange((r == null ? void 0 : r.current) || o.current)
      }), r ? null : p.jsx(ae.div, {
          ...s,
          ref: a
      })
  });
dS.displayName = uS;
var Nm = "PopperContent",
  [PO, AO] = aS(Nm),
  hS = g.forwardRef((e, t) => {
      var ue, ei, sr, os, ir, ti;
      const {
          __scopePopper: n,
          side: r = "bottom",
          sideOffset: s = 0,
          align: i = "center",
          alignOffset: o = 0,
          arrowPadding: a = 0,
          avoidCollisions: l = !0,
          collisionBoundary: c = [],
          collisionPadding: u = 0,
          sticky: d = "partial",
          hideWhenDetached: h = !1,
          updatePositionStrategy: f = "optimized",
          onPlaced: x,
          ...m
      } = e, b = cS(Nm, n), [v, y] = g.useState(null), w = we(t, or => y(or)), [S, _] = g.useState(null), E = Am(S), T = (E == null ? void 0 : E.width) ?? 0, k = (E == null ? void 0 : E.height) ?? 0, P = r + (i !== "center" ? "-" + i : ""), A = typeof u == "number" ? u : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...u
      }, $ = Array.isArray(c) ? c : [c], I = $.length > 0, G = {
          padding: A,
          boundary: $.filter(jO),
          altBoundary: I
      }, {
          refs: D,
          floatingStyles: X,
          placement: B,
          isPositioned: U,
          middlewareData: R
      } = vO({
          strategy: "fixed",
          placement: P,
          whileElementsMounted: (...or) => lO(...or, {
              animationFrame: f === "always"
          }),
          elements: {
              reference: b.anchor
          },
          middleware: [xO({
              mainAxis: s + k,
              alignmentAxis: o
          }), l && bO({
              mainAxis: !0,
              crossAxis: !1,
              limiter: d === "partial" ? SO() : void 0,
              ...G
          }), l && _O({
              ...G
          }), EO({
              ...G,
              apply: ({
                  elements: or,
                  rects: ml,
                  availableWidth: ed,
                  availableHeight: gl
              }) => {
                  const {
                      width: td,
                      height: jo
                  } = ml.reference, ni = or.floating.style;
                  ni.setProperty("--radix-popper-available-width", `${ed}px`), ni.setProperty("--radix-popper-available-height", `${gl}px`), ni.setProperty("--radix-popper-anchor-width", `${td}px`), ni.setProperty("--radix-popper-anchor-height", `${jo}px`)
              }
          }), S && TO({
              element: S,
              padding: a
          }), OO({
              arrowWidth: T,
              arrowHeight: k
          }), h && CO({
              strategy: "referenceHidden",
              ...G
          })]
      }), [N, M] = mS(B), Q = fn(x);
      jn(() => {
          U && (Q == null || Q())
      }, [U, Q]);
      const W = (ue = R.arrow) == null ? void 0 : ue.x,
          re = (ei = R.arrow) == null ? void 0 : ei.y,
          ie = ((sr = R.arrow) == null ? void 0 : sr.centerOffset) !== 0,
          [Oe, Je] = g.useState();
      return jn(() => {
          v && Je(window.getComputedStyle(v).zIndex)
      }, [v]), p.jsx("div", {
          ref: D.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
              ...X,
              transform: U ? X.transform : "translate(0, -200%)",
              minWidth: "max-content",
              zIndex: Oe,
              "--radix-popper-transform-origin": [(os = R.transformOrigin) == null ? void 0 : os.x, (ir = R.transformOrigin) == null ? void 0 : ir.y].join(" "),
              ...((ti = R.hide) == null ? void 0 : ti.referenceHidden) && {
                  visibility: "hidden",
                  pointerEvents: "none"
              }
          },
          dir: e.dir,
          children: p.jsx(PO, {
              scope: n,
              placedSide: N,
              onArrowChange: _,
              arrowX: W,
              arrowY: re,
              shouldHideArrow: ie,
              children: p.jsx(ae.div, {
                  "data-side": N,
                  "data-align": M,
                  ...m,
                  ref: w,
                  style: {
                      ...m.style,
                      animation: U ? void 0 : "none"
                  }
              })
          })
      })
  });
hS.displayName = Nm;
var fS = "PopperArrow",
  NO = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right"
  },
  pS = g.forwardRef(function(t, n) {
      const {
          __scopePopper: r,
          ...s
      } = t, i = AO(fS, r), o = NO[i.placedSide];
      return p.jsx("span", {
          ref: i.onArrowChange,
          style: {
              position: "absolute",
              left: i.arrowX,
              top: i.arrowY,
              [o]: 0,
              transformOrigin: {
                  top: "",
                  right: "0 0",
                  bottom: "center 0",
                  left: "100% 0"
              } [i.placedSide],
              transform: {
                  top: "translateY(100%)",
                  right: "translateY(50%) rotate(90deg) translateX(-50%)",
                  bottom: "rotate(180deg)",
                  left: "translateY(50%) rotate(-90deg) translateX(50%)"
              } [i.placedSide],
              visibility: i.shouldHideArrow ? "hidden" : void 0
          },
          children: p.jsx(RO, {
              ...s,
              ref: n,
              style: {
                  ...s.style,
                  display: "block"
              }
          })
      })
  });
pS.displayName = fS;

function jO(e) {
  return e !== null
}
var OO = e => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
      var b, v, y;
      const {
          placement: n,
          rects: r,
          middlewareData: s
      } = t, o = ((b = s.arrow) == null ? void 0 : b.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [c, u] = mS(n), d = {
          start: "0%",
          center: "50%",
          end: "100%"
      } [u], h = (((v = s.arrow) == null ? void 0 : v.x) ?? 0) + a / 2, f = (((y = s.arrow) == null ? void 0 : y.y) ?? 0) + l / 2;
      let x = "",
          m = "";
      return c === "bottom" ? (x = o ? d : `${h}px`, m = `${-l}px`) : c === "top" ? (x = o ? d : `${h}px`, m = `${r.floating.height + l}px`) : c === "right" ? (x = `${-l}px`, m = o ? d : `${f}px`) : c === "left" && (x = `${r.floating.width + l}px`, m = o ? d : `${f}px`), {
          data: {
              x,
              y: m
          }
      }
  }
});

function mS(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n]
}
var IO = dS,
  DO = hS,
  MO = pS,
  [Mu, QV] = Kt("Tooltip", [lS]),
  jm = lS(),
  gS = "TooltipProvider",
  LO = 700,
  bv = "tooltip.open",
  [$O, yS] = Mu(gS),
  vS = e => {
      const {
          __scopeTooltip: t,
          delayDuration: n = LO,
          skipDelayDuration: r = 300,
          disableHoverableContent: s = !1,
          children: i
      } = e, o = g.useRef(!0), a = g.useRef(!1), l = g.useRef(0);
      return g.useEffect(() => {
          const c = l.current;
          return () => window.clearTimeout(c)
      }, []), p.jsx($O, {
          scope: t,
          isOpenDelayedRef: o,
          delayDuration: n,
          onOpen: g.useCallback(() => {
              window.clearTimeout(l.current), o.current = !1
          }, []),
          onClose: g.useCallback(() => {
              window.clearTimeout(l.current), l.current = window.setTimeout(() => o.current = !0, r)
          }, [r]),
          isPointerInTransitRef: a,
          onPointerInTransitChange: g.useCallback(c => {
              a.current = c
          }, []),
          disableHoverableContent: s,
          children: i
      })
  };
vS.displayName = gS;
var wS = "Tooltip",
  [YV, Lu] = Mu(wS),
  wf = "TooltipTrigger",
  FO = g.forwardRef((e, t) => {
      const {
          __scopeTooltip: n,
          ...r
      } = e, s = Lu(wf, n), i = yS(wf, n), o = jm(n), a = g.useRef(null), l = we(t, a, s.onTriggerChange), c = g.useRef(!1), u = g.useRef(!1), d = g.useCallback(() => c.current = !1, []);
      return g.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), p.jsx(IO, {
          asChild: !0,
          ...o,
          children: p.jsx(ae.button, {
              "aria-describedby": s.open ? s.contentId : void 0,
              "data-state": s.stateAttribute,
              ...r,
              ref: l,
              onPointerMove: ne(e.onPointerMove, h => {
                  h.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(), u.current = !0)
              }),
              onPointerLeave: ne(e.onPointerLeave, () => {
                  s.onTriggerLeave(), u.current = !1
              }),
              onPointerDown: ne(e.onPointerDown, () => {
                  s.open && s.onClose(), c.current = !0, document.addEventListener("pointerup", d, {
                      once: !0
                  })
              }),
              onFocus: ne(e.onFocus, () => {
                  c.current || s.onOpen()
              }),
              onBlur: ne(e.onBlur, s.onClose),
              onClick: ne(e.onClick, s.onClose)
          })
      })
  });
FO.displayName = wf;
var UO = "TooltipPortal",
  [JV, VO] = Mu(UO, {
      forceMount: void 0
  }),
  yo = "TooltipContent",
  xS = g.forwardRef((e, t) => {
      const n = VO(yo, e.__scopeTooltip),
          {
              forceMount: r = n.forceMount,
              side: s = "top",
              ...i
          } = e,
          o = Lu(yo, e.__scopeTooltip);
      return p.jsx(tr, {
          present: r || o.open,
          children: o.disableHoverableContent ? p.jsx(bS, {
              side: s,
              ...i,
              ref: t
          }) : p.jsx(BO, {
              side: s,
              ...i,
              ref: t
          })
      })
  }),
  BO = g.forwardRef((e, t) => {
      const n = Lu(yo, e.__scopeTooltip),
          r = yS(yo, e.__scopeTooltip),
          s = g.useRef(null),
          i = we(t, s),
          [o, a] = g.useState(null),
          {
              trigger: l,
              onClose: c
          } = n,
          u = s.current,
          {
              onPointerInTransitChange: d
          } = r,
          h = g.useCallback(() => {
              a(null), d(!1)
          }, [d]),
          f = g.useCallback((x, m) => {
              const b = x.currentTarget,
                  v = {
                      x: x.clientX,
                      y: x.clientY
                  },
                  y = qO(v, b.getBoundingClientRect()),
                  w = GO(v, y),
                  S = QO(m.getBoundingClientRect()),
                  _ = JO([...w, ...S]);
              a(_), d(!0)
          }, [d]);
      return g.useEffect(() => () => h(), [h]), g.useEffect(() => {
          if (l && u) {
              const x = b => f(b, u),
                  m = b => f(b, l);
              return l.addEventListener("pointerleave", x), u.addEventListener("pointerleave", m), () => {
                  l.removeEventListener("pointerleave", x), u.removeEventListener("pointerleave", m)
              }
          }
      }, [l, u, f, h]), g.useEffect(() => {
          if (o) {
              const x = m => {
                  const b = m.target,
                      v = {
                          x: m.clientX,
                          y: m.clientY
                      },
                      y = (l == null ? void 0 : l.contains(b)) || (u == null ? void 0 : u.contains(b)),
                      w = !YO(v, o);
                  y ? h() : w && (h(), c())
              };
              return document.addEventListener("pointermove", x), () => document.removeEventListener("pointermove", x)
          }
      }, [l, u, o, c, h]), p.jsx(bS, {
          ...e,
          ref: i
      })
  }),
  [zO, WO] = Mu(wS, {
      isInside: !1
  }),
  HO = c1("TooltipContent"),
  bS = g.forwardRef((e, t) => {
      const {
          __scopeTooltip: n,
          children: r,
          "aria-label": s,
          onEscapeKeyDown: i,
          onPointerDownOutside: o,
          ...a
      } = e, l = Lu(yo, n), c = jm(n), {
          onClose: u
      } = l;
      return g.useEffect(() => (document.addEventListener(bv, u), () => document.removeEventListener(bv, u)), [u]), g.useEffect(() => {
          if (l.trigger) {
              const d = h => {
                  const f = h.target;
                  f != null && f.contains(l.trigger) && u()
              };
              return window.addEventListener("scroll", d, {
                  capture: !0
              }), () => window.removeEventListener("scroll", d, {
                  capture: !0
              })
          }
      }, [l.trigger, u]), p.jsx(Pu, {
          asChild: !0,
          disableOutsidePointerEvents: !1,
          onEscapeKeyDown: i,
          onPointerDownOutside: o,
          onFocusOutside: d => d.preventDefault(),
          onDismiss: u,
          children: p.jsxs(DO, {
              "data-state": l.stateAttribute,
              ...c,
              ...a,
              ref: t,
              style: {
                  ...a.style,
                  "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              },
              children: [p.jsx(HO, {
                  children: r
              }), p.jsx(zO, {
                  scope: n,
                  isInside: !0,
                  children: p.jsx(aA, {
                      id: l.contentId,
                      role: "tooltip",
                      children: s || r
                  })
              })]
          })
      })
  });
xS.displayName = yo;
var SS = "TooltipArrow",
  KO = g.forwardRef((e, t) => {
      const {
          __scopeTooltip: n,
          ...r
      } = e, s = jm(n);
      return WO(SS, n).isInside ? null : p.jsx(MO, {
          ...s,
          ...r,
          ref: t
      })
  });
KO.displayName = SS;

function qO(e, t) {
  const n = Math.abs(t.top - e.y),
      r = Math.abs(t.bottom - e.y),
      s = Math.abs(t.right - e.x),
      i = Math.abs(t.left - e.x);
  switch (Math.min(n, r, s, i)) {
      case i:
          return "left";
      case s:
          return "right";
      case n:
          return "top";
      case r:
          return "bottom";
      default:
          throw new Error("unreachable")
  }
}

function GO(e, t, n = 5) {
  const r = [];
  switch (t) {
      case "top":
          r.push({
              x: e.x - n,
              y: e.y + n
          }, {
              x: e.x + n,
              y: e.y + n
          });
          break;
      case "bottom":
          r.push({
              x: e.x - n,
              y: e.y - n
          }, {
              x: e.x + n,
              y: e.y - n
          });
          break;
      case "left":
          r.push({
              x: e.x + n,
              y: e.y - n
          }, {
              x: e.x + n,
              y: e.y + n
          });
          break;
      case "right":
          r.push({
              x: e.x - n,
              y: e.y - n
          }, {
              x: e.x - n,
              y: e.y + n
          });
          break
  }
  return r
}

function QO(e) {
  const {
      top: t,
      right: n,
      bottom: r,
      left: s
  } = e;
  return [{
      x: s,
      y: t
  }, {
      x: n,
      y: t
  }, {
      x: n,
      y: r
  }, {
      x: s,
      y: r
  }]
}

function YO(e, t) {
  const {
      x: n,
      y: r
  } = e;
  let s = !1;
  for (let i = 0, o = t.length - 1; i < t.length; o = i++) {
      const a = t[i],
          l = t[o],
          c = a.x,
          u = a.y,
          d = l.x,
          h = l.y;
      u > r != h > r && n < (d - c) * (r - u) / (h - u) + c && (s = !s)
  }
  return s
}

function JO(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), XO(t)
}

function XO(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
      const s = e[r];
      for (; t.length >= 2;) {
          const i = t[t.length - 1],
              o = t[t.length - 2];
          if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) t.pop();
          else break
      }
      t.push(s)
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
      const s = e[r];
      for (; n.length >= 2;) {
          const i = n[n.length - 1],
              o = n[n.length - 2];
          if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x)) n.pop();
          else break
      }
      n.push(s)
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n)
}
var ZO = vS,
  _S = xS;
const eI = ZO,
  tI = g.forwardRef(({
      className: e,
      sideOffset: t = 4,
      ...n
  }, r) => p.jsx(_S, {
      ref: r,
      sideOffset: t,
      className: ee("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", e),
      ...n
  }));
tI.displayName = _S.displayName;
var To = class {
      constructor() {
          this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
      }
      subscribe(e) {
          return this.listeners.add(e), this.onSubscribe(), () => {
              this.listeners.delete(e), this.onUnsubscribe()
          }
      }
      hasListeners() {
          return this.listeners.size > 0
      }
      onSubscribe() {}
      onUnsubscribe() {}
  },
  qs = typeof window > "u" || "Deno" in globalThis;

function at() {}

function nI(e, t) {
  return typeof e == "function" ? e(t) : e
}

function xf(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0
}

function ES(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}

function Kr(e, t) {
  return typeof e == "function" ? e(t) : e
}

function Lt(e, t) {
  return typeof e == "function" ? e(t) : e
}

function Sv(e, t) {
  const {
      type: n = "all",
      exact: r,
      fetchStatus: s,
      predicate: i,
      queryKey: o,
      stale: a
  } = e;
  if (o) {
      if (r) {
          if (t.queryHash !== Om(o, t.options)) return !1
      } else if (!Da(t.queryKey, o)) return !1
  }
  if (n !== "all") {
      const l = t.isActive();
      if (n === "active" && !l || n === "inactive" && l) return !1
  }
  return !(typeof a == "boolean" && t.isStale() !== a || s && s !== t.state.fetchStatus || i && !i(t))
}

function _v(e, t) {
  const {
      exact: n,
      status: r,
      predicate: s,
      mutationKey: i
  } = e;
  if (i) {
      if (!t.options.mutationKey) return !1;
      if (n) {
          if (Gs(t.options.mutationKey) !== Gs(i)) return !1
      } else if (!Da(t.options.mutationKey, i)) return !1
  }
  return !(r && t.state.status !== r || s && !s(t))
}

function Om(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Gs)(e)
}

function Gs(e) {
  return JSON.stringify(e, (t, n) => bf(n) ? Object.keys(n).sort().reduce((r, s) => (r[s] = n[s], r), {}) : n)
}

function Da(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(n => Da(e[n], t[n])) : !1
}

function CS(e, t) {
  if (e === t) return e;
  const n = Ev(e) && Ev(t);
  if (n || bf(e) && bf(t)) {
      const r = n ? e : Object.keys(e),
          s = r.length,
          i = n ? t : Object.keys(t),
          o = i.length,
          a = n ? [] : {},
          l = new Set(r);
      let c = 0;
      for (let u = 0; u < o; u++) {
          const d = n ? u : i[u];
          (!n && l.has(d) || n) && e[d] === void 0 && t[d] === void 0 ? (a[d] = void 0, c++) : (a[d] = CS(e[d], t[d]), a[d] === e[d] && e[d] !== void 0 && c++)
      }
      return s === o && c === s ? e : a
  }
  return t
}

function Yc(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const n in e)
      if (e[n] !== t[n]) return !1;
  return !0
}

function Ev(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}

function bf(e) {
  if (!Cv(e)) return !1;
  const t = e.constructor;
  if (t === void 0) return !0;
  const n = t.prototype;
  return !(!Cv(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}

function Cv(e) {
  return Object.prototype.toString.call(e) === "[object Object]"
}

function rI(e) {
  return new Promise(t => {
      setTimeout(t, e)
  })
}

function Sf(e, t, n) {
  return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? CS(e, t) : t
}

function sI(e, t, n = 0) {
  const r = [...e, t];
  return n && r.length > n ? r.slice(1) : r
}

function iI(e, t, n = 0) {
  const r = [t, ...e];
  return n && r.length > n ? r.slice(0, -1) : r
}
var Im = Symbol();

function TS(e, t) {
  return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === Im ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}

function kS(e, t) {
  return typeof e == "function" ? e(...t) : !!e
}
var Rs, Cr, Yi, Mw, oI = (Mw = class extends To {
      constructor() {
          super();
          z(this, Rs);
          z(this, Cr);
          z(this, Yi);
          L(this, Yi, t => {
              if (!qs && window.addEventListener) {
                  const n = () => t();
                  return window.addEventListener("visibilitychange", n, !1), () => {
                      window.removeEventListener("visibilitychange", n)
                  }
              }
          })
      }
      onSubscribe() {
          C(this, Cr) || this.setEventListener(C(this, Yi))
      }
      onUnsubscribe() {
          var t;
          this.hasListeners() || ((t = C(this, Cr)) == null || t.call(this), L(this, Cr, void 0))
      }
      setEventListener(t) {
          var n;
          L(this, Yi, t), (n = C(this, Cr)) == null || n.call(this), L(this, Cr, t(r => {
              typeof r == "boolean" ? this.setFocused(r) : this.onFocus()
          }))
      }
      setFocused(t) {
          C(this, Rs) !== t && (L(this, Rs, t), this.onFocus())
      }
      onFocus() {
          const t = this.isFocused();
          this.listeners.forEach(n => {
              n(t)
          })
      }
      isFocused() {
          var t;
          return typeof C(this, Rs) == "boolean" ? C(this, Rs) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden"
      }
  }, Rs = new WeakMap, Cr = new WeakMap, Yi = new WeakMap, Mw),
  Dm = new oI,
  Ji, Tr, Xi, Lw, aI = (Lw = class extends To {
      constructor() {
          super();
          z(this, Ji, !0);
          z(this, Tr);
          z(this, Xi);
          L(this, Xi, t => {
              if (!qs && window.addEventListener) {
                  const n = () => t(!0),
                      r = () => t(!1);
                  return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
                      window.removeEventListener("online", n), window.removeEventListener("offline", r)
                  }
              }
          })
      }
      onSubscribe() {
          C(this, Tr) || this.setEventListener(C(this, Xi))
      }
      onUnsubscribe() {
          var t;
          this.hasListeners() || ((t = C(this, Tr)) == null || t.call(this), L(this, Tr, void 0))
      }
      setEventListener(t) {
          var n;
          L(this, Xi, t), (n = C(this, Tr)) == null || n.call(this), L(this, Tr, t(this.setOnline.bind(this)))
      }
      setOnline(t) {
          C(this, Ji) !== t && (L(this, Ji, t), this.listeners.forEach(r => {
              r(t)
          }))
      }
      isOnline() {
          return C(this, Ji)
      }
  }, Ji = new WeakMap, Tr = new WeakMap, Xi = new WeakMap, Lw),
  Jc = new aI;

function _f() {
  let e, t;
  const n = new Promise((s, i) => {
      e = s, t = i
  });
  n.status = "pending", n.catch(() => {});

  function r(s) {
      Object.assign(n, s), delete n.resolve, delete n.reject
  }
  return n.resolve = s => {
      r({
          status: "fulfilled",
          value: s
      }), e(s)
  }, n.reject = s => {
      r({
          status: "rejected",
          reason: s
      }), t(s)
  }, n
}

function lI(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}

function RS(e) {
  return (e ?? "online") === "online" ? Jc.isOnline() : !0
}
var PS = class extends Error {
  constructor(e) {
      super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent
  }
};

function Ld(e) {
  return e instanceof PS
}

function AS(e) {
  let t = !1,
      n = 0,
      r = !1,
      s;
  const i = _f(),
      o = m => {
          var b;
          r || (h(new PS(m)), (b = e.abort) == null || b.call(e))
      },
      a = () => {
          t = !0
      },
      l = () => {
          t = !1
      },
      c = () => Dm.isFocused() && (e.networkMode === "always" || Jc.isOnline()) && e.canRun(),
      u = () => RS(e.networkMode) && e.canRun(),
      d = m => {
          var b;
          r || (r = !0, (b = e.onSuccess) == null || b.call(e, m), s == null || s(), i.resolve(m))
      },
      h = m => {
          var b;
          r || (r = !0, (b = e.onError) == null || b.call(e, m), s == null || s(), i.reject(m))
      },
      f = () => new Promise(m => {
          var b;
          s = v => {
              (r || c()) && m(v)
          }, (b = e.onPause) == null || b.call(e)
      }).then(() => {
          var m;
          s = void 0, r || (m = e.onContinue) == null || m.call(e)
      }),
      x = () => {
          if (r) return;
          let m;
          const b = n === 0 ? e.initialPromise : void 0;
          try {
              m = b ?? e.fn()
          } catch (v) {
              m = Promise.reject(v)
          }
          Promise.resolve(m).then(d).catch(v => {
              var E;
              if (r) return;
              const y = e.retry ?? (qs ? 0 : 3),
                  w = e.retryDelay ?? lI,
                  S = typeof w == "function" ? w(n, v) : w,
                  _ = y === !0 || typeof y == "number" && n < y || typeof y == "function" && y(n, v);
              if (t || !_) {
                  h(v);
                  return
              }
              n++, (E = e.onFail) == null || E.call(e, n, v), rI(S).then(() => c() ? void 0 : f()).then(() => {
                  t ? h(v) : x()
              })
          })
      };
  return {
      promise: i,
      cancel: o,
      continue: () => (s == null || s(), i),
      cancelRetry: a,
      continueRetry: l,
      canStart: u,
      start: () => (u() ? x() : f().then(x), i)
  }
}
var cI = e => setTimeout(e, 0);

function uI() {
  let e = [],
      t = 0,
      n = a => {
          a()
      },
      r = a => {
          a()
      },
      s = cI;
  const i = a => {
          t ? e.push(a) : s(() => {
              n(a)
          })
      },
      o = () => {
          const a = e;
          e = [], a.length && s(() => {
              r(() => {
                  a.forEach(l => {
                      n(l)
                  })
              })
          })
      };
  return {
      batch: a => {
          let l;
          t++;
          try {
              l = a()
          } finally {
              t--, t || o()
          }
          return l
      },
      batchCalls: a => (...l) => {
          i(() => {
              a(...l)
          })
      },
      schedule: i,
      setNotifyFunction: a => {
          n = a
      },
      setBatchNotifyFunction: a => {
          r = a
      },
      setScheduler: a => {
          s = a
      }
  }
}
var Ve = uI(),
  Ps, $w, NS = ($w = class {
      constructor() {
          z(this, Ps)
      }
      destroy() {
          this.clearGcTimeout()
      }
      scheduleGc() {
          this.clearGcTimeout(), xf(this.gcTime) && L(this, Ps, setTimeout(() => {
              this.optionalRemove()
          }, this.gcTime))
      }
      updateGcTime(e) {
          this.gcTime = Math.max(this.gcTime || 0, e ?? (qs ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
          C(this, Ps) && (clearTimeout(C(this, Ps)), L(this, Ps, void 0))
      }
  }, Ps = new WeakMap, $w),
  Zi, As, Mt, Ns, et, Qa, js, sn, Mn, Fw, dI = (Fw = class extends NS {
      constructor(t) {
          super();
          z(this, sn);
          z(this, Zi);
          z(this, As);
          z(this, Mt);
          z(this, Ns);
          z(this, et);
          z(this, Qa);
          z(this, js);
          L(this, js, !1), L(this, Qa, t.defaultOptions), this.setOptions(t.options), this.observers = [], L(this, Ns, t.client), L(this, Mt, C(this, Ns).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, L(this, Zi, hI(this.options)), this.state = t.state ?? C(this, Zi), this.scheduleGc()
      }
      get meta() {
          return this.options.meta
      }
      get promise() {
          var t;
          return (t = C(this, et)) == null ? void 0 : t.promise
      }
      setOptions(t) {
          this.options = {
              ...C(this, Qa),
              ...t
          }, this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
          !this.observers.length && this.state.fetchStatus === "idle" && C(this, Mt).remove(this)
      }
      setData(t, n) {
          const r = Sf(this.state.data, t, this.options);
          return te(this, sn, Mn).call(this, {
              data: r,
              type: "success",
              dataUpdatedAt: n == null ? void 0 : n.updatedAt,
              manual: n == null ? void 0 : n.manual
          }), r
      }
      setState(t, n) {
          te(this, sn, Mn).call(this, {
              type: "setState",
              state: t,
              setStateOptions: n
          })
      }
      cancel(t) {
          var r, s;
          const n = (r = C(this, et)) == null ? void 0 : r.promise;
          return (s = C(this, et)) == null || s.cancel(t), n ? n.then(at).catch(at) : Promise.resolve()
      }
      destroy() {
          super.destroy(), this.cancel({
              silent: !0
          })
      }
      reset() {
          this.destroy(), this.setState(C(this, Zi))
      }
      isActive() {
          return this.observers.some(t => Lt(t.options.enabled, this) !== !1)
      }
      isDisabled() {
          return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Im || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
      }
      isStatic() {
          return this.getObserversCount() > 0 ? this.observers.some(t => Kr(t.options.staleTime, this) === "static") : !1
      }
      isStale() {
          return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
      }
      isStaleByTime(t = 0) {
          return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !ES(this.state.dataUpdatedAt, t)
      }
      onFocus() {
          var n;
          const t = this.observers.find(r => r.shouldFetchOnWindowFocus());
          t == null || t.refetch({
              cancelRefetch: !1
          }), (n = C(this, et)) == null || n.continue()
      }
      onOnline() {
          var n;
          const t = this.observers.find(r => r.shouldFetchOnReconnect());
          t == null || t.refetch({
              cancelRefetch: !1
          }), (n = C(this, et)) == null || n.continue()
      }
      addObserver(t) {
          this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), C(this, Mt).notify({
              type: "observerAdded",
              query: this,
              observer: t
          }))
      }
      removeObserver(t) {
          this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (C(this, et) && (C(this, js) ? C(this, et).cancel({
              revert: !0
          }) : C(this, et).cancelRetry()), this.scheduleGc()), C(this, Mt).notify({
              type: "observerRemoved",
              query: this,
              observer: t
          }))
      }
      getObserversCount() {
          return this.observers.length
      }
      invalidate() {
          this.state.isInvalidated || te(this, sn, Mn).call(this, {
              type: "invalidate"
          })
      }
      fetch(t, n) {
          var c, u, d;
          if (this.state.fetchStatus !== "idle") {
              if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({
                  silent: !0
              });
              else if (C(this, et)) return C(this, et).continueRetry(), C(this, et).promise
          }
          if (t && this.setOptions(t), !this.options.queryFn) {
              const h = this.observers.find(f => f.options.queryFn);
              h && this.setOptions(h.options)
          }
          const r = new AbortController,
              s = h => {
                  Object.defineProperty(h, "signal", {
                      enumerable: !0,
                      get: () => (L(this, js, !0), r.signal)
                  })
              },
              i = () => {
                  const h = TS(this.options, n),
                      x = (() => {
                          const m = {
                              client: C(this, Ns),
                              queryKey: this.queryKey,
                              meta: this.meta
                          };
                          return s(m), m
                      })();
                  return L(this, js, !1), this.options.persister ? this.options.persister(h, x, this) : h(x)
              },
              a = (() => {
                  const h = {
                      fetchOptions: n,
                      options: this.options,
                      queryKey: this.queryKey,
                      client: C(this, Ns),
                      state: this.state,
                      fetchFn: i
                  };
                  return s(h), h
              })();
          (c = this.options.behavior) == null || c.onFetch(a, this), L(this, As, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = a.fetchOptions) == null ? void 0 : u.meta)) && te(this, sn, Mn).call(this, {
              type: "fetch",
              meta: (d = a.fetchOptions) == null ? void 0 : d.meta
          });
          const l = h => {
              var f, x, m, b;
              Ld(h) && h.silent || te(this, sn, Mn).call(this, {
                  type: "error",
                  error: h
              }), Ld(h) || ((x = (f = C(this, Mt).config).onError) == null || x.call(f, h, this), (b = (m = C(this, Mt).config).onSettled) == null || b.call(m, this.state.data, h, this)), this.scheduleGc()
          };
          return L(this, et, AS({
              initialPromise: n == null ? void 0 : n.initialPromise,
              fn: a.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: h => {
                  var f, x, m, b;
                  if (h === void 0) {
                      l(new Error(`${this.queryHash} data is undefined`));
                      return
                  }
                  try {
                      this.setData(h)
                  } catch (v) {
                      l(v);
                      return
                  }(x = (f = C(this, Mt).config).onSuccess) == null || x.call(f, h, this), (b = (m = C(this, Mt).config).onSettled) == null || b.call(m, h, this.state.error, this), this.scheduleGc()
              },
              onError: l,
              onFail: (h, f) => {
                  te(this, sn, Mn).call(this, {
                      type: "failed",
                      failureCount: h,
                      error: f
                  })
              },
              onPause: () => {
                  te(this, sn, Mn).call(this, {
                      type: "pause"
                  })
              },
              onContinue: () => {
                  te(this, sn, Mn).call(this, {
                      type: "continue"
                  })
              },
              retry: a.options.retry,
              retryDelay: a.options.retryDelay,
              networkMode: a.options.networkMode,
              canRun: () => !0
          })), C(this, et).start()
      }
  }, Zi = new WeakMap, As = new WeakMap, Mt = new WeakMap, Ns = new WeakMap, et = new WeakMap, Qa = new WeakMap, js = new WeakMap, sn = new WeakSet, Mn = function(t) {
      const n = r => {
          switch (t.type) {
              case "failed":
                  return {
                      ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error
                  };
              case "pause":
                  return {
                      ...r, fetchStatus: "paused"
                  };
              case "continue":
                  return {
                      ...r, fetchStatus: "fetching"
                  };
              case "fetch":
                  return {
                      ...r, ...jS(r.data, this.options), fetchMeta: t.meta ?? null
                  };
              case "success":
                  return L(this, As, void 0), {
                      ...r,
                      data: t.data,
                      dataUpdateCount: r.dataUpdateCount + 1,
                      dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
                      error: null,
                      isInvalidated: !1,
                      status: "success",
                      ...!t.manual && {
                          fetchStatus: "idle",
                          fetchFailureCount: 0,
                          fetchFailureReason: null
                      }
                  };
              case "error":
                  const s = t.error;
                  return Ld(s) && s.revert && C(this, As) ? {
                      ...C(this, As),
                      fetchStatus: "idle"
                  } : {
                      ...r,
                      error: s,
                      errorUpdateCount: r.errorUpdateCount + 1,
                      errorUpdatedAt: Date.now(),
                      fetchFailureCount: r.fetchFailureCount + 1,
                      fetchFailureReason: s,
                      fetchStatus: "idle",
                      status: "error"
                  };
              case "invalidate":
                  return {
                      ...r, isInvalidated: !0
                  };
              case "setState":
                  return {
                      ...r, ...t.state
                  }
          }
      };
      this.state = n(this.state), Ve.batch(() => {
          this.observers.forEach(r => {
              r.onQueryUpdate()
          }), C(this, Mt).notify({
              query: this,
              type: "updated",
              action: t
          })
      })
  }, Fw);

function jS(e, t) {
  return {
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: RS(t.networkMode) ? "fetching" : "paused",
      ...e === void 0 && {
          error: null,
          status: "pending"
      }
  }
}

function hI(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData,
      n = t !== void 0,
      r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
      data: t,
      dataUpdateCount: 0,
      dataUpdatedAt: n ? r ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: !1,
      status: n ? "success" : "pending",
      fetchStatus: "idle"
  }
}
var xn, Uw, fI = (Uw = class extends To {
      constructor(t = {}) {
          super();
          z(this, xn);
          this.config = t, L(this, xn, new Map)
      }
      build(t, n, r) {
          const s = n.queryKey,
              i = n.queryHash ?? Om(s, n);
          let o = this.get(i);
          return o || (o = new dI({
              client: t,
              queryKey: s,
              queryHash: i,
              options: t.defaultQueryOptions(n),
              state: r,
              defaultOptions: t.getQueryDefaults(s)
          }), this.add(o)), o
      }
      add(t) {
          C(this, xn).has(t.queryHash) || (C(this, xn).set(t.queryHash, t), this.notify({
              type: "added",
              query: t
          }))
      }
      remove(t) {
          const n = C(this, xn).get(t.queryHash);
          n && (t.destroy(), n === t && C(this, xn).delete(t.queryHash), this.notify({
              type: "removed",
              query: t
          }))
      }
      clear() {
          Ve.batch(() => {
              this.getAll().forEach(t => {
                  this.remove(t)
              })
          })
      }
      get(t) {
          return C(this, xn).get(t)
      }
      getAll() {
          return [...C(this, xn).values()]
      }
      find(t) {
          const n = {
              exact: !0,
              ...t
          };
          return this.getAll().find(r => Sv(n, r))
      }
      findAll(t = {}) {
          const n = this.getAll();
          return Object.keys(t).length > 0 ? n.filter(r => Sv(t, r)) : n
      }
      notify(t) {
          Ve.batch(() => {
              this.listeners.forEach(n => {
                  n(t)
              })
          })
      }
      onFocus() {
          Ve.batch(() => {
              this.getAll().forEach(t => {
                  t.onFocus()
              })
          })
      }
      onOnline() {
          Ve.batch(() => {
              this.getAll().forEach(t => {
                  t.onOnline()
              })
          })
      }
  }, xn = new WeakMap, Uw),
  bn, st, Os, Sn, fr, Vw, pI = (Vw = class extends NS {
      constructor(t) {
          super();
          z(this, Sn);
          z(this, bn);
          z(this, st);
          z(this, Os);
          this.mutationId = t.mutationId, L(this, st, t.mutationCache), L(this, bn, []), this.state = t.state || OS(), this.setOptions(t.options), this.scheduleGc()
      }
      setOptions(t) {
          this.options = t, this.updateGcTime(this.options.gcTime)
      }
      get meta() {
          return this.options.meta
      }
      addObserver(t) {
          C(this, bn).includes(t) || (C(this, bn).push(t), this.clearGcTimeout(), C(this, st).notify({
              type: "observerAdded",
              mutation: this,
              observer: t
          }))
      }
      removeObserver(t) {
          L(this, bn, C(this, bn).filter(n => n !== t)), this.scheduleGc(), C(this, st).notify({
              type: "observerRemoved",
              mutation: this,
              observer: t
          })
      }
      optionalRemove() {
          C(this, bn).length || (this.state.status === "pending" ? this.scheduleGc() : C(this, st).remove(this))
      }
      continue () {
          var t;
          return ((t = C(this, Os)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
      }
      async execute(t) {
          var i, o, a, l, c, u, d, h, f, x, m, b, v, y, w, S, _, E, T, k;
          const n = () => {
              te(this, Sn, fr).call(this, {
                  type: "continue"
              })
          };
          L(this, Os, AS({
              fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
              onFail: (P, A) => {
                  te(this, Sn, fr).call(this, {
                      type: "failed",
                      failureCount: P,
                      error: A
                  })
              },
              onPause: () => {
                  te(this, Sn, fr).call(this, {
                      type: "pause"
                  })
              },
              onContinue: n,
              retry: this.options.retry ?? 0,
              retryDelay: this.options.retryDelay,
              networkMode: this.options.networkMode,
              canRun: () => C(this, st).canRun(this)
          }));
          const r = this.state.status === "pending",
              s = !C(this, Os).canStart();
          try {
              if (r) n();
              else {
                  te(this, Sn, fr).call(this, {
                      type: "pending",
                      variables: t,
                      isPaused: s
                  }), await ((o = (i = C(this, st).config).onMutate) == null ? void 0 : o.call(i, t, this));
                  const A = await ((l = (a = this.options).onMutate) == null ? void 0 : l.call(a, t));
                  A !== this.state.context && te(this, Sn, fr).call(this, {
                      type: "pending",
                      context: A,
                      variables: t,
                      isPaused: s
                  })
              }
              const P = await C(this, Os).start();
              return await ((u = (c = C(this, st).config).onSuccess) == null ? void 0 : u.call(c, P, t, this.state.context, this)), await ((h = (d = this.options).onSuccess) == null ? void 0 : h.call(d, P, t, this.state.context)), await ((x = (f = C(this, st).config).onSettled) == null ? void 0 : x.call(f, P, null, this.state.variables, this.state.context, this)), await ((b = (m = this.options).onSettled) == null ? void 0 : b.call(m, P, null, t, this.state.context)), te(this, Sn, fr).call(this, {
                  type: "success",
                  data: P
              }), P
          } catch (P) {
              try {
                  throw await ((y = (v = C(this, st).config).onError) == null ? void 0 : y.call(v, P, t, this.state.context, this)), await ((S = (w = this.options).onError) == null ? void 0 : S.call(w, P, t, this.state.context)), await ((E = (_ = C(this, st).config).onSettled) == null ? void 0 : E.call(_, void 0, P, this.state.variables, this.state.context, this)), await ((k = (T = this.options).onSettled) == null ? void 0 : k.call(T, void 0, P, t, this.state.context)), P
              } finally {
                  te(this, Sn, fr).call(this, {
                      type: "error",
                      error: P
                  })
              }
          } finally {
              C(this, st).runNext(this)
          }
      }
  }, bn = new WeakMap, st = new WeakMap, Os = new WeakMap, Sn = new WeakSet, fr = function(t) {
      const n = r => {
          switch (t.type) {
              case "failed":
                  return {
                      ...r, failureCount: t.failureCount, failureReason: t.error
                  };
              case "pause":
                  return {
                      ...r, isPaused: !0
                  };
              case "continue":
                  return {
                      ...r, isPaused: !1
                  };
              case "pending":
                  return {
                      ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now()
                  };
              case "success":
                  return {
                      ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1
                  };
              case "error":
                  return {
                      ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error"
                  }
          }
      };
      this.state = n(this.state), Ve.batch(() => {
          C(this, bn).forEach(r => {
              r.onMutationUpdate(t)
          }), C(this, st).notify({
              mutation: this,
              type: "updated",
              action: t
          })
      })
  }, Vw);

function OS() {
  return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: !1,
      status: "idle",
      variables: void 0,
      submittedAt: 0
  }
}
var Un, on, Ya, Bw, mI = (Bw = class extends To {
  constructor(t = {}) {
      super();
      z(this, Un);
      z(this, on);
      z(this, Ya);
      this.config = t, L(this, Un, new Set), L(this, on, new Map), L(this, Ya, 0)
  }
  build(t, n, r) {
      const s = new pI({
          mutationCache: this,
          mutationId: ++vl(this, Ya)._,
          options: t.defaultMutationOptions(n),
          state: r
      });
      return this.add(s), s
  }
  add(t) {
      C(this, Un).add(t);
      const n = Ul(t);
      if (typeof n == "string") {
          const r = C(this, on).get(n);
          r ? r.push(t) : C(this, on).set(n, [t])
      }
      this.notify({
          type: "added",
          mutation: t
      })
  }
  remove(t) {
      if (C(this, Un).delete(t)) {
          const n = Ul(t);
          if (typeof n == "string") {
              const r = C(this, on).get(n);
              if (r)
                  if (r.length > 1) {
                      const s = r.indexOf(t);
                      s !== -1 && r.splice(s, 1)
                  } else r[0] === t && C(this, on).delete(n)
          }
      }
      this.notify({
          type: "removed",
          mutation: t
      })
  }
  canRun(t) {
      const n = Ul(t);
      if (typeof n == "string") {
          const r = C(this, on).get(n),
              s = r == null ? void 0 : r.find(i => i.state.status === "pending");
          return !s || s === t
      } else return !0
  }
  runNext(t) {
      var r;
      const n = Ul(t);
      if (typeof n == "string") {
          const s = (r = C(this, on).get(n)) == null ? void 0 : r.find(i => i !== t && i.state.isPaused);
          return (s == null ? void 0 : s.continue()) ?? Promise.resolve()
      } else return Promise.resolve()
  }
  clear() {
      Ve.batch(() => {
          C(this, Un).forEach(t => {
              this.notify({
                  type: "removed",
                  mutation: t
              })
          }), C(this, Un).clear(), C(this, on).clear()
      })
  }
  getAll() {
      return Array.from(C(this, Un))
  }
  find(t) {
      const n = {
          exact: !0,
          ...t
      };
      return this.getAll().find(r => _v(n, r))
  }
  findAll(t = {}) {
      return this.getAll().filter(n => _v(t, n))
  }
  notify(t) {
      Ve.batch(() => {
          this.listeners.forEach(n => {
              n(t)
          })
      })
  }
  resumePausedMutations() {
      const t = this.getAll().filter(n => n.state.isPaused);
      return Ve.batch(() => Promise.all(t.map(n => n.continue().catch(at))))
  }
}, Un = new WeakMap, on = new WeakMap, Ya = new WeakMap, Bw);

function Ul(e) {
  var t;
  return (t = e.options.scope) == null ? void 0 : t.id
}

function Tv(e) {
  return {
      onFetch: (t, n) => {
          var u, d, h, f, x;
          const r = t.options,
              s = (h = (d = (u = t.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : h.direction,
              i = ((f = t.state.data) == null ? void 0 : f.pages) || [],
              o = ((x = t.state.data) == null ? void 0 : x.pageParams) || [];
          let a = {
                  pages: [],
                  pageParams: []
              },
              l = 0;
          const c = async () => {
              let m = !1;
              const b = w => {
                      Object.defineProperty(w, "signal", {
                          enumerable: !0,
                          get: () => (t.signal.aborted ? m = !0 : t.signal.addEventListener("abort", () => {
                              m = !0
                          }), t.signal)
                      })
                  },
                  v = TS(t.options, t.fetchOptions),
                  y = async (w, S, _) => {
                      if (m) return Promise.reject();
                      if (S == null && w.pages.length) return Promise.resolve(w);
                      const T = (() => {
                              const $ = {
                                  client: t.client,
                                  queryKey: t.queryKey,
                                  pageParam: S,
                                  direction: _ ? "backward" : "forward",
                                  meta: t.options.meta
                              };
                              return b($), $
                          })(),
                          k = await v(T),
                          {
                              maxPages: P
                          } = t.options,
                          A = _ ? iI : sI;
                      return {
                          pages: A(w.pages, k, P),
                          pageParams: A(w.pageParams, S, P)
                      }
                  };
              if (s && i.length) {
                  const w = s === "backward",
                      S = w ? gI : kv,
                      _ = {
                          pages: i,
                          pageParams: o
                      },
                      E = S(r, _);
                  a = await y(_, E, w)
              } else {
                  const w = e ?? i.length;
                  do {
                      const S = l === 0 ? o[0] ?? r.initialPageParam : kv(r, a);
                      if (l > 0 && S == null) break;
                      a = await y(a, S), l++
                  } while (l < w)
              }
              return a
          };
          t.options.persister ? t.fetchFn = () => {
              var m, b;
              return (b = (m = t.options).persister) == null ? void 0 : b.call(m, c, {
                  client: t.client,
                  queryKey: t.queryKey,
                  meta: t.options.meta,
                  signal: t.signal
              }, n)
          } : t.fetchFn = c
      }
  }
}

function kv(e, {
  pages: t,
  pageParams: n
}) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(t[r], t, n[r], n) : void 0
}

function gI(e, {
  pages: t,
  pageParams: n
}) {
  var r;
  return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0
}
var Re, kr, Rr, eo, to, Pr, no, ro, zw, yI = (zw = class {
      constructor(e = {}) {
          z(this, Re);
          z(this, kr);
          z(this, Rr);
          z(this, eo);
          z(this, to);
          z(this, Pr);
          z(this, no);
          z(this, ro);
          L(this, Re, e.queryCache || new fI), L(this, kr, e.mutationCache || new mI), L(this, Rr, e.defaultOptions || {}), L(this, eo, new Map), L(this, to, new Map), L(this, Pr, 0)
      }
      mount() {
          vl(this, Pr)._++, C(this, Pr) === 1 && (L(this, no, Dm.subscribe(async e => {
              e && (await this.resumePausedMutations(), C(this, Re).onFocus())
          })), L(this, ro, Jc.subscribe(async e => {
              e && (await this.resumePausedMutations(), C(this, Re).onOnline())
          })))
      }
      unmount() {
          var e, t;
          vl(this, Pr)._--, C(this, Pr) === 0 && ((e = C(this, no)) == null || e.call(this), L(this, no, void 0), (t = C(this, ro)) == null || t.call(this), L(this, ro, void 0))
      }
      isFetching(e) {
          return C(this, Re).findAll({
              ...e,
              fetchStatus: "fetching"
          }).length
      }
      isMutating(e) {
          return C(this, kr).findAll({
              ...e,
              status: "pending"
          }).length
      }
      getQueryData(e) {
          var n;
          const t = this.defaultQueryOptions({
              queryKey: e
          });
          return (n = C(this, Re).get(t.queryHash)) == null ? void 0 : n.state.data
      }
      ensureQueryData(e) {
          const t = this.defaultQueryOptions(e),
              n = C(this, Re).build(this, t),
              r = n.state.data;
          return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Kr(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r))
      }
      getQueriesData(e) {
          return C(this, Re).findAll(e).map(({
              queryKey: t,
              state: n
          }) => {
              const r = n.data;
              return [t, r]
          })
      }
      setQueryData(e, t, n) {
          const r = this.defaultQueryOptions({
                  queryKey: e
              }),
              s = C(this, Re).get(r.queryHash),
              i = s == null ? void 0 : s.state.data,
              o = nI(t, i);
          if (o !== void 0) return C(this, Re).build(this, r).setData(o, {
              ...n,
              manual: !0
          })
      }
      setQueriesData(e, t, n) {
          return Ve.batch(() => C(this, Re).findAll(e).map(({
              queryKey: r
          }) => [r, this.setQueryData(r, t, n)]))
      }
      getQueryState(e) {
          var n;
          const t = this.defaultQueryOptions({
              queryKey: e
          });
          return (n = C(this, Re).get(t.queryHash)) == null ? void 0 : n.state
      }
      removeQueries(e) {
          const t = C(this, Re);
          Ve.batch(() => {
              t.findAll(e).forEach(n => {
                  t.remove(n)
              })
          })
      }
      resetQueries(e, t) {
          const n = C(this, Re);
          return Ve.batch(() => (n.findAll(e).forEach(r => {
              r.reset()
          }), this.refetchQueries({
              type: "active",
              ...e
          }, t)))
      }
      cancelQueries(e, t = {}) {
          const n = {
                  revert: !0,
                  ...t
              },
              r = Ve.batch(() => C(this, Re).findAll(e).map(s => s.cancel(n)));
          return Promise.all(r).then(at).catch(at)
      }
      invalidateQueries(e, t = {}) {
          return Ve.batch(() => (C(this, Re).findAll(e).forEach(n => {
              n.invalidate()
          }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
              ...e,
              type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
          }, t)))
      }
      refetchQueries(e, t = {}) {
          const n = {
                  ...t,
                  cancelRefetch: t.cancelRefetch ?? !0
              },
              r = Ve.batch(() => C(this, Re).findAll(e).filter(s => !s.isDisabled() && !s.isStatic()).map(s => {
                  let i = s.fetch(void 0, n);
                  return n.throwOnError || (i = i.catch(at)), s.state.fetchStatus === "paused" ? Promise.resolve() : i
              }));
          return Promise.all(r).then(at)
      }
      fetchQuery(e) {
          const t = this.defaultQueryOptions(e);
          t.retry === void 0 && (t.retry = !1);
          const n = C(this, Re).build(this, t);
          return n.isStaleByTime(Kr(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data)
      }
      prefetchQuery(e) {
          return this.fetchQuery(e).then(at).catch(at)
      }
      fetchInfiniteQuery(e) {
          return e.behavior = Tv(e.pages), this.fetchQuery(e)
      }
      prefetchInfiniteQuery(e) {
          return this.fetchInfiniteQuery(e).then(at).catch(at)
      }
      ensureInfiniteQueryData(e) {
          return e.behavior = Tv(e.pages), this.ensureQueryData(e)
      }
      resumePausedMutations() {
          return Jc.isOnline() ? C(this, kr).resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
          return C(this, Re)
      }
      getMutationCache() {
          return C(this, kr)
      }
      getDefaultOptions() {
          return C(this, Rr)
      }
      setDefaultOptions(e) {
          L(this, Rr, e)
      }
      setQueryDefaults(e, t) {
          C(this, eo).set(Gs(e), {
              queryKey: e,
              defaultOptions: t
          })
      }
      getQueryDefaults(e) {
          const t = [...C(this, eo).values()],
              n = {};
          return t.forEach(r => {
              Da(e, r.queryKey) && Object.assign(n, r.defaultOptions)
          }), n
      }
      setMutationDefaults(e, t) {
          C(this, to).set(Gs(e), {
              mutationKey: e,
              defaultOptions: t
          })
      }
      getMutationDefaults(e) {
          const t = [...C(this, to).values()],
              n = {};
          return t.forEach(r => {
              Da(e, r.mutationKey) && Object.assign(n, r.defaultOptions)
          }), n
      }
      defaultQueryOptions(e) {
          if (e._defaulted) return e;
          const t = {
              ...C(this, Rr).queries,
              ...this.getQueryDefaults(e.queryKey),
              ...e,
              _defaulted: !0
          };
          return t.queryHash || (t.queryHash = Om(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === Im && (t.enabled = !1), t
      }
      defaultMutationOptions(e) {
          return e != null && e._defaulted ? e : {
              ...C(this, Rr).mutations,
              ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
              ...e,
              _defaulted: !0
          }
      }
      clear() {
          C(this, Re).clear(), C(this, kr).clear()
      }
  }, Re = new WeakMap, kr = new WeakMap, Rr = new WeakMap, eo = new WeakMap, to = new WeakMap, Pr = new WeakMap, no = new WeakMap, ro = new WeakMap, zw),
  ft, oe, Ja, it, Is, so, Ar, Nr, Xa, io, oo, Ds, Ms, jr, ao, de, Qo, Ef, Cf, Tf, kf, Rf, Pf, Af, IS, Ww, vI = (Ww = class extends To {
      constructor(t, n) {
          super();
          z(this, de);
          z(this, ft);
          z(this, oe);
          z(this, Ja);
          z(this, it);
          z(this, Is);
          z(this, so);
          z(this, Ar);
          z(this, Nr);
          z(this, Xa);
          z(this, io);
          z(this, oo);
          z(this, Ds);
          z(this, Ms);
          z(this, jr);
          z(this, ao, new Set);
          this.options = n, L(this, ft, t), L(this, Nr, null), L(this, Ar, _f()), this.options.experimental_prefetchInRender || C(this, Ar).reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(n)
      }
      bindMethods() {
          this.refetch = this.refetch.bind(this)
      }
      onSubscribe() {
          this.listeners.size === 1 && (C(this, oe).addObserver(this), Rv(C(this, oe), this.options) ? te(this, de, Qo).call(this) : this.updateResult(), te(this, de, kf).call(this))
      }
      onUnsubscribe() {
          this.hasListeners() || this.destroy()
      }
      shouldFetchOnReconnect() {
          return Nf(C(this, oe), this.options, this.options.refetchOnReconnect)
      }
      shouldFetchOnWindowFocus() {
          return Nf(C(this, oe), this.options, this.options.refetchOnWindowFocus)
      }
      destroy() {
          this.listeners = new Set, te(this, de, Rf).call(this), te(this, de, Pf).call(this), C(this, oe).removeObserver(this)
      }
      setOptions(t) {
          const n = this.options,
              r = C(this, oe);
          if (this.options = C(this, ft).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Lt(this.options.enabled, C(this, oe)) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
          te(this, de, Af).call(this), C(this, oe).setOptions(this.options), n._defaulted && !Yc(this.options, n) && C(this, ft).getQueryCache().notify({
              type: "observerOptionsUpdated",
              query: C(this, oe),
              observer: this
          });
          const s = this.hasListeners();
          s && Pv(C(this, oe), r, this.options, n) && te(this, de, Qo).call(this), this.updateResult(), s && (C(this, oe) !== r || Lt(this.options.enabled, C(this, oe)) !== Lt(n.enabled, C(this, oe)) || Kr(this.options.staleTime, C(this, oe)) !== Kr(n.staleTime, C(this, oe))) && te(this, de, Ef).call(this);
          const i = te(this, de, Cf).call(this);
          s && (C(this, oe) !== r || Lt(this.options.enabled, C(this, oe)) !== Lt(n.enabled, C(this, oe)) || i !== C(this, jr)) && te(this, de, Tf).call(this, i)
      }
      getOptimisticResult(t) {
          const n = C(this, ft).getQueryCache().build(C(this, ft), t),
              r = this.createResult(n, t);
          return xI(this, r) && (L(this, it, r), L(this, so, this.options), L(this, Is, C(this, oe).state)), r
      }
      getCurrentResult() {
          return C(this, it)
      }
      trackResult(t, n) {
          return new Proxy(t, {
              get: (r, s) => (this.trackProp(s), n == null || n(s), Reflect.get(r, s))
          })
      }
      trackProp(t) {
          C(this, ao).add(t)
      }
      getCurrentQuery() {
          return C(this, oe)
      }
      refetch({
          ...t
      } = {}) {
          return this.fetch({
              ...t
          })
      }
      fetchOptimistic(t) {
          const n = C(this, ft).defaultQueryOptions(t),
              r = C(this, ft).getQueryCache().build(C(this, ft), n);
          return r.fetch().then(() => this.createResult(r, n))
      }
      fetch(t) {
          return te(this, de, Qo).call(this, {
              ...t,
              cancelRefetch: t.cancelRefetch ?? !0
          }).then(() => (this.updateResult(), C(this, it)))
      }
      createResult(t, n) {
          var P;
          const r = C(this, oe),
              s = this.options,
              i = C(this, it),
              o = C(this, Is),
              a = C(this, so),
              c = t !== r ? t.state : C(this, Ja),
              {
                  state: u
              } = t;
          let d = {
                  ...u
              },
              h = !1,
              f;
          if (n._optimisticResults) {
              const A = this.hasListeners(),
                  $ = !A && Rv(t, n),
                  I = A && Pv(t, r, n, s);
              ($ || I) && (d = {
                  ...d,
                  ...jS(u.data, t.options)
              }), n._optimisticResults === "isRestoring" && (d.fetchStatus = "idle")
          }
          let {
              error: x,
              errorUpdatedAt: m,
              status: b
          } = d;
          f = d.data;
          let v = !1;
          if (n.placeholderData !== void 0 && f === void 0 && b === "pending") {
              let A;
              i != null && i.isPlaceholderData && n.placeholderData === (a == null ? void 0 : a.placeholderData) ? (A = i.data, v = !0) : A = typeof n.placeholderData == "function" ? n.placeholderData((P = C(this, oo)) == null ? void 0 : P.state.data, C(this, oo)) : n.placeholderData, A !== void 0 && (b = "success", f = Sf(i == null ? void 0 : i.data, A, n), h = !0)
          }
          if (n.select && f !== void 0 && !v)
              if (i && f === (o == null ? void 0 : o.data) && n.select === C(this, Xa)) f = C(this, io);
              else try {
                  L(this, Xa, n.select), f = n.select(f), f = Sf(i == null ? void 0 : i.data, f, n), L(this, io, f), L(this, Nr, null)
              } catch (A) {
                  L(this, Nr, A)
              }
          C(this, Nr) && (x = C(this, Nr), f = C(this, io), m = Date.now(), b = "error");
          const y = d.fetchStatus === "fetching",
              w = b === "pending",
              S = b === "error",
              _ = w && y,
              E = f !== void 0,
              k = {
                  status: b,
                  fetchStatus: d.fetchStatus,
                  isPending: w,
                  isSuccess: b === "success",
                  isError: S,
                  isInitialLoading: _,
                  isLoading: _,
                  data: f,
                  dataUpdatedAt: d.dataUpdatedAt,
                  error: x,
                  errorUpdatedAt: m,
                  failureCount: d.fetchFailureCount,
                  failureReason: d.fetchFailureReason,
                  errorUpdateCount: d.errorUpdateCount,
                  isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
                  isFetchedAfterMount: d.dataUpdateCount > c.dataUpdateCount || d.errorUpdateCount > c.errorUpdateCount,
                  isFetching: y,
                  isRefetching: y && !w,
                  isLoadingError: S && !E,
                  isPaused: d.fetchStatus === "paused",
                  isPlaceholderData: h,
                  isRefetchError: S && E,
                  isStale: Mm(t, n),
                  refetch: this.refetch,
                  promise: C(this, Ar),
                  isEnabled: Lt(n.enabled, t) !== !1
              };
          if (this.options.experimental_prefetchInRender) {
              const A = G => {
                      k.status === "error" ? G.reject(k.error) : k.data !== void 0 && G.resolve(k.data)
                  },
                  $ = () => {
                      const G = L(this, Ar, k.promise = _f());
                      A(G)
                  },
                  I = C(this, Ar);
              switch (I.status) {
                  case "pending":
                      t.queryHash === r.queryHash && A(I);
                      break;
                  case "fulfilled":
                      (k.status === "error" || k.data !== I.value) && $();
                      break;
                  case "rejected":
                      (k.status !== "error" || k.error !== I.reason) && $();
                      break
              }
          }
          return k
      }
      updateResult() {
          const t = C(this, it),
              n = this.createResult(C(this, oe), this.options);
          if (L(this, Is, C(this, oe).state), L(this, so, this.options), C(this, Is).data !== void 0 && L(this, oo, C(this, oe)), Yc(n, t)) return;
          L(this, it, n);
          const r = () => {
              if (!t) return !0;
              const {
                  notifyOnChangeProps: s
              } = this.options, i = typeof s == "function" ? s() : s;
              if (i === "all" || !i && !C(this, ao).size) return !0;
              const o = new Set(i ?? C(this, ao));
              return this.options.throwOnError && o.add("error"), Object.keys(C(this, it)).some(a => {
                  const l = a;
                  return C(this, it)[l] !== t[l] && o.has(l)
              })
          };
          te(this, de, IS).call(this, {
              listeners: r()
          })
      }
      onQueryUpdate() {
          this.updateResult(), this.hasListeners() && te(this, de, kf).call(this)
      }
  }, ft = new WeakMap, oe = new WeakMap, Ja = new WeakMap, it = new WeakMap, Is = new WeakMap, so = new WeakMap, Ar = new WeakMap, Nr = new WeakMap, Xa = new WeakMap, io = new WeakMap, oo = new WeakMap, Ds = new WeakMap, Ms = new WeakMap, jr = new WeakMap, ao = new WeakMap, de = new WeakSet, Qo = function(t) {
      te(this, de, Af).call(this);
      let n = C(this, oe).fetch(this.options, t);
      return t != null && t.throwOnError || (n = n.catch(at)), n
  }, Ef = function() {
      te(this, de, Rf).call(this);
      const t = Kr(this.options.staleTime, C(this, oe));
      if (qs || C(this, it).isStale || !xf(t)) return;
      const r = ES(C(this, it).dataUpdatedAt, t) + 1;
      L(this, Ds, setTimeout(() => {
          C(this, it).isStale || this.updateResult()
      }, r))
  }, Cf = function() {
      return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(C(this, oe)) : this.options.refetchInterval) ?? !1
  }, Tf = function(t) {
      te(this, de, Pf).call(this), L(this, jr, t), !(qs || Lt(this.options.enabled, C(this, oe)) === !1 || !xf(C(this, jr)) || C(this, jr) === 0) && L(this, Ms, setInterval(() => {
          (this.options.refetchIntervalInBackground || Dm.isFocused()) && te(this, de, Qo).call(this)
      }, C(this, jr)))
  }, kf = function() {
      te(this, de, Ef).call(this), te(this, de, Tf).call(this, te(this, de, Cf).call(this))
  }, Rf = function() {
      C(this, Ds) && (clearTimeout(C(this, Ds)), L(this, Ds, void 0))
  }, Pf = function() {
      C(this, Ms) && (clearInterval(C(this, Ms)), L(this, Ms, void 0))
  }, Af = function() {
      const t = C(this, ft).getQueryCache().build(C(this, ft), this.options);
      if (t === C(this, oe)) return;
      const n = C(this, oe);
      L(this, oe, t), L(this, Ja, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this))
  }, IS = function(t) {
      Ve.batch(() => {
          t.listeners && this.listeners.forEach(n => {
              n(C(this, it))
          }), C(this, ft).getQueryCache().notify({
              query: C(this, oe),
              type: "observerResultsUpdated"
          })
      })
  }, Ww);

function wI(e, t) {
  return Lt(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}

function Rv(e, t) {
  return wI(e, t) || e.state.data !== void 0 && Nf(e, t, t.refetchOnMount)
}

function Nf(e, t, n) {
  if (Lt(t.enabled, e) !== !1 && Kr(t.staleTime, e) !== "static") {
      const r = typeof n == "function" ? n(e) : n;
      return r === "always" || r !== !1 && Mm(e, t)
  }
  return !1
}

function Pv(e, t, n, r) {
  return (e !== t || Lt(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && Mm(e, n)
}

function Mm(e, t) {
  return Lt(t.enabled, e) !== !1 && e.isStaleByTime(Kr(t.staleTime, e))
}

function xI(e, t) {
  return !Yc(e.getCurrentResult(), t)
}
var Or, Ir, pt, Vn, Hn, pc, jf, Hw, bI = (Hw = class extends To {
      constructor(n, r) {
          super();
          z(this, Hn);
          z(this, Or);
          z(this, Ir);
          z(this, pt);
          z(this, Vn);
          L(this, Or, n), this.setOptions(r), this.bindMethods(), te(this, Hn, pc).call(this)
      }
      bindMethods() {
          this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
      }
      setOptions(n) {
          var s;
          const r = this.options;
          this.options = C(this, Or).defaultMutationOptions(n), Yc(this.options, r) || C(this, Or).getMutationCache().notify({
              type: "observerOptionsUpdated",
              mutation: C(this, pt),
              observer: this
          }), r != null && r.mutationKey && this.options.mutationKey && Gs(r.mutationKey) !== Gs(this.options.mutationKey) ? this.reset() : ((s = C(this, pt)) == null ? void 0 : s.state.status) === "pending" && C(this, pt).setOptions(this.options)
      }
      onUnsubscribe() {
          var n;
          this.hasListeners() || (n = C(this, pt)) == null || n.removeObserver(this)
      }
      onMutationUpdate(n) {
          te(this, Hn, pc).call(this), te(this, Hn, jf).call(this, n)
      }
      getCurrentResult() {
          return C(this, Ir)
      }
      reset() {
          var n;
          (n = C(this, pt)) == null || n.removeObserver(this), L(this, pt, void 0), te(this, Hn, pc).call(this), te(this, Hn, jf).call(this)
      }
      mutate(n, r) {
          var s;
          return L(this, Vn, r), (s = C(this, pt)) == null || s.removeObserver(this), L(this, pt, C(this, Or).getMutationCache().build(C(this, Or), this.options)), C(this, pt).addObserver(this), C(this, pt).execute(n)
      }
  }, Or = new WeakMap, Ir = new WeakMap, pt = new WeakMap, Vn = new WeakMap, Hn = new WeakSet, pc = function() {
      var r;
      const n = ((r = C(this, pt)) == null ? void 0 : r.state) ?? OS();
      L(this, Ir, {
          ...n,
          isPending: n.status === "pending",
          isSuccess: n.status === "success",
          isError: n.status === "error",
          isIdle: n.status === "idle",
          mutate: this.mutate,
          reset: this.reset
      })
  }, jf = function(n) {
      Ve.batch(() => {
          var r, s, i, o, a, l, c, u;
          if (C(this, Vn) && this.hasListeners()) {
              const d = C(this, Ir).variables,
                  h = C(this, Ir).context;
              (n == null ? void 0 : n.type) === "success" ? ((s = (r = C(this, Vn)).onSuccess) == null || s.call(r, n.data, d, h), (o = (i = C(this, Vn)).onSettled) == null || o.call(i, n.data, null, d, h)) : (n == null ? void 0 : n.type) === "error" && ((l = (a = C(this, Vn)).onError) == null || l.call(a, n.error, d, h), (u = (c = C(this, Vn)).onSettled) == null || u.call(c, void 0, n.error, d, h))
          }
          this.listeners.forEach(d => {
              d(C(this, Ir))
          })
      })
  }, Hw),
  DS = g.createContext(void 0),
  $u = e => {
      const t = g.useContext(DS);
      if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one");
      return t
  },
  SI = ({
      client: e,
      children: t
  }) => (g.useEffect(() => (e.mount(), () => {
      e.unmount()
  }), [e]), p.jsx(DS.Provider, {
      value: e,
      children: t
  })),
  MS = g.createContext(!1),
  _I = () => g.useContext(MS);
MS.Provider;

function EI() {
  let e = !1;
  return {
      clearReset: () => {
          e = !1
      },
      reset: () => {
          e = !0
      },
      isReset: () => e
  }
}
var CI = g.createContext(EI()),
  TI = () => g.useContext(CI),
  kI = (e, t) => {
      (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1))
  },
  RI = e => {
      g.useEffect(() => {
          e.clearReset()
      }, [e])
  },
  PI = ({
      result: e,
      errorResetBoundary: t,
      throwOnError: n,
      query: r,
      suspense: s
  }) => e.isError && !t.isReset() && !e.isFetching && r && (s && e.data === void 0 || kS(n, [e.error, r])),
  AI = e => {
      if (e.suspense) {
          const t = r => r === "static" ? r : Math.max(r ?? 1e3, 1e3),
              n = e.staleTime;
          e.staleTime = typeof n == "function" ? (...r) => t(n(...r)) : t(n), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3))
      }
  },
  NI = (e, t) => e.isLoading && e.isFetching && !t,
  jI = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending,
  Av = (e, t, n) => t.fetchOptimistic(e).catch(() => {
      n.clearReset()
  });

function OI(e, t, n) {
  var d, h, f, x, m;
  const r = _I(),
      s = TI(),
      i = $u(),
      o = i.defaultQueryOptions(e);
  (h = (d = i.getDefaultOptions().queries) == null ? void 0 : d._experimental_beforeQuery) == null || h.call(d, o), o._optimisticResults = r ? "isRestoring" : "optimistic", AI(o), kI(o, s), RI(s);
  const a = !i.getQueryCache().get(o.queryHash),
      [l] = g.useState(() => new t(i, o)),
      c = l.getOptimisticResult(o),
      u = !r && e.subscribed !== !1;
  if (g.useSyncExternalStore(g.useCallback(b => {
          const v = u ? l.subscribe(Ve.batchCalls(b)) : at;
          return l.updateResult(), v
      }, [l, u]), () => l.getCurrentResult(), () => l.getCurrentResult()), g.useEffect(() => {
          l.setOptions(o)
      }, [o, l]), jI(o, c)) throw Av(o, l, s);
  if (PI({
          result: c,
          errorResetBoundary: s,
          throwOnError: o.throwOnError,
          query: i.getQueryCache().get(o.queryHash),
          suspense: o.suspense
      })) throw c.error;
  if ((x = (f = i.getDefaultOptions().queries) == null ? void 0 : f._experimental_afterQuery) == null || x.call(f, o, c), o.experimental_prefetchInRender && !qs && NI(c, r)) {
      const b = a ? Av(o, l, s) : (m = i.getQueryCache().get(o.queryHash)) == null ? void 0 : m.promise;
      b == null || b.catch(at).finally(() => {
          l.updateResult()
      })
  }
  return o.notifyOnChangeProps ? c : l.trackResult(c)
}

function Fu(e, t) {
  return OI(e, vI)
}

function LS(e, t) {
  const n = $u(),
      [r] = g.useState(() => new bI(n, e));
  g.useEffect(() => {
      r.setOptions(e)
  }, [r, e]);
  const s = g.useSyncExternalStore(g.useCallback(o => r.subscribe(Ve.batchCalls(o)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()),
      i = g.useCallback((o, a) => {
          r.mutate(o, a).catch(at)
      }, [r]);
  if (s.error && kS(r.options.throwOnError, [s.error])) throw s.error;
  return {
      ...s,
      mutate: i,
      mutateAsync: s.mutate
  }
}
/**
* @remix-run/router v1.23.0
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function Ma() {
  return Ma = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }, Ma.apply(this, arguments)
}
var Lr;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE"
})(Lr || (Lr = {}));
const Nv = "popstate";

function II(e) {
  e === void 0 && (e = {});

  function t(r, s) {
      let {
          pathname: i,
          search: o,
          hash: a
      } = r.location;
      return Of("", {
          pathname: i,
          search: o,
          hash: a
      }, s.state && s.state.usr || null, s.state && s.state.key || "default")
  }

  function n(r, s) {
      return typeof s == "string" ? s : Xc(s)
  }
  return MI(t, n, null, e)
}

function Le(e, t) {
  if (e === !1 || e === null || typeof e > "u") throw new Error(t)
}

function $S(e, t) {
  if (!e) {
      typeof console < "u" && console.warn(t);
      try {
          throw new Error(t)
      } catch {}
  }
}

function DI() {
  return Math.random().toString(36).substr(2, 8)
}

function jv(e, t) {
  return {
      usr: e.state,
      key: e.key,
      idx: t
  }
}

function Of(e, t, n, r) {
  return n === void 0 && (n = null), Ma({
      pathname: typeof e == "string" ? e : e.pathname,
      search: "",
      hash: ""
  }, typeof t == "string" ? ko(t) : t, {
      state: n,
      key: t && t.key || r || DI()
  })
}

function Xc(e) {
  let {
      pathname: t = "/",
      search: n = "",
      hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t
}

function ko(e) {
  let t = {};
  if (e) {
      let n = e.indexOf("#");
      n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
      let r = e.indexOf("?");
      r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e)
  }
  return t
}

function MI(e, t, n, r) {
  r === void 0 && (r = {});
  let {
      window: s = document.defaultView,
      v5Compat: i = !1
  } = r, o = s.history, a = Lr.Pop, l = null, c = u();
  c == null && (c = 0, o.replaceState(Ma({}, o.state, {
      idx: c
  }), ""));

  function u() {
      return (o.state || {
          idx: null
      }).idx
  }

  function d() {
      a = Lr.Pop;
      let b = u(),
          v = b == null ? null : b - c;
      c = b, l && l({
          action: a,
          location: m.location,
          delta: v
      })
  }

  function h(b, v) {
      a = Lr.Push;
      let y = Of(m.location, b, v);
      c = u() + 1;
      let w = jv(y, c),
          S = m.createHref(y);
      try {
          o.pushState(w, "", S)
      } catch (_) {
          if (_ instanceof DOMException && _.name === "DataCloneError") throw _;
          s.location.assign(S)
      }
      i && l && l({
          action: a,
          location: m.location,
          delta: 1
      })
  }

  function f(b, v) {
      a = Lr.Replace;
      let y = Of(m.location, b, v);
      c = u();
      let w = jv(y, c),
          S = m.createHref(y);
      o.replaceState(w, "", S), i && l && l({
          action: a,
          location: m.location,
          delta: 0
      })
  }

  function x(b) {
      let v = s.location.origin !== "null" ? s.location.origin : s.location.href,
          y = typeof b == "string" ? b : Xc(b);
      return y = y.replace(/ $/, "%20"), Le(v, "No window.location.(origin|href) available to create URL for href: " + y), new URL(y, v)
  }
  let m = {
      get action() {
          return a
      },
      get location() {
          return e(s, o)
      },
      listen(b) {
          if (l) throw new Error("A history only accepts one active listener");
          return s.addEventListener(Nv, d), l = b, () => {
              s.removeEventListener(Nv, d), l = null
          }
      },
      createHref(b) {
          return t(s, b)
      },
      createURL: x,
      encodeLocation(b) {
          let v = x(b);
          return {
              pathname: v.pathname,
              search: v.search,
              hash: v.hash
          }
      },
      push: h,
      replace: f,
      go(b) {
          return o.go(b)
      }
  };
  return m
}
var Ov;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error"
})(Ov || (Ov = {}));

function LI(e, t, n) {
  return n === void 0 && (n = "/"), $I(e, t, n, !1)
}

function $I(e, t, n, r) {
  let s = typeof t == "string" ? ko(t) : t,
      i = Lm(s.pathname || "/", n);
  if (i == null) return null;
  let o = FS(e);
  FI(o);
  let a = null;
  for (let l = 0; a == null && l < o.length; ++l) {
      let c = YI(i);
      a = GI(o[l], c, r)
  }
  return a
}

function FS(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let s = (i, o, a) => {
      let l = {
          relativePath: a === void 0 ? i.path || "" : a,
          caseSensitive: i.caseSensitive === !0,
          childrenIndex: o,
          route: i
      };
      l.relativePath.startsWith("/") && (Le(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length));
      let c = qr([r, l.relativePath]),
          u = n.concat(l);
      i.children && i.children.length > 0 && (Le(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), FS(i.children, t, u, c)), !(i.path == null && !i.index) && t.push({
          path: c,
          score: KI(c, i.index),
          routesMeta: u
      })
  };
  return e.forEach((i, o) => {
      var a;
      if (i.path === "" || !((a = i.path) != null && a.includes("?"))) s(i, o);
      else
          for (let l of US(i.path)) s(i, o, l)
  }), t
}

function US(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, "");
  if (r.length === 0) return s ? [i, ""] : [i];
  let o = US(r.join("/")),
      a = [];
  return a.push(...o.map(l => l === "" ? i : [i, l].join("/"))), s && a.push(...o), a.map(l => e.startsWith("/") && l === "" ? "/" : l)
}

function FI(e) {
  e.sort((t, n) => t.score !== n.score ? n.score - t.score : qI(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
const UI = /^:[\w-]+$/,
  VI = 3,
  BI = 2,
  zI = 1,
  WI = 10,
  HI = -2,
  Iv = e => e === "*";

function KI(e, t) {
  let n = e.split("/"),
      r = n.length;
  return n.some(Iv) && (r += HI), t && (r += BI), n.filter(s => !Iv(s)).reduce((s, i) => s + (UI.test(i) ? VI : i === "" ? zI : WI), r)
}

function qI(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, s) => r === t[s]) ? e[e.length - 1] - t[t.length - 1] : 0
}

function GI(e, t, n) {
  let {
      routesMeta: r
  } = e, s = {}, i = "/", o = [];
  for (let a = 0; a < r.length; ++a) {
      let l = r[a],
          c = a === r.length - 1,
          u = i === "/" ? t : t.slice(i.length) || "/",
          d = Dv({
              path: l.relativePath,
              caseSensitive: l.caseSensitive,
              end: c
          }, u),
          h = l.route;
      if (!d && c && n && !r[r.length - 1].route.index && (d = Dv({
              path: l.relativePath,
              caseSensitive: l.caseSensitive,
              end: !1
          }, u)), !d) return null;
      Object.assign(s, d.params), o.push({
          params: s,
          pathname: qr([i, d.pathname]),
          pathnameBase: e2(qr([i, d.pathnameBase])),
          route: h
      }), d.pathnameBase !== "/" && (i = qr([i, d.pathnameBase]))
  }
  return o
}

function Dv(e, t) {
  typeof e == "string" && (e = {
      path: e,
      caseSensitive: !1,
      end: !0
  });
  let [n, r] = QI(e.path, e.caseSensitive, e.end), s = t.match(n);
  if (!s) return null;
  let i = s[0],
      o = i.replace(/(.)\/+$/, "$1"),
      a = s.slice(1);
  return {
      params: r.reduce((c, u, d) => {
          let {
              paramName: h,
              isOptional: f
          } = u;
          if (h === "*") {
              let m = a[d] || "";
              o = i.slice(0, i.length - m.length).replace(/(.)\/+$/, "$1")
          }
          const x = a[d];
          return f && !x ? c[h] = void 0 : c[h] = (x || "").replace(/%2F/g, "/"), c
      }, {}),
      pathname: i,
      pathnameBase: o,
      pattern: e
  }
}

function QI(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), $S(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = [],
      s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({
          paramName: a,
          isOptional: l != null
      }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
      paramName: "*"
  }), s += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : e !== "" && e !== "/" && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r]
}

function YI(e) {
  try {
      return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
  } catch (t) {
      return $S(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e
  }
}

function Lm(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length,
      r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/"
}

function JI(e, t) {
  t === void 0 && (t = "/");
  let {
      pathname: n,
      search: r = "",
      hash: s = ""
  } = typeof e == "string" ? ko(e) : e;
  return {
      pathname: n ? n.startsWith("/") ? n : XI(n, t) : t,
      search: t2(r),
      hash: n2(s)
  }
}

function XI(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach(s => {
      s === ".." ? n.length > 1 && n.pop() : s !== "." && n.push(s)
  }), n.length > 1 ? n.join("/") : "/"
}

function $d(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function ZI(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}

function VS(e, t) {
  let n = ZI(e);
  return t ? n.map((r, s) => s === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase)
}

function BS(e, t, n, r) {
  r === void 0 && (r = !1);
  let s;
  typeof e == "string" ? s = ko(e) : (s = Ma({}, e), Le(!s.pathname || !s.pathname.includes("?"), $d("?", "pathname", "search", s)), Le(!s.pathname || !s.pathname.includes("#"), $d("#", "pathname", "hash", s)), Le(!s.search || !s.search.includes("#"), $d("#", "search", "hash", s)));
  let i = e === "" || s.pathname === "",
      o = i ? "/" : s.pathname,
      a;
  if (o == null) a = n;
  else {
      let d = t.length - 1;
      if (!r && o.startsWith("..")) {
          let h = o.split("/");
          for (; h[0] === "..";) h.shift(), d -= 1;
          s.pathname = h.join("/")
      }
      a = d >= 0 ? t[d] : "/"
  }
  let l = JI(s, a),
      c = o && o !== "/" && o.endsWith("/"),
      u = (i || o === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l
}
const qr = e => e.join("/").replace(/\/\/+/g, "/"),
  e2 = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
  t2 = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e,
  n2 = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;

function r2(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e
}
const zS = ["post", "put", "patch", "delete"];
new Set(zS);
const s2 = ["get", ...zS];
new Set(s2);
/**
* React Router v6.30.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function La() {
  return La = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }, La.apply(this, arguments)
}
const $m = g.createContext(null),
  i2 = g.createContext(null),
  Xs = g.createContext(null),
  Uu = g.createContext(null),
  Zs = g.createContext({
      outlet: null,
      matches: [],
      isDataRoute: !1
  }),
  WS = g.createContext(null);

function o2(e, t) {
  let {
      relative: n
  } = t === void 0 ? {} : t;
  al() || Le(!1);
  let {
      basename: r,
      navigator: s
  } = g.useContext(Xs), {
      hash: i,
      pathname: o,
      search: a
  } = qS(e, {
      relative: n
  }), l = o;
  return r !== "/" && (l = o === "/" ? r : qr([r, o])), s.createHref({
      pathname: l,
      search: a,
      hash: i
  })
}

function al() {
  return g.useContext(Uu) != null
}

function ll() {
  return al() || Le(!1), g.useContext(Uu).location
}

function HS(e) {
  g.useContext(Xs).static || g.useLayoutEffect(e)
}

function KS() {
  let {
      isDataRoute: e
  } = g.useContext(Zs);
  return e ? w2() : a2()
}

function a2() {
  al() || Le(!1);
  let e = g.useContext($m),
      {
          basename: t,
          future: n,
          navigator: r
      } = g.useContext(Xs),
      {
          matches: s
      } = g.useContext(Zs),
      {
          pathname: i
      } = ll(),
      o = JSON.stringify(VS(s, n.v7_relativeSplatPath)),
      a = g.useRef(!1);
  return HS(() => {
      a.current = !0
  }), g.useCallback(function(c, u) {
      if (u === void 0 && (u = {}), !a.current) return;
      if (typeof c == "number") {
          r.go(c);
          return
      }
      let d = BS(c, JSON.parse(o), i, u.relative === "path");
      e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : qr([t, d.pathname])), (u.replace ? r.replace : r.push)(d, u.state, u)
  }, [t, r, o, i, e])
}

function qS(e, t) {
  let {
      relative: n
  } = t === void 0 ? {} : t, {
      future: r
  } = g.useContext(Xs), {
      matches: s
  } = g.useContext(Zs), {
      pathname: i
  } = ll(), o = JSON.stringify(VS(s, r.v7_relativeSplatPath));
  return g.useMemo(() => BS(e, JSON.parse(o), i, n === "path"), [e, o, i, n])
}

function l2(e, t) {
  return c2(e, t)
}

function c2(e, t, n, r) {
  al() || Le(!1);
  let {
      navigator: s
  } = g.useContext(Xs), {
      matches: i
  } = g.useContext(Zs), o = i[i.length - 1], a = o ? o.params : {};
  o && o.pathname;
  let l = o ? o.pathnameBase : "/";
  o && o.route;
  let c = ll(),
      u;
  if (t) {
      var d;
      let b = typeof t == "string" ? ko(t) : t;
      l === "/" || (d = b.pathname) != null && d.startsWith(l) || Le(!1), u = b
  } else u = c;
  let h = u.pathname || "/",
      f = h;
  if (l !== "/") {
      let b = l.replace(/^\//, "").split("/");
      f = "/" + h.replace(/^\//, "").split("/").slice(b.length).join("/")
  }
  let x = LI(e, {
          pathname: f
      }),
      m = p2(x && x.map(b => Object.assign({}, b, {
          params: Object.assign({}, a, b.params),
          pathname: qr([l, s.encodeLocation ? s.encodeLocation(b.pathname).pathname : b.pathname]),
          pathnameBase: b.pathnameBase === "/" ? l : qr([l, s.encodeLocation ? s.encodeLocation(b.pathnameBase).pathname : b.pathnameBase])
      })), i, n, r);
  return t && m ? g.createElement(Uu.Provider, {
      value: {
          location: La({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
          }, u),
          navigationType: Lr.Pop
      }
  }, m) : m
}

function u2() {
  let e = v2(),
      t = r2(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
      n = e instanceof Error ? e.stack : null,
      s = {
          padding: "0.5rem",
          backgroundColor: "rgba(200,200,200, 0.5)"
      };
  return g.createElement(g.Fragment, null, g.createElement("h2", null, "Unexpected Application Error!"), g.createElement("h3", {
      style: {
          fontStyle: "italic"
      }
  }, t), n ? g.createElement("pre", {
      style: s
  }, n) : null, null)
}
const d2 = g.createElement(u2, null);
class h2 extends g.Component {
  constructor(t) {
      super(t), this.state = {
          location: t.location,
          revalidation: t.revalidation,
          error: t.error
      }
  }
  static getDerivedStateFromError(t) {
      return {
          error: t
      }
  }
  static getDerivedStateFromProps(t, n) {
      return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
          error: t.error,
          location: t.location,
          revalidation: t.revalidation
      } : {
          error: t.error !== void 0 ? t.error : n.error,
          location: n.location,
          revalidation: t.revalidation || n.revalidation
      }
  }
  componentDidCatch(t, n) {
      console.error("React Router caught the following error during render", t, n)
  }
  render() {
      return this.state.error !== void 0 ? g.createElement(Zs.Provider, {
          value: this.props.routeContext
      }, g.createElement(WS.Provider, {
          value: this.state.error,
          children: this.props.component
      })) : this.props.children
  }
}

function f2(e) {
  let {
      routeContext: t,
      match: n,
      children: r
  } = e, s = g.useContext($m);
  return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), g.createElement(Zs.Provider, {
      value: t
  }, r)
}

function p2(e, t, n, r) {
  var s;
  if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) {
      var i;
      if (!n) return null;
      if (n.errors) e = n.matches;
      else if ((i = r) != null && i.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches;
      else return null
  }
  let o = e,
      a = (s = n) == null ? void 0 : s.errors;
  if (a != null) {
      let u = o.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0);
      u >= 0 || Le(!1), o = o.slice(0, Math.min(o.length, u + 1))
  }
  let l = !1,
      c = -1;
  if (n && r && r.v7_partialHydration)
      for (let u = 0; u < o.length; u++) {
          let d = o[u];
          if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (c = u), d.route.id) {
              let {
                  loaderData: h,
                  errors: f
              } = n, x = d.route.loader && h[d.route.id] === void 0 && (!f || f[d.route.id] === void 0);
              if (d.route.lazy || x) {
                  l = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
                  break
              }
          }
      }
  return o.reduceRight((u, d, h) => {
      let f, x = !1,
          m = null,
          b = null;
      n && (f = a && d.route.id ? a[d.route.id] : void 0, m = d.route.errorElement || d2, l && (c < 0 && h === 0 ? (x = !0, b = null) : c === h && (x = !0, b = d.route.hydrateFallbackElement || null)));
      let v = t.concat(o.slice(0, h + 1)),
          y = () => {
              let w;
              return f ? w = m : x ? w = b : d.route.Component ? w = g.createElement(d.route.Component, null) : d.route.element ? w = d.route.element : w = u, g.createElement(f2, {
                  match: d,
                  routeContext: {
                      outlet: u,
                      matches: v,
                      isDataRoute: n != null
                  },
                  children: w
              })
          };
      return n && (d.route.ErrorBoundary || d.route.errorElement || h === 0) ? g.createElement(h2, {
          location: n.location,
          revalidation: n.revalidation,
          component: m,
          error: f,
          children: y(),
          routeContext: {
              outlet: null,
              matches: v,
              isDataRoute: !0
          }
      }) : y()
  }, null)
}
var GS = function(e) {
      return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e
  }(GS || {}),
  Zc = function(e) {
      return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e
  }(Zc || {});

function m2(e) {
  let t = g.useContext($m);
  return t || Le(!1), t
}

function g2(e) {
  let t = g.useContext(i2);
  return t || Le(!1), t
}

function y2(e) {
  let t = g.useContext(Zs);
  return t || Le(!1), t
}

function QS(e) {
  let t = y2(),
      n = t.matches[t.matches.length - 1];
  return n.route.id || Le(!1), n.route.id
}

function v2() {
  var e;
  let t = g.useContext(WS),
      n = g2(Zc.UseRouteError),
      r = QS(Zc.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r]
}

function w2() {
  let {
      router: e
  } = m2(GS.UseNavigateStable), t = QS(Zc.UseNavigateStable), n = g.useRef(!1);
  return HS(() => {
      n.current = !0
  }), g.useCallback(function(s, i) {
      i === void 0 && (i = {}), n.current && (typeof s == "number" ? e.navigate(s) : e.navigate(s, La({
          fromRouteId: t
      }, i)))
  }, [e, t])
}

function x2(e, t) {
  e == null || e.v7_startTransition, e == null || e.v7_relativeSplatPath
}

function Yo(e) {
  Le(!1)
}

function b2(e) {
  let {
      basename: t = "/",
      children: n = null,
      location: r,
      navigationType: s = Lr.Pop,
      navigator: i,
      static: o = !1,
      future: a
  } = e;
  al() && Le(!1);
  let l = t.replace(/^\/*/, "/"),
      c = g.useMemo(() => ({
          basename: l,
          navigator: i,
          static: o,
          future: La({
              v7_relativeSplatPath: !1
          }, a)
      }), [l, a, i, o]);
  typeof r == "string" && (r = ko(r));
  let {
      pathname: u = "/",
      search: d = "",
      hash: h = "",
      state: f = null,
      key: x = "default"
  } = r, m = g.useMemo(() => {
      let b = Lm(u, l);
      return b == null ? null : {
          location: {
              pathname: b,
              search: d,
              hash: h,
              state: f,
              key: x
          },
          navigationType: s
      }
  }, [l, u, d, h, f, x, s]);
  return m == null ? null : g.createElement(Xs.Provider, {
      value: c
  }, g.createElement(Uu.Provider, {
      children: n,
      value: m
  }))
}

function S2(e) {
  let {
      children: t,
      location: n
  } = e;
  return l2(If(t), n)
}
new Promise(() => {});

function If(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return g.Children.forEach(e, (r, s) => {
      if (!g.isValidElement(r)) return;
      let i = [...t, s];
      if (r.type === g.Fragment) {
          n.push.apply(n, If(r.props.children, i));
          return
      }
      r.type !== Yo && Le(!1), !r.props.index || !r.props.children || Le(!1);
      let o = {
          id: r.props.id || i.join("-"),
          caseSensitive: r.props.caseSensitive,
          element: r.props.element,
          Component: r.props.Component,
          index: r.props.index,
          path: r.props.path,
          loader: r.props.loader,
          action: r.props.action,
          errorElement: r.props.errorElement,
          ErrorBoundary: r.props.ErrorBoundary,
          hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
          shouldRevalidate: r.props.shouldRevalidate,
          handle: r.props.handle,
          lazy: r.props.lazy
      };
      r.props.children && (o.children = If(r.props.children, i)), n.push(o)
  }), n
}
/**
* React Router DOM v6.30.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function Df() {
  return Df = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }, Df.apply(this, arguments)
}

function _2(e, t) {
  if (e == null) return {};
  var n = {},
      r = Object.keys(e),
      s, i;
  for (i = 0; i < r.length; i++) s = r[i], !(t.indexOf(s) >= 0) && (n[s] = e[s]);
  return n
}

function E2(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}

function C2(e, t) {
  return e.button === 0 && (!t || t === "_self") && !E2(e)
}
const T2 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"],
  k2 = "6";
try {
  window.__reactRouterVersion = k2
} catch {}
const R2 = "startTransition",
  Mv = Cp[R2];

function P2(e) {
  let {
      basename: t,
      children: n,
      future: r,
      window: s
  } = e, i = g.useRef();
  i.current == null && (i.current = II({
      window: s,
      v5Compat: !0
  }));
  let o = i.current,
      [a, l] = g.useState({
          action: o.action,
          location: o.location
      }),
      {
          v7_startTransition: c
      } = r || {},
      u = g.useCallback(d => {
          c && Mv ? Mv(() => l(d)) : l(d)
      }, [l, c]);
  return g.useLayoutEffect(() => o.listen(u), [o, u]), g.useEffect(() => x2(r), [r]), g.createElement(b2, {
      basename: t,
      children: n,
      location: a.location,
      navigationType: a.action,
      navigator: o,
      future: r
  })
}
const A2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
  N2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  j2 = g.forwardRef(function(t, n) {
      let {
          onClick: r,
          relative: s,
          reloadDocument: i,
          replace: o,
          state: a,
          target: l,
          to: c,
          preventScrollReset: u,
          viewTransition: d
      } = t, h = _2(t, T2), {
          basename: f
      } = g.useContext(Xs), x, m = !1;
      if (typeof c == "string" && N2.test(c) && (x = c, A2)) try {
          let w = new URL(window.location.href),
              S = c.startsWith("//") ? new URL(w.protocol + c) : new URL(c),
              _ = Lm(S.pathname, f);
          S.origin === w.origin && _ != null ? c = _ + S.search + S.hash : m = !0
      } catch {}
      let b = o2(c, {
              relative: s
          }),
          v = O2(c, {
              replace: o,
              state: a,
              target: l,
              preventScrollReset: u,
              relative: s,
              viewTransition: d
          });

      function y(w) {
          r && r(w), w.defaultPrevented || v(w)
      }
      return g.createElement("a", Df({}, h, {
          href: x || b,
          onClick: m || i ? r : y,
          ref: n,
          target: l
      }))
  });
var Lv;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState"
})(Lv || (Lv = {}));
var $v;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration"
})($v || ($v = {}));

function O2(e, t) {
  let {
      target: n,
      replace: r,
      state: s,
      preventScrollReset: i,
      relative: o,
      viewTransition: a
  } = t === void 0 ? {} : t, l = KS(), c = ll(), u = qS(e, {
      relative: o
  });
  return g.useCallback(d => {
      if (C2(d, n)) {
          d.preventDefault();
          let h = r !== void 0 ? r : Xc(c) === Xc(u);
          l(e, {
              replace: h,
              state: s,
              preventScrollReset: i,
              relative: o,
              viewTransition: a
          })
      }
  }, [c, l, u, r, s, n, e, i, o, a])
}
const Fm = g.createContext({});

function Um(e) {
  const t = g.useRef(null);
  return t.current === null && (t.current = e()), t.current
}
const Vm = typeof window < "u",
  YS = Vm ? g.useLayoutEffect : g.useEffect,
  Vu = g.createContext(null);

function Bm(e, t) {
  e.indexOf(t) === -1 && e.push(t)
}

function zm(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1)
}
const Xn = (e, t, n) => n > t ? t : n < e ? e : n;
let eu = () => {};
const Zn = {},
  JS = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);

function XS(e) {
  return typeof e == "object" && e !== null
}
const ZS = e => /^0[^.\s]+$/u.test(e);

function Wm(e) {
  let t;
  return () => (t === void 0 && (t = e()), t)
}
const zt = e => e,
  I2 = (e, t) => n => t(e(n)),
  cl = (...e) => e.reduce(I2),
  $a = (e, t, n) => {
      const r = t - e;
      return r === 0 ? 1 : (n - e) / r
  };
class Hm {
  constructor() {
      this.subscriptions = []
  }
  add(t) {
      return Bm(this.subscriptions, t), () => zm(this.subscriptions, t)
  }
  notify(t, n, r) {
      const s = this.subscriptions.length;
      if (s)
          if (s === 1) this.subscriptions[0](t, n, r);
          else
              for (let i = 0; i < s; i++) {
                  const o = this.subscriptions[i];
                  o && o(t, n, r)
              }
  }
  getSize() {
      return this.subscriptions.length
  }
  clear() {
      this.subscriptions.length = 0
  }
}
const Pn = e => e * 1e3,
  Vt = e => e / 1e3;

function e_(e, t) {
  return t ? e * (1e3 / t) : 0
}
const t_ = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
  D2 = 1e-7,
  M2 = 12;

function L2(e, t, n, r, s) {
  let i, o, a = 0;
  do o = t + (n - t) / 2, i = t_(o, r, s) - e, i > 0 ? n = o : t = o; while (Math.abs(i) > D2 && ++a < M2);
  return o
}

function ul(e, t, n, r) {
  if (e === t && n === r) return zt;
  const s = i => L2(i, 0, 1, e, n);
  return i => i === 0 || i === 1 ? i : t_(s(i), t, r)
}
const n_ = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
  r_ = e => t => 1 - e(1 - t),
  s_ = ul(.33, 1.53, .69, .99),
  Km = r_(s_),
  i_ = n_(Km),
  o_ = e => (e *= 2) < 1 ? .5 * Km(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))),
  qm = e => 1 - Math.sin(Math.acos(e)),
  a_ = r_(qm),
  l_ = n_(qm),
  $2 = ul(.42, 0, 1, 1),
  F2 = ul(0, 0, .58, 1),
  c_ = ul(.42, 0, .58, 1),
  U2 = e => Array.isArray(e) && typeof e[0] != "number",
  u_ = e => Array.isArray(e) && typeof e[0] == "number",
  Fv = {
      linear: zt,
      easeIn: $2,
      easeInOut: c_,
      easeOut: F2,
      circIn: qm,
      circInOut: l_,
      circOut: a_,
      backIn: Km,
      backInOut: i_,
      backOut: s_,
      anticipate: o_
  },
  V2 = e => typeof e == "string",
  Uv = e => {
      if (u_(e)) {
          eu(e.length === 4);
          const [t, n, r, s] = e;
          return ul(t, n, r, s)
      } else if (V2(e)) return eu(Fv[e] !== void 0), Fv[e];
      return e
  },
  Vl = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"],
  Vv = {
      value: null,
      addProjectionMetrics: null
  };

function B2(e, t) {
  let n = new Set,
      r = new Set,
      s = !1,
      i = !1;
  const o = new WeakSet;
  let a = {
          delta: 0,
          timestamp: 0,
          isProcessing: !1
      },
      l = 0;

  function c(d) {
      o.has(d) && (u.schedule(d), e()), l++, d(a)
  }
  const u = {
      schedule: (d, h = !1, f = !1) => {
          const m = f && s ? n : r;
          return h && o.add(d), m.has(d) || m.add(d), d
      },
      cancel: d => {
          r.delete(d), o.delete(d)
      },
      process: d => {
          if (a = d, s) {
              i = !0;
              return
          }
          s = !0, [n, r] = [r, n], n.forEach(c), t && Vv.value && Vv.value.frameloop[t].push(l), l = 0, n.clear(), s = !1, i && (i = !1, u.process(d))
      }
  };
  return u
}
const z2 = 40;

function d_(e, t) {
  let n = !1,
      r = !0;
  const s = {
          delta: 0,
          timestamp: 0,
          isProcessing: !1
      },
      i = () => n = !0,
      o = Vl.reduce((w, S) => (w[S] = B2(i, t ? S : void 0), w), {}),
      {
          setup: a,
          read: l,
          resolveKeyframes: c,
          preUpdate: u,
          update: d,
          preRender: h,
          render: f,
          postRender: x
      } = o,
      m = () => {
          const w = Zn.useManualTiming ? s.timestamp : performance.now();
          n = !1, Zn.useManualTiming || (s.delta = r ? 1e3 / 60 : Math.max(Math.min(w - s.timestamp, z2), 1)), s.timestamp = w, s.isProcessing = !0, a.process(s), l.process(s), c.process(s), u.process(s), d.process(s), h.process(s), f.process(s), x.process(s), s.isProcessing = !1, n && t && (r = !1, e(m))
      },
      b = () => {
          n = !0, r = !0, s.isProcessing || e(m)
      };
  return {
      schedule: Vl.reduce((w, S) => {
          const _ = o[S];
          return w[S] = (E, T = !1, k = !1) => (n || b(), _.schedule(E, T, k)), w
      }, {}),
      cancel: w => {
          for (let S = 0; S < Vl.length; S++) o[Vl[S]].cancel(w)
      },
      state: s,
      steps: o
  }
}
const {
  schedule: Se,
  cancel: Zr,
  state: Ge,
  steps: Fd
} = d_(typeof requestAnimationFrame < "u" ? requestAnimationFrame : zt, !0);
let mc;

function W2() {
  mc = void 0
}
const wt = {
      now: () => (mc === void 0 && wt.set(Ge.isProcessing || Zn.useManualTiming ? Ge.timestamp : performance.now()), mc),
      set: e => {
          mc = e, queueMicrotask(W2)
      }
  },
  h_ = e => t => typeof t == "string" && t.startsWith(e),
  f_ = h_("--"),
  H2 = h_("var(--"),
  Gm = e => H2(e) ? K2.test(e.split("/*")[0].trim()) : !1,
  K2 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Ro = {
      test: e => typeof e == "number",
      parse: parseFloat,
      transform: e => e
  },
  Fa = {
      ...Ro,
      transform: e => Xn(0, 1, e)
  },
  Bl = {
      ...Ro,
      default: 1
  },
  ca = e => Math.round(e * 1e5) / 1e5,
  Qm = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function q2(e) {
  return e == null
}
const G2 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  Ym = (e, t) => n => !!(typeof n == "string" && G2.test(n) && n.startsWith(e) || t && !q2(n) && Object.prototype.hasOwnProperty.call(n, t)),
  p_ = (e, t, n) => r => {
      if (typeof r != "string") return r;
      const [s, i, o, a] = r.match(Qm);
      return {
          [e]: parseFloat(s),
          [t]: parseFloat(i),
          [n]: parseFloat(o),
          alpha: a !== void 0 ? parseFloat(a) : 1
      }
  },
  Q2 = e => Xn(0, 255, e),
  Ud = {
      ...Ro,
      transform: e => Math.round(Q2(e))
  },
  Cs = {
      test: Ym("rgb", "red"),
      parse: p_("red", "green", "blue"),
      transform: ({
          red: e,
          green: t,
          blue: n,
          alpha: r = 1
      }) => "rgba(" + Ud.transform(e) + ", " + Ud.transform(t) + ", " + Ud.transform(n) + ", " + ca(Fa.transform(r)) + ")"
  };

function Y2(e) {
  let t = "",
      n = "",
      r = "",
      s = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), s = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), s = e.substring(4, 5), t += t, n += n, r += r, s += s), {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: s ? parseInt(s, 16) / 255 : 1
  }
}
const Mf = {
      test: Ym("#"),
      parse: Y2,
      transform: Cs.transform
  },
  dl = e => ({
      test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
      parse: parseFloat,
      transform: t => `${t}${e}`
  }),
  pr = dl("deg"),
  An = dl("%"),
  q = dl("px"),
  J2 = dl("vh"),
  X2 = dl("vw"),
  Bv = {
      ...An,
      parse: e => An.parse(e) / 100,
      transform: e => An.transform(e * 100)
  },
  Ni = {
      test: Ym("hsl", "hue"),
      parse: p_("hue", "saturation", "lightness"),
      transform: ({
          hue: e,
          saturation: t,
          lightness: n,
          alpha: r = 1
      }) => "hsla(" + Math.round(e) + ", " + An.transform(ca(t)) + ", " + An.transform(ca(n)) + ", " + ca(Fa.transform(r)) + ")"
  },
  De = {
      test: e => Cs.test(e) || Mf.test(e) || Ni.test(e),
      parse: e => Cs.test(e) ? Cs.parse(e) : Ni.test(e) ? Ni.parse(e) : Mf.parse(e),
      transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? Cs.transform(e) : Ni.transform(e),
      getAnimatableNone: e => {
          const t = De.parse(e);
          return t.alpha = 0, De.transform(t)
      }
  },
  Z2 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function eD(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(Qm)) == null ? void 0 : t.length) || 0) + (((n = e.match(Z2)) == null ? void 0 : n.length) || 0) > 0
}
const m_ = "number",
  g_ = "color",
  tD = "var",
  nD = "var(",
  zv = "${}",
  rD = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function Ua(e) {
  const t = e.toString(),
      n = [],
      r = {
          color: [],
          number: [],
          var: []
      },
      s = [];
  let i = 0;
  const a = t.replace(rD, l => (De.test(l) ? (r.color.push(i), s.push(g_), n.push(De.parse(l))) : l.startsWith(nD) ? (r.var.push(i), s.push(tD), n.push(l)) : (r.number.push(i), s.push(m_), n.push(parseFloat(l))), ++i, zv)).split(zv);
  return {
      values: n,
      split: a,
      indexes: r,
      types: s
  }
}

function y_(e) {
  return Ua(e).values
}

function v_(e) {
  const {
      split: t,
      types: n
  } = Ua(e), r = t.length;
  return s => {
      let i = "";
      for (let o = 0; o < r; o++)
          if (i += t[o], s[o] !== void 0) {
              const a = n[o];
              a === m_ ? i += ca(s[o]) : a === g_ ? i += De.transform(s[o]) : i += s[o]
          } return i
  }
}
const sD = e => typeof e == "number" ? 0 : De.test(e) ? De.getAnimatableNone(e) : e;

function iD(e) {
  const t = y_(e);
  return v_(e)(t.map(sD))
}
const es = {
  test: eD,
  parse: y_,
  createTransformer: v_,
  getAnimatableNone: iD
};

function Vd(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}

function oD({
  hue: e,
  saturation: t,
  lightness: n,
  alpha: r
}) {
  e /= 360, t /= 100, n /= 100;
  let s = 0,
      i = 0,
      o = 0;
  if (!t) s = i = o = n;
  else {
      const a = n < .5 ? n * (1 + t) : n + t - n * t,
          l = 2 * n - a;
      s = Vd(l, a, e + 1 / 3), i = Vd(l, a, e), o = Vd(l, a, e - 1 / 3)
  }
  return {
      red: Math.round(s * 255),
      green: Math.round(i * 255),
      blue: Math.round(o * 255),
      alpha: r
  }
}

function tu(e, t) {
  return n => n > 0 ? t : e
}
const Ce = (e, t, n) => e + (t - e) * n,
  Bd = (e, t, n) => {
      const r = e * e,
          s = n * (t * t - r) + r;
      return s < 0 ? 0 : Math.sqrt(s)
  },
  aD = [Mf, Cs, Ni],
  lD = e => aD.find(t => t.test(e));

function Wv(e) {
  const t = lD(e);
  if (!t) return !1;
  let n = t.parse(e);
  return t === Ni && (n = oD(n)), n
}
const Hv = (e, t) => {
      const n = Wv(e),
          r = Wv(t);
      if (!n || !r) return tu(e, t);
      const s = {
          ...n
      };
      return i => (s.red = Bd(n.red, r.red, i), s.green = Bd(n.green, r.green, i), s.blue = Bd(n.blue, r.blue, i), s.alpha = Ce(n.alpha, r.alpha, i), Cs.transform(s))
  },
  Lf = new Set(["none", "hidden"]);

function cD(e, t) {
  return Lf.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e
}

function uD(e, t) {
  return n => Ce(e, t, n)
}

function Jm(e) {
  return typeof e == "number" ? uD : typeof e == "string" ? Gm(e) ? tu : De.test(e) ? Hv : fD : Array.isArray(e) ? w_ : typeof e == "object" ? De.test(e) ? Hv : dD : tu
}

function w_(e, t) {
  const n = [...e],
      r = n.length,
      s = e.map((i, o) => Jm(i)(i, t[o]));
  return i => {
      for (let o = 0; o < r; o++) n[o] = s[o](i);
      return n
  }
}

function dD(e, t) {
  const n = {
          ...e,
          ...t
      },
      r = {};
  for (const s in n) e[s] !== void 0 && t[s] !== void 0 && (r[s] = Jm(e[s])(e[s], t[s]));
  return s => {
      for (const i in r) n[i] = r[i](s);
      return n
  }
}

function hD(e, t) {
  const n = [],
      r = {
          color: 0,
          var: 0,
          number: 0
      };
  for (let s = 0; s < t.values.length; s++) {
      const i = t.types[s],
          o = e.indexes[i][r[i]],
          a = e.values[o] ?? 0;
      n[s] = a, r[i]++
  }
  return n
}
const fD = (e, t) => {
  const n = es.createTransformer(t),
      r = Ua(e),
      s = Ua(t);
  return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? Lf.has(e) && !s.values.length || Lf.has(t) && !r.values.length ? cD(e, t) : cl(w_(hD(r, s), s.values), n) : tu(e, t)
};

function x_(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Ce(e, t, n) : Jm(e)(e, t)
}
const pD = e => {
      const t = ({
          timestamp: n
      }) => e(n);
      return {
          start: (n = !0) => Se.update(t, n),
          stop: () => Zr(t),
          now: () => Ge.isProcessing ? Ge.timestamp : wt.now()
      }
  },
  b_ = (e, t, n = 10) => {
      let r = "";
      const s = Math.max(Math.round(t / n), 2);
      for (let i = 0; i < s; i++) r += Math.round(e(i / (s - 1)) * 1e4) / 1e4 + ", ";
      return `linear(${r.substring(0, r.length - 2)})`
  },
  nu = 2e4;

function Xm(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < nu;) t += n, r = e.next(t);
  return t >= nu ? 1 / 0 : t
}

function mD(e, t = 100, n) {
  const r = n({
          ...e,
          keyframes: [0, t]
      }),
      s = Math.min(Xm(r), nu);
  return {
      type: "keyframes",
      ease: i => r.next(s * i).value / t,
      duration: Vt(s)
  }
}
const gD = 5;

function S_(e, t, n) {
  const r = Math.max(t - gD, 0);
  return e_(n - e(r), t - r)
}
const Ae = {
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      duration: 800,
      bounce: .3,
      visualDuration: .3,
      restSpeed: {
          granular: .01,
          default: 2
      },
      restDelta: {
          granular: .005,
          default: .5
      },
      minDuration: .01,
      maxDuration: 10,
      minDamping: .05,
      maxDamping: 1
  },
  zd = .001;

function yD({
  duration: e = Ae.duration,
  bounce: t = Ae.bounce,
  velocity: n = Ae.velocity,
  mass: r = Ae.mass
}) {
  let s, i, o = 1 - t;
  o = Xn(Ae.minDamping, Ae.maxDamping, o), e = Xn(Ae.minDuration, Ae.maxDuration, Vt(e)), o < 1 ? (s = c => {
      const u = c * o,
          d = u * e,
          h = u - n,
          f = $f(c, o),
          x = Math.exp(-d);
      return zd - h / f * x
  }, i = c => {
      const d = c * o * e,
          h = d * n + n,
          f = Math.pow(o, 2) * Math.pow(c, 2) * e,
          x = Math.exp(-d),
          m = $f(Math.pow(c, 2), o);
      return (-s(c) + zd > 0 ? -1 : 1) * ((h - f) * x) / m
  }) : (s = c => {
      const u = Math.exp(-c * e),
          d = (c - n) * e + 1;
      return -zd + u * d
  }, i = c => {
      const u = Math.exp(-c * e),
          d = (n - c) * (e * e);
      return u * d
  });
  const a = 5 / e,
      l = wD(s, i, a);
  if (e = Pn(e), isNaN(l)) return {
      stiffness: Ae.stiffness,
      damping: Ae.damping,
      duration: e
  };
  {
      const c = Math.pow(l, 2) * r;
      return {
          stiffness: c,
          damping: o * 2 * Math.sqrt(r * c),
          duration: e
      }
  }
}
const vD = 12;

function wD(e, t, n) {
  let r = n;
  for (let s = 1; s < vD; s++) r = r - e(r) / t(r);
  return r
}

function $f(e, t) {
  return e * Math.sqrt(1 - t * t)
}
const xD = ["duration", "bounce"],
  bD = ["stiffness", "damping", "mass"];

function Kv(e, t) {
  return t.some(n => e[n] !== void 0)
}

function SD(e) {
  let t = {
      velocity: Ae.velocity,
      stiffness: Ae.stiffness,
      damping: Ae.damping,
      mass: Ae.mass,
      isResolvedFromDuration: !1,
      ...e
  };
  if (!Kv(e, bD) && Kv(e, xD))
      if (e.visualDuration) {
          const n = e.visualDuration,
              r = 2 * Math.PI / (n * 1.2),
              s = r * r,
              i = 2 * Xn(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(s);
          t = {
              ...t,
              mass: Ae.mass,
              stiffness: s,
              damping: i
          }
      } else {
          const n = yD(e);
          t = {
              ...t,
              ...n,
              mass: Ae.mass
          }, t.isResolvedFromDuration = !0
      } return t
}

function ru(e = Ae.visualDuration, t = Ae.bounce) {
  const n = typeof e != "object" ? {
      visualDuration: e,
      keyframes: [0, 1],
      bounce: t
  } : e;
  let {
      restSpeed: r,
      restDelta: s
  } = n;
  const i = n.keyframes[0],
      o = n.keyframes[n.keyframes.length - 1],
      a = {
          done: !1,
          value: i
      },
      {
          stiffness: l,
          damping: c,
          mass: u,
          duration: d,
          velocity: h,
          isResolvedFromDuration: f
      } = SD({
          ...n,
          velocity: -Vt(n.velocity || 0)
      }),
      x = h || 0,
      m = c / (2 * Math.sqrt(l * u)),
      b = o - i,
      v = Vt(Math.sqrt(l / u)),
      y = Math.abs(b) < 5;
  r || (r = y ? Ae.restSpeed.granular : Ae.restSpeed.default), s || (s = y ? Ae.restDelta.granular : Ae.restDelta.default);
  let w;
  if (m < 1) {
      const _ = $f(v, m);
      w = E => {
          const T = Math.exp(-m * v * E);
          return o - T * ((x + m * v * b) / _ * Math.sin(_ * E) + b * Math.cos(_ * E))
      }
  } else if (m === 1) w = _ => o - Math.exp(-v * _) * (b + (x + v * b) * _);
  else {
      const _ = v * Math.sqrt(m * m - 1);
      w = E => {
          const T = Math.exp(-m * v * E),
              k = Math.min(_ * E, 300);
          return o - T * ((x + m * v * b) * Math.sinh(k) + _ * b * Math.cosh(k)) / _
      }
  }
  const S = {
      calculatedDuration: f && d || null,
      next: _ => {
          const E = w(_);
          if (f) a.done = _ >= d;
          else {
              let T = _ === 0 ? x : 0;
              m < 1 && (T = _ === 0 ? Pn(x) : S_(w, _, E));
              const k = Math.abs(T) <= r,
                  P = Math.abs(o - E) <= s;
              a.done = k && P
          }
          return a.value = a.done ? o : E, a
      },
      toString: () => {
          const _ = Math.min(Xm(S), nu),
              E = b_(T => S.next(_ * T).value, _, 30);
          return _ + "ms " + E
      },
      toTransition: () => {}
  };
  return S
}
ru.applyToOptions = e => {
  const t = mD(e, 100, ru);
  return e.ease = t.ease, e.duration = Pn(t.duration), e.type = "keyframes", e
};

function Ff({
  keyframes: e,
  velocity: t = 0,
  power: n = .8,
  timeConstant: r = 325,
  bounceDamping: s = 10,
  bounceStiffness: i = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: c = .5,
  restSpeed: u
}) {
  const d = e[0],
      h = {
          done: !1,
          value: d
      },
      f = k => a !== void 0 && k < a || l !== void 0 && k > l,
      x = k => a === void 0 ? l : l === void 0 || Math.abs(a - k) < Math.abs(l - k) ? a : l;
  let m = n * t;
  const b = d + m,
      v = o === void 0 ? b : o(b);
  v !== b && (m = v - d);
  const y = k => -m * Math.exp(-k / r),
      w = k => v + y(k),
      S = k => {
          const P = y(k),
              A = w(k);
          h.done = Math.abs(P) <= c, h.value = h.done ? v : A
      };
  let _, E;
  const T = k => {
      f(h.value) && (_ = k, E = ru({
          keyframes: [h.value, x(h.value)],
          velocity: S_(w, k, h.value),
          damping: s,
          stiffness: i,
          restDelta: c,
          restSpeed: u
      }))
  };
  return T(0), {
      calculatedDuration: null,
      next: k => {
          let P = !1;
          return !E && _ === void 0 && (P = !0, S(k), T(k)), _ !== void 0 && k >= _ ? E.next(k - _) : (!P && S(k), h)
      }
  }
}

function _D(e, t, n) {
  const r = [],
      s = n || Zn.mix || x_,
      i = e.length - 1;
  for (let o = 0; o < i; o++) {
      let a = s(e[o], e[o + 1]);
      if (t) {
          const l = Array.isArray(t) ? t[o] || zt : t;
          a = cl(l, a)
      }
      r.push(a)
  }
  return r
}

function ED(e, t, {
  clamp: n = !0,
  ease: r,
  mixer: s
} = {}) {
  const i = e.length;
  if (eu(i === t.length), i === 1) return () => t[0];
  if (i === 2 && t[0] === t[1]) return () => t[1];
  const o = e[0] === e[1];
  e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const a = _D(t, r, s),
      l = a.length,
      c = u => {
          if (o && u < e[0]) return t[0];
          let d = 0;
          if (l > 1)
              for (; d < e.length - 2 && !(u < e[d + 1]); d++);
          const h = $a(e[d], e[d + 1], u);
          return a[d](h)
      };
  return n ? u => c(Xn(e[0], e[i - 1], u)) : c
}

function CD(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
      const s = $a(0, t, r);
      e.push(Ce(n, 1, s))
  }
}

function TD(e) {
  const t = [0];
  return CD(t, e.length - 1), t
}

function kD(e, t) {
  return e.map(n => n * t)
}

function RD(e, t) {
  return e.map(() => t || c_).splice(0, e.length - 1)
}

function ua({
  duration: e = 300,
  keyframes: t,
  times: n,
  ease: r = "easeInOut"
}) {
  const s = U2(r) ? r.map(Uv) : Uv(r),
      i = {
          done: !1,
          value: t[0]
      },
      o = kD(n && n.length === t.length ? n : TD(t), e),
      a = ED(o, t, {
          ease: Array.isArray(s) ? s : RD(t, s)
      });
  return {
      calculatedDuration: e,
      next: l => (i.value = a(l), i.done = l >= e, i)
  }
}
const PD = e => e !== null;

function Zm(e, {
  repeat: t,
  repeatType: n = "loop"
}, r, s = 1) {
  const i = e.filter(PD),
      a = s < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return !a || r === void 0 ? i[a] : r
}
const AD = {
  decay: Ff,
  inertia: Ff,
  tween: ua,
  keyframes: ua,
  spring: ru
};

function __(e) {
  typeof e.type == "string" && (e.type = AD[e.type])
}
class eg {
  constructor() {
      this.updateFinished()
  }
  get finished() {
      return this._finished
  }
  updateFinished() {
      this._finished = new Promise(t => {
          this.resolve = t
      })
  }
  notifyFinished() {
      this.resolve()
  }
  then(t, n) {
      return this.finished.then(t, n)
  }
}
const ND = e => e / 100;
class tg extends eg {
  constructor(t) {
      super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
          var r, s;
          const {
              motionValue: n
          } = this.options;
          n && n.updatedAt !== wt.now() && this.tick(wt.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (s = (r = this.options).onStop) == null || s.call(r))
      }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause()
  }
  initAnimation() {
      const {
          options: t
      } = this;
      __(t);
      const {
          type: n = ua,
          repeat: r = 0,
          repeatDelay: s = 0,
          repeatType: i,
          velocity: o = 0
      } = t;
      let {
          keyframes: a
      } = t;
      const l = n || ua;
      l !== ua && typeof a[0] != "number" && (this.mixKeyframes = cl(ND, x_(a[0], a[1])), a = [0, 100]);
      const c = l({
          ...t,
          keyframes: a
      });
      i === "mirror" && (this.mirroredGenerator = l({
          ...t,
          keyframes: [...a].reverse(),
          velocity: -o
      })), c.calculatedDuration === null && (c.calculatedDuration = Xm(c));
      const {
          calculatedDuration: u
      } = c;
      this.calculatedDuration = u, this.resolvedDuration = u + s, this.totalDuration = this.resolvedDuration * (r + 1) - s, this.generator = c
  }
  updateTime(t) {
      const n = Math.round(t - this.startTime) * this.playbackSpeed;
      this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n
  }
  tick(t, n = !1) {
      const {
          generator: r,
          totalDuration: s,
          mixKeyframes: i,
          mirroredGenerator: o,
          resolvedDuration: a,
          calculatedDuration: l
      } = this;
      if (this.startTime === null) return r.next(0);
      const {
          delay: c = 0,
          keyframes: u,
          repeat: d,
          repeatType: h,
          repeatDelay: f,
          type: x,
          onUpdate: m,
          finalKeyframe: b
      } = this.options;
      this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
      const v = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
          y = this.playbackSpeed >= 0 ? v < 0 : v > s;
      this.currentTime = Math.max(v, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s);
      let w = this.currentTime,
          S = r;
      if (d) {
          const k = Math.min(this.currentTime, s) / a;
          let P = Math.floor(k),
              A = k % 1;
          !A && k >= 1 && (A = 1), A === 1 && P--, P = Math.min(P, d + 1), !!(P % 2) && (h === "reverse" ? (A = 1 - A, f && (A -= f / a)) : h === "mirror" && (S = o)), w = Xn(0, 1, A) * a
      }
      const _ = y ? {
          done: !1,
          value: u[0]
      } : S.next(w);
      i && (_.value = i(_.value));
      let {
          done: E
      } = _;
      !y && l !== null && (E = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0);
      const T = this.holdTime === null && (this.state === "finished" || this.state === "running" && E);
      return T && x !== Ff && (_.value = Zm(u, this.options, b, this.speed)), m && m(_.value), T && this.finish(), _
  }
  then(t, n) {
      return this.finished.then(t, n)
  }
  get duration() {
      return Vt(this.calculatedDuration)
  }
  get iterationDuration() {
      const {
          delay: t = 0
      } = this.options || {};
      return this.duration + Vt(t)
  }
  get time() {
      return Vt(this.currentTime)
  }
  set time(t) {
      var n;
      t = Pn(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1)
  }
  get speed() {
      return this.playbackSpeed
  }
  set speed(t) {
      this.updateTime(wt.now());
      const n = this.playbackSpeed !== t;
      this.playbackSpeed = t, n && (this.time = Vt(this.currentTime))
  }
  play() {
      var s, i;
      if (this.isStopped) return;
      const {
          driver: t = pD,
          startTime: n
      } = this.options;
      this.driver || (this.driver = t(o => this.tick(o))), (i = (s = this.options).onPlay) == null || i.call(s);
      const r = this.driver.now();
      this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start()
  }
  pause() {
      this.state = "paused", this.updateTime(wt.now()), this.holdTime = this.currentTime
  }
  complete() {
      this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null
  }
  finish() {
      var t, n;
      this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t)
  }
  cancel() {
      var t, n;
      this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t)
  }
  teardown() {
      this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null
  }
  stopDriver() {
      this.driver && (this.driver.stop(), this.driver = void 0)
  }
  sample(t) {
      return this.startTime = 0, this.tick(t, !0)
  }
  attachTimeline(t) {
      var n;
      return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this)
  }
}

function jD(e) {
  for (let t = 1; t < e.length; t++) e[t] ?? (e[t] = e[t - 1])
}
const Ts = e => e * 180 / Math.PI,
  Uf = e => {
      const t = Ts(Math.atan2(e[1], e[0]));
      return Vf(t)
  },
  OD = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
      rotate: Uf,
      rotateZ: Uf,
      skewX: e => Ts(Math.atan(e[1])),
      skewY: e => Ts(Math.atan(e[2])),
      skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2
  },
  Vf = e => (e = e % 360, e < 0 && (e += 360), e),
  qv = Uf,
  Gv = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]),
  Qv = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]),
  ID = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX: Gv,
      scaleY: Qv,
      scale: e => (Gv(e) + Qv(e)) / 2,
      rotateX: e => Vf(Ts(Math.atan2(e[6], e[5]))),
      rotateY: e => Vf(Ts(Math.atan2(-e[2], e[0]))),
      rotateZ: qv,
      rotate: qv,
      skewX: e => Ts(Math.atan(e[4])),
      skewY: e => Ts(Math.atan(e[1])),
      skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2
  };

function Bf(e) {
  return e.includes("scale") ? 1 : 0
}

function zf(e, t) {
  if (!e || e === "none") return Bf(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, s;
  if (n) r = ID, s = n;
  else {
      const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      r = OD, s = a
  }
  if (!s) return Bf(t);
  const i = r[t],
      o = s[1].split(",").map(MD);
  return typeof i == "function" ? i(o) : o[i]
}
const DD = (e, t) => {
  const {
      transform: n = "none"
  } = getComputedStyle(e);
  return zf(n, t)
};

function MD(e) {
  return parseFloat(e.trim())
}
const Po = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
  Ao = new Set(Po),
  Yv = e => e === Ro || e === q,
  LD = new Set(["x", "y", "z"]),
  $D = Po.filter(e => !LD.has(e));

function FD(e) {
  const t = [];
  return $D.forEach(n => {
      const r = e.getValue(n);
      r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0))
  }), t
}
const Fs = {
  width: ({
      x: e
  }, {
      paddingLeft: t = "0",
      paddingRight: n = "0"
  }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({
      y: e
  }, {
      paddingTop: t = "0",
      paddingBottom: n = "0"
  }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, {
      top: t
  }) => parseFloat(t),
  left: (e, {
      left: t
  }) => parseFloat(t),
  bottom: ({
      y: e
  }, {
      top: t
  }) => parseFloat(t) + (e.max - e.min),
  right: ({
      x: e
  }, {
      left: t
  }) => parseFloat(t) + (e.max - e.min),
  x: (e, {
      transform: t
  }) => zf(t, "x"),
  y: (e, {
      transform: t
  }) => zf(t, "y")
};
Fs.translateX = Fs.x;
Fs.translateY = Fs.y;
const Us = new Set;
let Wf = !1,
  Hf = !1,
  Kf = !1;

function E_() {
  if (Hf) {
      const e = Array.from(Us).filter(r => r.needsMeasurement),
          t = new Set(e.map(r => r.element)),
          n = new Map;
      t.forEach(r => {
          const s = FD(r);
          s.length && (n.set(r, s), r.render())
      }), e.forEach(r => r.measureInitialState()), t.forEach(r => {
          r.render();
          const s = n.get(r);
          s && s.forEach(([i, o]) => {
              var a;
              (a = r.getValue(i)) == null || a.set(o)
          })
      }), e.forEach(r => r.measureEndState()), e.forEach(r => {
          r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY)
      })
  }
  Hf = !1, Wf = !1, Us.forEach(e => e.complete(Kf)), Us.clear()
}

function C_() {
  Us.forEach(e => {
      e.readKeyframes(), e.needsMeasurement && (Hf = !0)
  })
}

function UD() {
  Kf = !0, C_(), E_(), Kf = !1
}
class ng {
  constructor(t, n, r, s, i, o = !1) {
      this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = s, this.element = i, this.isAsync = o
  }
  scheduleResolve() {
      this.state = "scheduled", this.isAsync ? (Us.add(this), Wf || (Wf = !0, Se.read(C_), Se.resolveKeyframes(E_))) : (this.readKeyframes(), this.complete())
  }
  readKeyframes() {
      const {
          unresolvedKeyframes: t,
          name: n,
          element: r,
          motionValue: s
      } = this;
      if (t[0] === null) {
          const i = s == null ? void 0 : s.get(),
              o = t[t.length - 1];
          if (i !== void 0) t[0] = i;
          else if (r && n) {
              const a = r.readValue(n, o);
              a != null && (t[0] = a)
          }
          t[0] === void 0 && (t[0] = o), s && i === void 0 && s.set(t[0])
      }
      jD(t)
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(t = !1) {
      this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Us.delete(this)
  }
  cancel() {
      this.state === "scheduled" && (Us.delete(this), this.state = "pending")
  }
  resume() {
      this.state === "pending" && this.scheduleResolve()
  }
}
const VD = e => e.startsWith("--");

function BD(e, t, n) {
  VD(t) ? e.style.setProperty(t, n) : e.style[t] = n
}
const zD = Wm(() => window.ScrollTimeline !== void 0),
  WD = {};

function HD(e, t) {
  const n = Wm(e);
  return () => WD[t] ?? n()
}
const T_ = HD(() => {
      try {
          document.createElement("div").animate({
              opacity: 0
          }, {
              easing: "linear(0, 1)"
          })
      } catch {
          return !1
      }
      return !0
  }, "linearEasing"),
  Jo = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`,
  Jv = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: Jo([0, .65, .55, 1]),
      circOut: Jo([.55, 0, 1, .45]),
      backIn: Jo([.31, .01, .66, -.59]),
      backOut: Jo([.33, 1.53, .69, .99])
  };

function k_(e, t) {
  if (e) return typeof e == "function" ? T_() ? b_(e, t) : "ease-out" : u_(e) ? Jo(e) : Array.isArray(e) ? e.map(n => k_(n, t) || Jv.easeOut) : Jv[e]
}

function KD(e, t, n, {
  delay: r = 0,
  duration: s = 300,
  repeat: i = 0,
  repeatType: o = "loop",
  ease: a = "easeOut",
  times: l
} = {}, c = void 0) {
  const u = {
      [t]: n
  };
  l && (u.offset = l);
  const d = k_(a, s);
  Array.isArray(d) && (u.easing = d);
  const h = {
      delay: r,
      duration: s,
      easing: Array.isArray(d) ? "linear" : d,
      fill: "both",
      iterations: i + 1,
      direction: o === "reverse" ? "alternate" : "normal"
  };
  return c && (h.pseudoElement = c), e.animate(u, h)
}

function R_(e) {
  return typeof e == "function" && "applyToOptions" in e
}

function qD({
  type: e,
  ...t
}) {
  return R_(e) && T_() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t)
}
class GD extends eg {
  constructor(t) {
      if (super(), this.finishedTime = null, this.isStopped = !1, !t) return;
      const {
          element: n,
          name: r,
          keyframes: s,
          pseudoElement: i,
          allowFlatten: o = !1,
          finalKeyframe: a,
          onComplete: l
      } = t;
      this.isPseudoElement = !!i, this.allowFlatten = o, this.options = t, eu(typeof t.type != "string");
      const c = qD(t);
      this.animation = KD(n, r, s, c, i), c.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
          if (this.finishedTime = this.time, !i) {
              const u = Zm(s, this.options, a, this.speed);
              this.updateMotionValue ? this.updateMotionValue(u) : BD(n, r, u), this.animation.cancel()
          }
          l == null || l(), this.notifyFinished()
      }
  }
  play() {
      this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished())
  }
  pause() {
      this.animation.pause()
  }
  complete() {
      var t, n;
      (n = (t = this.animation).finish) == null || n.call(t)
  }
  cancel() {
      try {
          this.animation.cancel()
      } catch {}
  }
  stop() {
      if (this.isStopped) return;
      this.isStopped = !0;
      const {
          state: t
      } = this;
      t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel())
  }
  commitStyles() {
      var t, n;
      this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t)
  }
  get duration() {
      var n, r;
      const t = ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : r.call(n).duration) || 0;
      return Vt(Number(t))
  }
  get iterationDuration() {
      const {
          delay: t = 0
      } = this.options || {};
      return this.duration + Vt(t)
  }
  get time() {
      return Vt(Number(this.animation.currentTime) || 0)
  }
  set time(t) {
      this.finishedTime = null, this.animation.currentTime = Pn(t)
  }
  get speed() {
      return this.animation.playbackRate
  }
  set speed(t) {
      t < 0 && (this.finishedTime = null), this.animation.playbackRate = t
  }
  get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState
  }
  get startTime() {
      return Number(this.animation.startTime)
  }
  set startTime(t) {
      this.animation.startTime = t
  }
  attachTimeline({
      timeline: t,
      observe: n
  }) {
      var r;
      return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({
          easing: "linear"
      })), this.animation.onfinish = null, t && zD() ? (this.animation.timeline = t, zt) : n(this)
  }
}
const P_ = {
  anticipate: o_,
  backInOut: i_,
  circInOut: l_
};

function QD(e) {
  return e in P_
}

function YD(e) {
  typeof e.ease == "string" && QD(e.ease) && (e.ease = P_[e.ease])
}
const Xv = 10;
class JD extends GD {
  constructor(t) {
      YD(t), __(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t
  }
  updateMotionValue(t) {
      const {
          motionValue: n,
          onUpdate: r,
          onComplete: s,
          element: i,
          ...o
      } = this.options;
      if (!n) return;
      if (t !== void 0) {
          n.set(t);
          return
      }
      const a = new tg({
              ...o,
              autoplay: !1
          }),
          l = Pn(this.finishedTime ?? this.time);
      n.setWithVelocity(a.sample(l - Xv).value, a.sample(l).value, Xv), a.stop()
  }
}
const Zv = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (es.test(e) || e === "0") && !e.startsWith("url("));

function XD(e) {
  const t = e[0];
  if (e.length === 1) return !0;
  for (let n = 0; n < e.length; n++)
      if (e[n] !== t) return !0
}

function ZD(e, t, n, r) {
  const s = e[0];
  if (s === null) return !1;
  if (t === "display" || t === "visibility") return !0;
  const i = e[e.length - 1],
      o = Zv(s, t),
      a = Zv(i, t);
  return !o || !a ? !1 : XD(e) || (n === "spring" || R_(n)) && r
}

function qf(e) {
  e.duration = 0, e.type = "keyframes"
}
const eM = new Set(["opacity", "clipPath", "filter", "transform"]),
  tM = Wm(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

function nM(e) {
  var u;
  const {
      motionValue: t,
      name: n,
      repeatDelay: r,
      repeatType: s,
      damping: i,
      type: o
  } = e;
  if (!(((u = t == null ? void 0 : t.owner) == null ? void 0 : u.current) instanceof HTMLElement)) return !1;
  const {
      onUpdate: l,
      transformTemplate: c
  } = t.owner.getProps();
  return tM() && n && eM.has(n) && (n !== "transform" || !c) && !l && !r && s !== "mirror" && i !== 0 && o !== "inertia"
}
const rM = 40;
class sM extends eg {
  constructor({
      autoplay: t = !0,
      delay: n = 0,
      type: r = "keyframes",
      repeat: s = 0,
      repeatDelay: i = 0,
      repeatType: o = "loop",
      keyframes: a,
      name: l,
      motionValue: c,
      element: u,
      ...d
  }) {
      var x;
      super(), this.stop = () => {
          var m, b;
          this._animation && (this._animation.stop(), (m = this.stopTimeline) == null || m.call(this)), (b = this.keyframeResolver) == null || b.cancel()
      }, this.createdAt = wt.now();
      const h = {
              autoplay: t,
              delay: n,
              type: r,
              repeat: s,
              repeatDelay: i,
              repeatType: o,
              name: l,
              motionValue: c,
              element: u,
              ...d
          },
          f = (u == null ? void 0 : u.KeyframeResolver) || ng;
      this.keyframeResolver = new f(a, (m, b, v) => this.onKeyframesResolved(m, b, h, !v), l, c, u), (x = this.keyframeResolver) == null || x.scheduleResolve()
  }
  onKeyframesResolved(t, n, r, s) {
      this.keyframeResolver = void 0;
      const {
          name: i,
          type: o,
          velocity: a,
          delay: l,
          isHandoff: c,
          onUpdate: u
      } = r;
      this.resolvedAt = wt.now(), ZD(t, i, o, a) || ((Zn.instantAnimations || !l) && (u == null || u(Zm(t, r, n))), t[0] = t[t.length - 1], qf(r), r.repeat = 0);
      const h = {
              startTime: s ? this.resolvedAt ? this.resolvedAt - this.createdAt > rM ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
              finalKeyframe: n,
              ...r,
              keyframes: t
          },
          f = !c && nM(h) ? new JD({
              ...h,
              element: h.motionValue.owner.current
          }) : new tg(h);
      f.finished.then(() => this.notifyFinished()).catch(zt), this.pendingTimeline && (this.stopTimeline = f.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = f
  }
  get finished() {
      return this._animation ? this.animation.finished : this._finished
  }
  then(t, n) {
      return this.finished.finally(t).then(() => {})
  }
  get animation() {
      var t;
      return this._animation || ((t = this.keyframeResolver) == null || t.resume(), UD()), this._animation
  }
  get duration() {
      return this.animation.duration
  }
  get iterationDuration() {
      return this.animation.iterationDuration
  }
  get time() {
      return this.animation.time
  }
  set time(t) {
      this.animation.time = t
  }
  get speed() {
      return this.animation.speed
  }
  get state() {
      return this.animation.state
  }
  set speed(t) {
      this.animation.speed = t
  }
  get startTime() {
      return this.animation.startTime
  }
  attachTimeline(t) {
      return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop()
  }
  play() {
      this.animation.play()
  }
  pause() {
      this.animation.pause()
  }
  complete() {
      this.animation.complete()
  }
  cancel() {
      var t;
      this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel()
  }
}
const iM = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function oM(e) {
  const t = iM.exec(e);
  if (!t) return [, ];
  const [, n, r, s] = t;
  return [`--${n ?? r}`, s]
}

function A_(e, t, n = 1) {
  const [r, s] = oM(e);
  if (!r) return;
  const i = window.getComputedStyle(t).getPropertyValue(r);
  if (i) {
      const o = i.trim();
      return JS(o) ? parseFloat(o) : o
  }
  return Gm(s) ? A_(s, t, n + 1) : s
}

function rg(e, t) {
  return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e
}
const N_ = new Set(["width", "height", "top", "left", "right", "bottom", ...Po]),
  aM = {
      test: e => e === "auto",
      parse: e => e
  },
  j_ = e => t => t.test(e),
  O_ = [Ro, q, An, pr, X2, J2, aM],
  e0 = e => O_.find(j_(e));

function lM(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || ZS(e) : !0
}
const cM = new Set(["brightness", "contrast", "saturate", "opacity"]);

function uM(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow") return e;
  const [r] = n.match(Qm) || [];
  if (!r) return e;
  const s = n.replace(r, "");
  let i = cM.has(t) ? 1 : 0;
  return r !== n && (i *= 100), t + "(" + i + s + ")"
}
const dM = /\b([a-z-]*)\(.*?\)/gu,
  Gf = {
      ...es,
      getAnimatableNone: e => {
          const t = e.match(dM);
          return t ? t.map(uM).join(" ") : e
      }
  },
  t0 = {
      ...Ro,
      transform: Math.round
  },
  hM = {
      rotate: pr,
      rotateX: pr,
      rotateY: pr,
      rotateZ: pr,
      scale: Bl,
      scaleX: Bl,
      scaleY: Bl,
      scaleZ: Bl,
      skew: pr,
      skewX: pr,
      skewY: pr,
      distance: q,
      translateX: q,
      translateY: q,
      translateZ: q,
      x: q,
      y: q,
      z: q,
      perspective: q,
      transformPerspective: q,
      opacity: Fa,
      originX: Bv,
      originY: Bv,
      originZ: q
  },
  sg = {
      borderWidth: q,
      borderTopWidth: q,
      borderRightWidth: q,
      borderBottomWidth: q,
      borderLeftWidth: q,
      borderRadius: q,
      radius: q,
      borderTopLeftRadius: q,
      borderTopRightRadius: q,
      borderBottomRightRadius: q,
      borderBottomLeftRadius: q,
      width: q,
      maxWidth: q,
      height: q,
      maxHeight: q,
      top: q,
      right: q,
      bottom: q,
      left: q,
      padding: q,
      paddingTop: q,
      paddingRight: q,
      paddingBottom: q,
      paddingLeft: q,
      margin: q,
      marginTop: q,
      marginRight: q,
      marginBottom: q,
      marginLeft: q,
      backgroundPositionX: q,
      backgroundPositionY: q,
      ...hM,
      zIndex: t0,
      fillOpacity: Fa,
      strokeOpacity: Fa,
      numOctaves: t0
  },
  fM = {
      ...sg,
      color: De,
      backgroundColor: De,
      outlineColor: De,
      fill: De,
      stroke: De,
      borderColor: De,
      borderTopColor: De,
      borderRightColor: De,
      borderBottomColor: De,
      borderLeftColor: De,
      filter: Gf,
      WebkitFilter: Gf
  },
  I_ = e => fM[e];

function D_(e, t) {
  let n = I_(e);
  return n !== Gf && (n = es), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
}
const pM = new Set(["auto", "none", "0"]);

function mM(e, t, n) {
  let r = 0,
      s;
  for (; r < e.length && !s;) {
      const i = e[r];
      typeof i == "string" && !pM.has(i) && Ua(i).values.length && (s = e[r]), r++
  }
  if (s && n)
      for (const i of t) e[i] = D_(n, s)
}
class gM extends ng {
  constructor(t, n, r, s, i) {
      super(t, n, r, s, i, !0)
  }
  readKeyframes() {
      const {
          unresolvedKeyframes: t,
          element: n,
          name: r
      } = this;
      if (!n || !n.current) return;
      super.readKeyframes();
      for (let l = 0; l < t.length; l++) {
          let c = t[l];
          if (typeof c == "string" && (c = c.trim(), Gm(c))) {
              const u = A_(c, n.current);
              u !== void 0 && (t[l] = u), l === t.length - 1 && (this.finalKeyframe = c)
          }
      }
      if (this.resolveNoneKeyframes(), !N_.has(r) || t.length !== 2) return;
      const [s, i] = t, o = e0(s), a = e0(i);
      if (o !== a)
          if (Yv(o) && Yv(a))
              for (let l = 0; l < t.length; l++) {
                  const c = t[l];
                  typeof c == "string" && (t[l] = parseFloat(c))
              } else Fs[r] && (this.needsMeasurement = !0)
  }
  resolveNoneKeyframes() {
      const {
          unresolvedKeyframes: t,
          name: n
      } = this, r = [];
      for (let s = 0; s < t.length; s++)(t[s] === null || lM(t[s])) && r.push(s);
      r.length && mM(t, r, n)
  }
  measureInitialState() {
      const {
          element: t,
          unresolvedKeyframes: n,
          name: r
      } = this;
      if (!t || !t.current) return;
      r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Fs[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
      const s = n[n.length - 1];
      s !== void 0 && t.getValue(r, s).jump(s, !1)
  }
  measureEndState() {
      var a;
      const {
          element: t,
          name: n,
          unresolvedKeyframes: r
      } = this;
      if (!t || !t.current) return;
      const s = t.getValue(n);
      s && s.jump(this.measuredOrigin, !1);
      const i = r.length - 1,
          o = r[i];
      r[i] = Fs[n](t.measureViewportBox(), window.getComputedStyle(t.current)), o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o), (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach(([l, c]) => {
          t.getValue(l).set(c)
      }), this.resolveNoneKeyframes()
  }
}

function yM(e, t, n) {
  if (e instanceof EventTarget) return [e];
  if (typeof e == "string") {
      const s = document.querySelectorAll(e);
      return s ? Array.from(s) : []
  }
  return Array.from(e)
}
const M_ = (e, t) => t && typeof e == "number" ? t.transform(e) : e;

function L_(e) {
  return XS(e) && "offsetHeight" in e
}
const n0 = 30,
  vM = e => !isNaN(parseFloat(e));
class wM {
  constructor(t, n = {}) {
      this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => {
          var i;
          const s = wt.now();
          if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((i = this.events.change) == null || i.notify(this.current), this.dependents))
              for (const o of this.dependents) o.dirty()
      }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner
  }
  setCurrent(t) {
      this.current = t, this.updatedAt = wt.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = vM(this.current))
  }
  setPrevFrameValue(t = this.current) {
      this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt
  }
  onChange(t) {
      return this.on("change", t)
  }
  on(t, n) {
      this.events[t] || (this.events[t] = new Hm);
      const r = this.events[t].add(n);
      return t === "change" ? () => {
          r(), Se.read(() => {
              this.events.change.getSize() || this.stop()
          })
      } : r
  }
  clearListeners() {
      for (const t in this.events) this.events[t].clear()
  }
  attach(t, n) {
      this.passiveEffect = t, this.stopPassiveEffect = n
  }
  set(t) {
      this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t)
  }
  setWithVelocity(t, n, r) {
      this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r
  }
  jump(t, n = !0) {
      this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
  }
  dirty() {
      var t;
      (t = this.events.change) == null || t.notify(this.current)
  }
  addDependent(t) {
      this.dependents || (this.dependents = new Set), this.dependents.add(t)
  }
  removeDependent(t) {
      this.dependents && this.dependents.delete(t)
  }
  get() {
      return this.current
  }
  getPrevious() {
      return this.prev
  }
  getVelocity() {
      const t = wt.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > n0) return 0;
      const n = Math.min(this.updatedAt - this.prevUpdatedAt, n0);
      return e_(parseFloat(this.current) - parseFloat(this.prevFrameValue), n)
  }
  start(t) {
      return this.stop(), new Promise(n => {
          this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
          this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
      })
  }
  stop() {
      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
  }
  isAnimating() {
      return !!this.animation
  }
  clearAnimation() {
      delete this.animation
  }
  destroy() {
      var t, n;
      (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
  }
}

function vo(e, t) {
  return new wM(e, t)
}
const {
  schedule: ig,
  cancel: ZV
} = d_(queueMicrotask, !1), tn = {
  x: !1,
  y: !1
};

function $_() {
  return tn.x || tn.y
}

function xM(e) {
  return e === "x" || e === "y" ? tn[e] ? null : (tn[e] = !0, () => {
      tn[e] = !1
  }) : tn.x || tn.y ? null : (tn.x = tn.y = !0, () => {
      tn.x = tn.y = !1
  })
}

function F_(e, t) {
  const n = yM(e),
      r = new AbortController,
      s = {
          passive: !0,
          ...t,
          signal: r.signal
      };
  return [n, s, () => r.abort()]
}

function r0(e) {
  return !(e.pointerType === "touch" || $_())
}

function bM(e, t, n = {}) {
  const [r, s, i] = F_(e, n), o = a => {
      if (!r0(a)) return;
      const {
          target: l
      } = a, c = t(l, a);
      if (typeof c != "function" || !l) return;
      const u = d => {
          r0(d) && (c(d), l.removeEventListener("pointerleave", u))
      };
      l.addEventListener("pointerleave", u, s)
  };
  return r.forEach(a => {
      a.addEventListener("pointerenter", o, s)
  }), i
}
const U_ = (e, t) => t ? e === t ? !0 : U_(e, t.parentElement) : !1,
  og = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1,
  SM = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);

function _M(e) {
  return SM.has(e.tagName) || e.tabIndex !== -1
}
const gc = new WeakSet;

function s0(e) {
  return t => {
      t.key === "Enter" && e(t)
  }
}

function Wd(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, {
      isPrimary: !0,
      bubbles: !0
  }))
}
const EM = (e, t) => {
  const n = e.currentTarget;
  if (!n) return;
  const r = s0(() => {
      if (gc.has(n)) return;
      Wd(n, "down");
      const s = s0(() => {
              Wd(n, "up")
          }),
          i = () => Wd(n, "cancel");
      n.addEventListener("keyup", s, t), n.addEventListener("blur", i, t)
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t)
};

function i0(e) {
  return og(e) && !$_()
}

function CM(e, t, n = {}) {
  const [r, s, i] = F_(e, n), o = a => {
      const l = a.currentTarget;
      if (!i0(a)) return;
      gc.add(l);
      const c = t(l, a),
          u = (f, x) => {
              window.removeEventListener("pointerup", d), window.removeEventListener("pointercancel", h), gc.has(l) && gc.delete(l), i0(f) && typeof c == "function" && c(f, {
                  success: x
              })
          },
          d = f => {
              u(f, l === window || l === document || n.useGlobalTarget || U_(l, f.target))
          },
          h = f => {
              u(f, !1)
          };
      window.addEventListener("pointerup", d, s), window.addEventListener("pointercancel", h, s)
  };
  return r.forEach(a => {
      (n.useGlobalTarget ? window : a).addEventListener("pointerdown", o, s), L_(a) && (a.addEventListener("focus", c => EM(c, s)), !_M(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0))
  }), i
}

function V_(e) {
  return XS(e) && "ownerSVGElement" in e
}

function TM(e) {
  return V_(e) && e.tagName === "svg"
}
const nt = e => !!(e && e.getVelocity),
  kM = [...O_, De, es],
  RM = e => kM.find(j_(e)),
  ag = g.createContext({
      transformPagePoint: e => e,
      isStatic: !1,
      reducedMotion: "never"
  });

function o0(e, t) {
  if (typeof e == "function") return e(t);
  e != null && (e.current = t)
}

function PM(...e) {
  return t => {
      let n = !1;
      const r = e.map(s => {
          const i = o0(s, t);
          return !n && typeof i == "function" && (n = !0), i
      });
      if (n) return () => {
          for (let s = 0; s < r.length; s++) {
              const i = r[s];
              typeof i == "function" ? i() : o0(e[s], null)
          }
      }
  }
}

function AM(...e) {
  return g.useCallback(PM(...e), e)
}
class NM extends g.Component {
  getSnapshotBeforeUpdate(t) {
      const n = this.props.childRef.current;
      if (n && t.isPresent && !this.props.isPresent) {
          const r = n.offsetParent,
              s = L_(r) && r.offsetWidth || 0,
              i = this.props.sizeRef.current;
          i.height = n.offsetHeight || 0, i.width = n.offsetWidth || 0, i.top = n.offsetTop, i.left = n.offsetLeft, i.right = s - i.width - i.left
      }
      return null
  }
  componentDidUpdate() {}
  render() {
      return this.props.children
  }
}

function jM({
  children: e,
  isPresent: t,
  anchorX: n,
  root: r
}) {
  const s = g.useId(),
      i = g.useRef(null),
      o = g.useRef({
          width: 0,
          height: 0,
          top: 0,
          left: 0,
          right: 0
      }),
      {
          nonce: a
      } = g.useContext(ag),
      l = AM(i, e == null ? void 0 : e.ref);
  return g.useInsertionEffect(() => {
      const {
          width: c,
          height: u,
          top: d,
          left: h,
          right: f
      } = o.current;
      if (t || !i.current || !c || !u) return;
      const x = n === "left" ? `left: ${h}` : `right: ${f}`;
      i.current.dataset.motionPopId = s;
      const m = document.createElement("style");
      a && (m.nonce = a);
      const b = r ?? document.head;
      return b.appendChild(m), m.sheet && m.sheet.insertRule(`
        [data-motion-pop-id="${s}"] {
          position: absolute !important;
          width: ${c}px !important;
          height: ${u}px !important;
          ${x}px !important;
          top: ${d}px !important;
        }
      `), () => {
          b.contains(m) && b.removeChild(m)
      }
  }, [t]), p.jsx(NM, {
      isPresent: t,
      childRef: i,
      sizeRef: o,
      children: g.cloneElement(e, {
          ref: l
      })
  })
}
const OM = ({
  children: e,
  initial: t,
  isPresent: n,
  onExitComplete: r,
  custom: s,
  presenceAffectsLayout: i,
  mode: o,
  anchorX: a,
  root: l
}) => {
  const c = Um(IM),
      u = g.useId();
  let d = !0,
      h = g.useMemo(() => (d = !1, {
          id: u,
          initial: t,
          isPresent: n,
          custom: s,
          onExitComplete: f => {
              c.set(f, !0);
              for (const x of c.values())
                  if (!x) return;
              r && r()
          },
          register: f => (c.set(f, !1), () => c.delete(f))
      }), [n, c, r]);
  return i && d && (h = {
      ...h
  }), g.useMemo(() => {
      c.forEach((f, x) => c.set(x, !1))
  }, [n]), g.useEffect(() => {
      !n && !c.size && r && r()
  }, [n]), o === "popLayout" && (e = p.jsx(jM, {
      isPresent: n,
      anchorX: a,
      root: l,
      children: e
  })), p.jsx(Vu.Provider, {
      value: h,
      children: e
  })
};

function IM() {
  return new Map
}

function B_(e = !0) {
  const t = g.useContext(Vu);
  if (t === null) return [!0, null];
  const {
      isPresent: n,
      onExitComplete: r,
      register: s
  } = t, i = g.useId();
  g.useEffect(() => {
      if (e) return s(i)
  }, [e]);
  const o = g.useCallback(() => e && r && r(i), [i, r, e]);
  return !n && r ? [!1, o] : [!0]
}
const zl = e => e.key || "";

function a0(e) {
  const t = [];
  return g.Children.forEach(e, n => {
      g.isValidElement(n) && t.push(n)
  }), t
}
const Qf = ({
      children: e,
      custom: t,
      initial: n = !0,
      onExitComplete: r,
      presenceAffectsLayout: s = !0,
      mode: i = "sync",
      propagate: o = !1,
      anchorX: a = "left",
      root: l
  }) => {
      const [c, u] = B_(o), d = g.useMemo(() => a0(e), [e]), h = o && !c ? [] : d.map(zl), f = g.useRef(!0), x = g.useRef(d), m = Um(() => new Map), [b, v] = g.useState(d), [y, w] = g.useState(d);
      YS(() => {
          f.current = !1, x.current = d;
          for (let E = 0; E < y.length; E++) {
              const T = zl(y[E]);
              h.includes(T) ? m.delete(T) : m.get(T) !== !0 && m.set(T, !1)
          }
      }, [y, h.length, h.join("-")]);
      const S = [];
      if (d !== b) {
          let E = [...d];
          for (let T = 0; T < y.length; T++) {
              const k = y[T],
                  P = zl(k);
              h.includes(P) || (E.splice(T, 0, k), S.push(k))
          }
          return i === "wait" && S.length && (E = S), w(a0(E)), v(d), null
      }
      const {
          forceRender: _
      } = g.useContext(Fm);
      return p.jsx(p.Fragment, {
          children: y.map(E => {
              const T = zl(E),
                  k = o && !c ? !1 : d === y || h.includes(T),
                  P = () => {
                      if (m.has(T)) m.set(T, !0);
                      else return;
                      let A = !0;
                      m.forEach($ => {
                          $ || (A = !1)
                      }), A && (_ == null || _(), w(x.current), o && (u == null || u()), r && r())
                  };
              return p.jsx(OM, {
                  isPresent: k,
                  initial: !f.current || n ? void 0 : !1,
                  custom: t,
                  presenceAffectsLayout: s,
                  mode: i,
                  root: l,
                  onExitComplete: k ? void 0 : P,
                  anchorX: a,
                  children: E
              }, T)
          })
      })
  },
  z_ = g.createContext({
      strict: !1
  }),
  l0 = {
      animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
  },
  wo = {};
for (const e in l0) wo[e] = {
  isEnabled: t => l0[e].some(n => !!t[n])
};

function DM(e) {
  for (const t in e) wo[t] = {
      ...wo[t],
      ...e[t]
  }
}
const MM = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function su(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || MM.has(e)
}
let W_ = e => !su(e);

function LM(e) {
  typeof e == "function" && (W_ = t => t.startsWith("on") ? !su(t) : e(t))
}
try {
  LM(require("@emotion/is-prop-valid").default)
} catch {}

function $M(e, t, n) {
  const r = {};
  for (const s in e) s === "values" && typeof e.values == "object" || (W_(s) || n === !0 && su(s) || !t && !su(s) || e.draggable && s.startsWith("onDrag")) && (r[s] = e[s]);
  return r
}
const Bu = g.createContext({});

function zu(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function"
}

function Va(e) {
  return typeof e == "string" || Array.isArray(e)
}
const lg = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
  cg = ["initial", ...lg];

function Wu(e) {
  return zu(e.animate) || cg.some(t => Va(e[t]))
}

function H_(e) {
  return !!(Wu(e) || e.variants)
}

function FM(e, t) {
  if (Wu(e)) {
      const {
          initial: n,
          animate: r
      } = e;
      return {
          initial: n === !1 || Va(n) ? n : void 0,
          animate: Va(r) ? r : void 0
      }
  }
  return e.inherit !== !1 ? t : {}
}

function UM(e) {
  const {
      initial: t,
      animate: n
  } = FM(e, g.useContext(Bu));
  return g.useMemo(() => ({
      initial: t,
      animate: n
  }), [c0(t), c0(n)])
}

function c0(e) {
  return Array.isArray(e) ? e.join(" ") : e
}

function u0(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100
}
const Wo = {
      correct: (e, t) => {
          if (!t.target) return e;
          if (typeof e == "string")
              if (q.test(e)) e = parseFloat(e);
              else return e;
          const n = u0(e, t.target.x),
              r = u0(e, t.target.y);
          return `${n}% ${r}%`
      }
  },
  VM = {
      correct: (e, {
          treeScale: t,
          projectionDelta: n
      }) => {
          const r = e,
              s = es.parse(e);
          if (s.length > 5) return r;
          const i = es.createTransformer(e),
              o = typeof s[0] != "number" ? 1 : 0,
              a = n.x.scale * t.x,
              l = n.y.scale * t.y;
          s[0 + o] /= a, s[1 + o] /= l;
          const c = Ce(a, l, .5);
          return typeof s[2 + o] == "number" && (s[2 + o] /= c), typeof s[3 + o] == "number" && (s[3 + o] /= c), i(s)
      }
  },
  Yf = {
      borderRadius: {
          ...Wo,
          applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
      },
      borderTopLeftRadius: Wo,
      borderTopRightRadius: Wo,
      borderBottomLeftRadius: Wo,
      borderBottomRightRadius: Wo,
      boxShadow: VM
  };

function K_(e, {
  layout: t,
  layoutId: n
}) {
  return Ao.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Yf[e] || e === "opacity")
}
const BM = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
  },
  zM = Po.length;

function WM(e, t, n) {
  let r = "",
      s = !0;
  for (let i = 0; i < zM; i++) {
      const o = Po[i],
          a = e[o];
      if (a === void 0) continue;
      let l = !0;
      if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {
          const c = M_(a, sg[o]);
          if (!l) {
              s = !1;
              const u = BM[o] || o;
              r += `${u}(${c}) `
          }
          n && (t[o] = c)
      }
  }
  return r = r.trim(), n ? r = n(t, s ? "" : r) : s && (r = "none"), r
}

function ug(e, t, n) {
  const {
      style: r,
      vars: s,
      transformOrigin: i
  } = e;
  let o = !1,
      a = !1;
  for (const l in t) {
      const c = t[l];
      if (Ao.has(l)) {
          o = !0;
          continue
      } else if (f_(l)) {
          s[l] = c;
          continue
      } else {
          const u = M_(c, sg[l]);
          l.startsWith("origin") ? (a = !0, i[l] = u) : r[l] = u
      }
  }
  if (t.transform || (o || n ? r.transform = WM(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
      const {
          originX: l = "50%",
          originY: c = "50%",
          originZ: u = 0
      } = i;
      r.transformOrigin = `${l} ${c} ${u}`
  }
}
const dg = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

function q_(e, t, n) {
  for (const r in t) !nt(t[r]) && !K_(r, n) && (e[r] = t[r])
}

function HM({
  transformTemplate: e
}, t) {
  return g.useMemo(() => {
      const n = dg();
      return ug(n, t, e), Object.assign({}, n.vars, n.style)
  }, [t])
}

function KM(e, t) {
  const n = e.style || {},
      r = {};
  return q_(r, n, e), Object.assign(r, HM(e, t)), r
}

function qM(e, t) {
  const n = {},
      r = KM(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n
}
const GM = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
  },
  QM = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
  };

function YM(e, t, n = 1, r = 0, s = !0) {
  e.pathLength = 1;
  const i = s ? GM : QM;
  e[i.offset] = q.transform(-r);
  const o = q.transform(t),
      a = q.transform(n);
  e[i.array] = `${o} ${a}`
}

function G_(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: s,
  pathSpacing: i = 1,
  pathOffset: o = 0,
  ...a
}, l, c, u) {
  if (ug(e, a, c), l) {
      e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
      return
  }
  e.attrs = e.style, e.style = {};
  const {
      attrs: d,
      style: h
  } = e;
  d.transform && (h.transform = d.transform, delete d.transform), (h.transform || d.transformOrigin) && (h.transformOrigin = d.transformOrigin ?? "50% 50%", delete d.transformOrigin), h.transform && (h.transformBox = (u == null ? void 0 : u.transformBox) ?? "fill-box", delete d.transformBox), t !== void 0 && (d.x = t), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), s !== void 0 && YM(d, s, i, o, !1)
}
const Q_ = () => ({
      ...dg(),
      attrs: {}
  }),
  Y_ = e => typeof e == "string" && e.toLowerCase() === "svg";

function JM(e, t, n, r) {
  const s = g.useMemo(() => {
      const i = Q_();
      return G_(i, t, Y_(r), e.transformTemplate, e.style), {
          ...i.attrs,
          style: {
              ...i.style
          }
      }
  }, [t]);
  if (e.style) {
      const i = {};
      q_(i, e.style, e), s.style = {
          ...i,
          ...s.style
      }
  }
  return s
}
const XM = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function hg(e) {
  return typeof e != "string" || e.includes("-") ? !1 : !!(XM.indexOf(e) > -1 || /[A-Z]/u.test(e))
}

function ZM(e, t, n, {
  latestValues: r
}, s, i = !1) {
  const a = (hg(e) ? JM : qM)(t, r, s, e),
      l = $M(t, typeof e == "string", i),
      c = e !== g.Fragment ? {
          ...l,
          ...a,
          ref: n
      } : {},
      {
          children: u
      } = t,
      d = g.useMemo(() => nt(u) ? u.get() : u, [u]);
  return g.createElement(e, {
      ...c,
      children: d
  })
}

function d0(e) {
  const t = [{}, {}];
  return e == null || e.values.forEach((n, r) => {
      t[0][r] = n.get(), t[1][r] = n.getVelocity()
  }), t
}

function fg(e, t, n, r) {
  if (typeof t == "function") {
      const [s, i] = d0(r);
      t = t(n !== void 0 ? n : e.custom, s, i)
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
      const [s, i] = d0(r);
      t = t(n !== void 0 ? n : e.custom, s, i)
  }
  return t
}

function yc(e) {
  return nt(e) ? e.get() : e
}

function eL({
  scrapeMotionValuesFromProps: e,
  createRenderState: t
}, n, r, s) {
  return {
      latestValues: tL(n, r, s, e),
      renderState: t()
  }
}

function tL(e, t, n, r) {
  const s = {},
      i = r(e, {});
  for (const h in i) s[h] = yc(i[h]);
  let {
      initial: o,
      animate: a
  } = e;
  const l = Wu(e),
      c = H_(e);
  t && c && !l && e.inherit !== !1 && (o === void 0 && (o = t.initial), a === void 0 && (a = t.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || o === !1;
  const d = u ? a : o;
  if (d && typeof d != "boolean" && !zu(d)) {
      const h = Array.isArray(d) ? d : [d];
      for (let f = 0; f < h.length; f++) {
          const x = fg(e, h[f]);
          if (x) {
              const {
                  transitionEnd: m,
                  transition: b,
                  ...v
              } = x;
              for (const y in v) {
                  let w = v[y];
                  if (Array.isArray(w)) {
                      const S = u ? w.length - 1 : 0;
                      w = w[S]
                  }
                  w !== null && (s[y] = w)
              }
              for (const y in m) s[y] = m[y]
          }
      }
  }
  return s
}
const J_ = e => (t, n) => {
  const r = g.useContext(Bu),
      s = g.useContext(Vu),
      i = () => eL(e, t, r, s);
  return n ? i() : Um(i)
};

function pg(e, t, n) {
  var i;
  const {
      style: r
  } = e, s = {};
  for (const o in r)(nt(r[o]) || t.style && nt(t.style[o]) || K_(o, e) || ((i = n == null ? void 0 : n.getValue(o)) == null ? void 0 : i.liveStyle) !== void 0) && (s[o] = r[o]);
  return s
}
const nL = J_({
  scrapeMotionValuesFromProps: pg,
  createRenderState: dg
});

function X_(e, t, n) {
  const r = pg(e, t, n);
  for (const s in e)
      if (nt(e[s]) || nt(t[s])) {
          const i = Po.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
          r[i] = e[s]
      } return r
}
const rL = J_({
      scrapeMotionValuesFromProps: X_,
      createRenderState: Q_
  }),
  sL = Symbol.for("motionComponentSymbol");

function ji(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
}

function iL(e, t, n) {
  return g.useCallback(r => {
      r && e.onMount && e.onMount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : ji(n) && (n.current = r))
  }, [t])
}
const mg = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  oL = "framerAppearId",
  Z_ = "data-" + mg(oL),
  eE = g.createContext({});

function aL(e, t, n, r, s) {
  var m, b;
  const {
      visualElement: i
  } = g.useContext(Bu), o = g.useContext(z_), a = g.useContext(Vu), l = g.useContext(ag).reducedMotion, c = g.useRef(null);
  r = r || o.renderer, !c.current && r && (c.current = r(e, {
      visualState: t,
      parent: i,
      props: n,
      presenceContext: a,
      blockInitialAnimation: a ? a.initial === !1 : !1,
      reducedMotionConfig: l
  }));
  const u = c.current,
      d = g.useContext(eE);
  u && !u.projection && s && (u.type === "html" || u.type === "svg") && lL(c.current, n, s, d);
  const h = g.useRef(!1);
  g.useInsertionEffect(() => {
      u && h.current && u.update(n, a)
  });
  const f = n[Z_],
      x = g.useRef(!!f && !((m = window.MotionHandoffIsComplete) != null && m.call(window, f)) && ((b = window.MotionHasOptimisedAnimation) == null ? void 0 : b.call(window, f)));
  return YS(() => {
      u && (h.current = !0, window.MotionIsMounted = !0, u.updateFeatures(), u.scheduleRenderMicrotask(), x.current && u.animationState && u.animationState.animateChanges())
  }), g.useEffect(() => {
      u && (!x.current && u.animationState && u.animationState.animateChanges(), x.current && (queueMicrotask(() => {
          var v;
          (v = window.MotionHandoffMarkAsComplete) == null || v.call(window, f)
      }), x.current = !1), u.enteringChildren = void 0)
  }), u
}

function lL(e, t, n, r) {
  const {
      layoutId: s,
      layout: i,
      drag: o,
      dragConstraints: a,
      layoutScroll: l,
      layoutRoot: c,
      layoutCrossfade: u
  } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : tE(e.parent)), e.projection.setOptions({
      layoutId: s,
      layout: i,
      alwaysMeasureLayout: !!o || a && ji(a),
      visualElement: e,
      animationType: typeof i == "string" ? i : "both",
      initialPromotionConfig: r,
      crossfade: u,
      layoutScroll: l,
      layoutRoot: c
  })
}

function tE(e) {
  if (e) return e.options.allowProjection !== !1 ? e.projection : tE(e.parent)
}

function Hd(e, {
  forwardMotionProps: t = !1
} = {}, n, r) {
  n && DM(n);
  const s = hg(e) ? rL : nL;

  function i(a, l) {
      let c;
      const u = {
              ...g.useContext(ag),
              ...a,
              layoutId: cL(a)
          },
          {
              isStatic: d
          } = u,
          h = UM(a),
          f = s(a, d);
      if (!d && Vm) {
          uL();
          const x = dL(u);
          c = x.MeasureLayout, h.visualElement = aL(e, f, u, r, x.ProjectionNode)
      }
      return p.jsxs(Bu.Provider, {
          value: h,
          children: [c && h.visualElement ? p.jsx(c, {
              visualElement: h.visualElement,
              ...u
          }) : null, ZM(e, a, iL(f, h.visualElement, l), f, d, t)]
      })
  }
  i.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const o = g.forwardRef(i);
  return o[sL] = e, o
}

function cL({
  layoutId: e
}) {
  const t = g.useContext(Fm).id;
  return t && e !== void 0 ? t + "-" + e : e
}

function uL(e, t) {
  g.useContext(z_).strict
}

function dL(e) {
  const {
      drag: t,
      layout: n
  } = wo;
  if (!t && !n) return {};
  const r = {
      ...t,
      ...n
  };
  return {
      MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0,
      ProjectionNode: r.ProjectionNode
  }
}

function hL(e, t) {
  if (typeof Proxy > "u") return Hd;
  const n = new Map,
      r = (i, o) => Hd(i, o, e, t),
      s = (i, o) => r(i, o);
  return new Proxy(s, {
      get: (i, o) => o === "create" ? r : (n.has(o) || n.set(o, Hd(o, void 0, e, t)), n.get(o))
  })
}

function nE({
  top: e,
  left: t,
  right: n,
  bottom: r
}) {
  return {
      x: {
          min: t,
          max: n
      },
      y: {
          min: e,
          max: r
      }
  }
}

function fL({
  x: e,
  y: t
}) {
  return {
      top: t.min,
      right: e.max,
      bottom: t.max,
      left: e.min
  }
}

function pL(e, t) {
  if (!t) return e;
  const n = t({
          x: e.left,
          y: e.top
      }),
      r = t({
          x: e.right,
          y: e.bottom
      });
  return {
      top: n.y,
      left: n.x,
      bottom: r.y,
      right: r.x
  }
}

function Kd(e) {
  return e === void 0 || e === 1
}

function Jf({
  scale: e,
  scaleX: t,
  scaleY: n
}) {
  return !Kd(e) || !Kd(t) || !Kd(n)
}

function ps(e) {
  return Jf(e) || rE(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY
}

function rE(e) {
  return h0(e.x) || h0(e.y)
}

function h0(e) {
  return e && e !== "0%"
}

function iu(e, t, n) {
  const r = e - n,
      s = t * r;
  return n + s
}

function f0(e, t, n, r, s) {
  return s !== void 0 && (e = iu(e, s, r)), iu(e, n, r) + t
}

function Xf(e, t = 0, n = 1, r, s) {
  e.min = f0(e.min, t, n, r, s), e.max = f0(e.max, t, n, r, s)
}

function sE(e, {
  x: t,
  y: n
}) {
  Xf(e.x, t.translate, t.scale, t.originPoint), Xf(e.y, n.translate, n.scale, n.originPoint)
}
const p0 = .999999999999,
  m0 = 1.0000000000001;

function mL(e, t, n, r = !1) {
  const s = n.length;
  if (!s) return;
  t.x = t.y = 1;
  let i, o;
  for (let a = 0; a < s; a++) {
      i = n[a], o = i.projectionDelta;
      const {
          visualElement: l
      } = i.options;
      l && l.props.style && l.props.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && Ii(e, {
          x: -i.scroll.offset.x,
          y: -i.scroll.offset.y
      }), o && (t.x *= o.x.scale, t.y *= o.y.scale, sE(e, o)), r && ps(i.latestValues) && Ii(e, i.latestValues))
  }
  t.x < m0 && t.x > p0 && (t.x = 1), t.y < m0 && t.y > p0 && (t.y = 1)
}

function Oi(e, t) {
  e.min = e.min + t, e.max = e.max + t
}

function g0(e, t, n, r, s = .5) {
  const i = Ce(e.min, e.max, s);
  Xf(e, t, n, i, r)
}

function Ii(e, t) {
  g0(e.x, t.x, t.scaleX, t.scale, t.originX), g0(e.y, t.y, t.scaleY, t.scale, t.originY)
}

function iE(e, t) {
  return nE(pL(e.getBoundingClientRect(), t))
}

function gL(e, t, n) {
  const r = iE(e, n),
      {
          scroll: s
      } = t;
  return s && (Oi(r.x, s.offset.x), Oi(r.y, s.offset.y)), r
}
const y0 = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
  }),
  Di = () => ({
      x: y0(),
      y: y0()
  }),
  v0 = () => ({
      min: 0,
      max: 0
  }),
  Fe = () => ({
      x: v0(),
      y: v0()
  }),
  Zf = {
      current: null
  },
  oE = {
      current: !1
  };

function yL() {
  if (oE.current = !0, !!Vm)
      if (window.matchMedia) {
          const e = window.matchMedia("(prefers-reduced-motion)"),
              t = () => Zf.current = e.matches;
          e.addEventListener("change", t), t()
      } else Zf.current = !1
}
const vL = new WeakMap;

function wL(e, t, n) {
  for (const r in t) {
      const s = t[r],
          i = n[r];
      if (nt(s)) e.addValue(r, s);
      else if (nt(i)) e.addValue(r, vo(s, {
          owner: e
      }));
      else if (i !== s)
          if (e.hasValue(r)) {
              const o = e.getValue(r);
              o.liveStyle === !0 ? o.jump(s) : o.hasAnimated || o.set(s)
          } else {
              const o = e.getStaticValue(r);
              e.addValue(r, vo(o !== void 0 ? o : s, {
                  owner: e
              }))
          }
  }
  for (const r in n) t[r] === void 0 && e.removeValue(r);
  return t
}
const w0 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class xL {
  scrapeMotionValuesFromProps(t, n, r) {
      return {}
  }
  constructor({
      parent: t,
      props: n,
      presenceContext: r,
      reducedMotionConfig: s,
      blockInitialAnimation: i,
      visualState: o
  }, a = {}) {
      this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ng, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
          this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }, this.renderScheduledAt = 0, this.scheduleRender = () => {
          const h = wt.now();
          this.renderScheduledAt < h && (this.renderScheduledAt = h, Se.render(this.render, !1, !0))
      };
      const {
          latestValues: l,
          renderState: c
      } = o;
      this.latestValues = l, this.baseTarget = {
          ...l
      }, this.initialValues = n.initial ? {
          ...l
      } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = s, this.options = a, this.blockInitialAnimation = !!i, this.isControllingVariants = Wu(n), this.isVariantNode = H_(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current);
      const {
          willChange: u,
          ...d
      } = this.scrapeMotionValuesFromProps(n, {}, this);
      for (const h in d) {
          const f = d[h];
          l[h] !== void 0 && nt(f) && f.set(l[h])
      }
  }
  mount(t) {
      var n;
      this.current = t, vL.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, s) => this.bindToMotionValue(s, r)), oE.current || yL(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Zf.current, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext)
  }
  unmount() {
      var t;
      this.projection && this.projection.unmount(), Zr(this.notifyUpdate), Zr(this.render), this.valueSubscriptions.forEach(n => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this);
      for (const n in this.events) this.events[n].clear();
      for (const n in this.features) {
          const r = this.features[n];
          r && (r.unmount(), r.isMounted = !1)
      }
      this.current = null
  }
  addChild(t) {
      this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t)
  }
  removeChild(t) {
      this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t)
  }
  bindToMotionValue(t, n) {
      this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
      const r = Ao.has(t);
      r && this.onBindTransform && this.onBindTransform();
      const s = n.on("change", o => {
          this.latestValues[t] = o, this.props.onUpdate && Se.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender()
      });
      let i;
      window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
          s(), i && i(), n.owner && n.stop()
      })
  }
  sortNodePosition(t) {
      return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current)
  }
  updateFeatures() {
      let t = "animation";
      for (t in wo) {
          const n = wo[t];
          if (!n) continue;
          const {
              isEnabled: r,
              Feature: s
          } = n;
          if (!this.features[t] && s && r(this.props) && (this.features[t] = new s(this)), this.features[t]) {
              const i = this.features[t];
              i.isMounted ? i.update() : (i.mount(), i.isMounted = !0)
          }
      }
  }
  triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props)
  }
  measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Fe()
  }
  getStaticValue(t) {
      return this.latestValues[t]
  }
  setStaticValue(t, n) {
      this.latestValues[t] = n
  }
  update(t, n) {
      (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
      for (let r = 0; r < w0.length; r++) {
          const s = w0[r];
          this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
          const i = "on" + s,
              o = t[i];
          o && (this.propEventSubscriptions[s] = this.on(s, o))
      }
      this.prevMotionValues = wL(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
      return this.props
  }
  getVariant(t) {
      return this.props.variants ? this.props.variants[t] : void 0
  }
  getDefaultTransition() {
      return this.props.transition
  }
  getTransformPagePoint() {
      return this.props.transformPagePoint
  }
  getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
  }
  addVariantChild(t) {
      const n = this.getClosestVariantNode();
      if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t)
  }
  addValue(t, n) {
      const r = this.values.get(t);
      n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get())
  }
  removeValue(t) {
      this.values.delete(t);
      const n = this.valueSubscriptions.get(t);
      n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
  }
  hasValue(t) {
      return this.values.has(t)
  }
  getValue(t, n) {
      if (this.props.values && this.props.values[t]) return this.props.values[t];
      let r = this.values.get(t);
      return r === void 0 && n !== void 0 && (r = vo(n === null ? void 0 : n, {
          owner: this
      }), this.addValue(t, r)), r
  }
  readValue(t, n) {
      let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
      return r != null && (typeof r == "string" && (JS(r) || ZS(r)) ? r = parseFloat(r) : !RM(r) && es.test(n) && (r = D_(t, n)), this.setBaseTarget(t, nt(r) ? r.get() : r)), nt(r) ? r.get() : r
  }
  setBaseTarget(t, n) {
      this.baseTarget[t] = n
  }
  getBaseTarget(t) {
      var i;
      const {
          initial: n
      } = this.props;
      let r;
      if (typeof n == "string" || typeof n == "object") {
          const o = fg(this.props, n, (i = this.presenceContext) == null ? void 0 : i.custom);
          o && (r = o[t])
      }
      if (n && r !== void 0) return r;
      const s = this.getBaseTargetFromProps(this.props, t);
      return s !== void 0 && !nt(s) ? s : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t]
  }
  on(t, n) {
      return this.events[t] || (this.events[t] = new Hm), this.events[t].add(n)
  }
  notify(t, ...n) {
      this.events[t] && this.events[t].notify(...n)
  }
  scheduleRenderMicrotask() {
      ig.render(this.render)
  }
}
class aE extends xL {
  constructor() {
      super(...arguments), this.KeyframeResolver = gM
  }
  sortInstanceNodePosition(t, n) {
      return t.compareDocumentPosition(n) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(t, n) {
      return t.style ? t.style[n] : void 0
  }
  removeValueFromRenderState(t, {
      vars: n,
      style: r
  }) {
      delete n[t], delete r[t]
  }
  handleChildMotionValue() {
      this.childSubscription && (this.childSubscription(), delete this.childSubscription);
      const {
          children: t
      } = this.props;
      nt(t) && (this.childSubscription = t.on("change", n => {
          this.current && (this.current.textContent = `${n}`)
      }))
  }
}

function lE(e, {
  style: t,
  vars: n
}, r, s) {
  const i = e.style;
  let o;
  for (o in t) i[o] = t[o];
  s == null || s.applyProjectionStyles(i, r);
  for (o in n) i.setProperty(o, n[o])
}

function bL(e) {
  return window.getComputedStyle(e)
}
class SL extends aE {
  constructor() {
      super(...arguments), this.type = "html", this.renderInstance = lE
  }
  readValueFromInstance(t, n) {
      var r;
      if (Ao.has(n)) return (r = this.projection) != null && r.isProjecting ? Bf(n) : DD(t, n);
      {
          const s = bL(t),
              i = (f_(n) ? s.getPropertyValue(n) : s[n]) || 0;
          return typeof i == "string" ? i.trim() : i
      }
  }
  measureInstanceViewportBox(t, {
      transformPagePoint: n
  }) {
      return iE(t, n)
  }
  build(t, n, r) {
      ug(t, n, r.transformTemplate)
  }
  scrapeMotionValuesFromProps(t, n, r) {
      return pg(t, n, r)
  }
}
const cE = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function _L(e, t, n, r) {
  lE(e, t, void 0, r);
  for (const s in t.attrs) e.setAttribute(cE.has(s) ? s : mg(s), t.attrs[s])
}
class EL extends aE {
  constructor() {
      super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Fe
  }
  getBaseTargetFromProps(t, n) {
      return t[n]
  }
  readValueFromInstance(t, n) {
      if (Ao.has(n)) {
          const r = I_(n);
          return r && r.default || 0
      }
      return n = cE.has(n) ? n : mg(n), t.getAttribute(n)
  }
  scrapeMotionValuesFromProps(t, n, r) {
      return X_(t, n, r)
  }
  build(t, n, r) {
      G_(t, n, this.isSVGTag, r.transformTemplate, r.style)
  }
  renderInstance(t, n, r, s) {
      _L(t, n, r, s)
  }
  mount(t) {
      this.isSVGTag = Y_(t.tagName), super.mount(t)
  }
}
const CL = (e, t) => hg(e) ? new EL(t) : new SL(t, {
  allowProjection: e !== g.Fragment
});

function Ki(e, t, n) {
  const r = e.getProps();
  return fg(r, t, n !== void 0 ? n : r.custom, e)
}
const ep = e => Array.isArray(e);

function TL(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, vo(n))
}

function kL(e) {
  return ep(e) ? e[e.length - 1] || 0 : e
}

function RL(e, t) {
  const n = Ki(e, t);
  let {
      transitionEnd: r = {},
      transition: s = {},
      ...i
  } = n || {};
  i = {
      ...i,
      ...r
  };
  for (const o in i) {
      const a = kL(i[o]);
      TL(e, o, a)
  }
}

function PL(e) {
  return !!(nt(e) && e.add)
}

function tp(e, t) {
  const n = e.getValue("willChange");
  if (PL(n)) return n.add(t);
  if (!n && Zn.WillChange) {
      const r = new Zn.WillChange("auto");
      e.addValue("willChange", r), r.add(t)
  }
}

function uE(e) {
  return e.props[Z_]
}
const AL = e => e !== null;

function NL(e, {
  repeat: t,
  repeatType: n = "loop"
}, r) {
  const s = e.filter(AL),
      i = t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !i || r === void 0 ? s[i] : r
}
const jL = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
  },
  OL = e => ({
      type: "spring",
      stiffness: 550,
      damping: e === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
  }),
  IL = {
      type: "keyframes",
      duration: .8
  },
  DL = {
      type: "keyframes",
      ease: [.25, .1, .35, 1],
      duration: .3
  },
  ML = (e, {
      keyframes: t
  }) => t.length > 2 ? IL : Ao.has(e) ? e.startsWith("scale") ? OL(t[1]) : jL : DL;

function LL({
  when: e,
  delay: t,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: s,
  repeat: i,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length
}
const gg = (e, t, n, r = {}, s, i) => o => {
  const a = rg(r, e) || {},
      l = a.delay || r.delay || 0;
  let {
      elapsed: c = 0
  } = r;
  c = c - Pn(l);
  const u = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: "easeOut",
      velocity: t.getVelocity(),
      ...a,
      delay: -c,
      onUpdate: h => {
          t.set(h), a.onUpdate && a.onUpdate(h)
      },
      onComplete: () => {
          o(), a.onComplete && a.onComplete()
      },
      name: e,
      motionValue: t,
      element: i ? void 0 : s
  };
  LL(a) || Object.assign(u, ML(e, u)), u.duration && (u.duration = Pn(u.duration)), u.repeatDelay && (u.repeatDelay = Pn(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
  let d = !1;
  if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (qf(u), u.delay === 0 && (d = !0)), (Zn.instantAnimations || Zn.skipAnimations) && (d = !0, qf(u), u.delay = 0), u.allowFlatten = !a.type && !a.ease, d && !i && t.get() !== void 0) {
      const h = NL(u.keyframes, a);
      if (h !== void 0) {
          Se.update(() => {
              u.onUpdate(h), u.onComplete()
          });
          return
      }
  }
  return a.isSync ? new tg(u) : new sM(u)
};

function $L({
  protectedKeys: e,
  needsAnimating: t
}, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r
}

function dE(e, t, {
  delay: n = 0,
  transitionOverride: r,
  type: s
} = {}) {
  let {
      transition: i = e.getDefaultTransition(),
      transitionEnd: o,
      ...a
  } = t;
  r && (i = r);
  const l = [],
      c = s && e.animationState && e.animationState.getState()[s];
  for (const u in a) {
      const d = e.getValue(u, e.latestValues[u] ?? null),
          h = a[u];
      if (h === void 0 || c && $L(c, u)) continue;
      const f = {
              delay: n,
              ...rg(i || {}, u)
          },
          x = d.get();
      if (x !== void 0 && !d.isAnimating && !Array.isArray(h) && h === x && !f.velocity) continue;
      let m = !1;
      if (window.MotionHandoffAnimation) {
          const v = uE(e);
          if (v) {
              const y = window.MotionHandoffAnimation(v, u, Se);
              y !== null && (f.startTime = y, m = !0)
          }
      }
      tp(e, u), d.start(gg(u, d, h, e.shouldReduceMotion && N_.has(u) ? {
          type: !1
      } : f, e, m));
      const b = d.animation;
      b && l.push(b)
  }
  return o && Promise.all(l).then(() => {
      Se.update(() => {
          o && RL(e, o)
      })
  }), l
}

function hE(e, t, n, r = 0, s = 1) {
  const i = Array.from(e).sort((c, u) => c.sortNodePosition(u)).indexOf(t),
      o = e.size,
      a = (o - 1) * r;
  return typeof n == "function" ? n(i, o) : s === 1 ? i * r : a - i * r
}

function np(e, t, n = {}) {
  var l;
  const r = Ki(e, t, n.type === "exit" ? (l = e.presenceContext) == null ? void 0 : l.custom : void 0);
  let {
      transition: s = e.getDefaultTransition() || {}
  } = r || {};
  n.transitionOverride && (s = n.transitionOverride);
  const i = r ? () => Promise.all(dE(e, r, n)) : () => Promise.resolve(),
      o = e.variantChildren && e.variantChildren.size ? (c = 0) => {
          const {
              delayChildren: u = 0,
              staggerChildren: d,
              staggerDirection: h
          } = s;
          return FL(e, t, c, u, d, h, n)
      } : () => Promise.resolve(),
      {
          when: a
      } = s;
  if (a) {
      const [c, u] = a === "beforeChildren" ? [i, o] : [o, i];
      return c().then(() => u())
  } else return Promise.all([i(), o(n.delay)])
}

function FL(e, t, n = 0, r = 0, s = 0, i = 1, o) {
  const a = [];
  for (const l of e.variantChildren) l.notify("AnimationStart", t), a.push(np(l, t, {
      ...o,
      delay: n + (typeof r == "function" ? 0 : r) + hE(e.variantChildren, l, r, s, i)
  }).then(() => l.notify("AnimationComplete", t)));
  return Promise.all(a)
}

function UL(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
      const s = t.map(i => np(e, i, n));
      r = Promise.all(s)
  } else if (typeof t == "string") r = np(e, t, n);
  else {
      const s = typeof t == "function" ? Ki(e, t, n.custom) : t;
      r = Promise.all(dE(e, s, n))
  }
  return r.then(() => {
      e.notify("AnimationComplete", t)
  })
}

function fE(e, t) {
  if (!Array.isArray(t)) return !1;
  const n = t.length;
  if (n !== e.length) return !1;
  for (let r = 0; r < n; r++)
      if (t[r] !== e[r]) return !1;
  return !0
}
const VL = cg.length;

function pE(e) {
  if (!e) return;
  if (!e.isControllingVariants) {
      const n = e.parent ? pE(e.parent) || {} : {};
      return e.props.initial !== void 0 && (n.initial = e.props.initial), n
  }
  const t = {};
  for (let n = 0; n < VL; n++) {
      const r = cg[n],
          s = e.props[r];
      (Va(s) || s === !1) && (t[r] = s)
  }
  return t
}
const BL = [...lg].reverse(),
  zL = lg.length;

function WL(e) {
  return t => Promise.all(t.map(({
      animation: n,
      options: r
  }) => UL(e, n, r)))
}

function HL(e) {
  let t = WL(e),
      n = x0(),
      r = !0;
  const s = l => (c, u) => {
      var h;
      const d = Ki(e, u, l === "exit" ? (h = e.presenceContext) == null ? void 0 : h.custom : void 0);
      if (d) {
          const {
              transition: f,
              transitionEnd: x,
              ...m
          } = d;
          c = {
              ...c,
              ...m,
              ...x
          }
      }
      return c
  };

  function i(l) {
      t = l(e)
  }

  function o(l) {
      const {
          props: c
      } = e, u = pE(e.parent) || {}, d = [], h = new Set;
      let f = {},
          x = 1 / 0;
      for (let b = 0; b < zL; b++) {
          const v = BL[b],
              y = n[v],
              w = c[v] !== void 0 ? c[v] : u[v],
              S = Va(w),
              _ = v === l ? y.isActive : null;
          _ === !1 && (x = b);
          let E = w === u[v] && w !== c[v] && S;
          if (E && r && e.manuallyAnimateOnMount && (E = !1), y.protectedKeys = {
                  ...f
              }, !y.isActive && _ === null || !w && !y.prevProp || zu(w) || typeof w == "boolean") continue;
          const T = KL(y.prevProp, w);
          let k = T || v === l && y.isActive && !E && S || b > x && S,
              P = !1;
          const A = Array.isArray(w) ? w : [w];
          let $ = A.reduce(s(v), {});
          _ === !1 && ($ = {});
          const {
              prevResolvedValues: I = {}
          } = y, G = {
              ...I,
              ...$
          }, D = U => {
              k = !0, h.has(U) && (P = !0, h.delete(U)), y.needsAnimating[U] = !0;
              const R = e.getValue(U);
              R && (R.liveStyle = !1)
          };
          for (const U in G) {
              const R = $[U],
                  N = I[U];
              if (f.hasOwnProperty(U)) continue;
              let M = !1;
              ep(R) && ep(N) ? M = !fE(R, N) : M = R !== N, M ? R != null ? D(U) : h.add(U) : R !== void 0 && h.has(U) ? D(U) : y.protectedKeys[U] = !0
          }
          y.prevProp = w, y.prevResolvedValues = $, y.isActive && (f = {
              ...f,
              ...$
          }), r && e.blockInitialAnimation && (k = !1);
          const X = E && T;
          k && (!X || P) && d.push(...A.map(U => {
              const R = {
                  type: v
              };
              if (typeof U == "string" && r && !X && e.manuallyAnimateOnMount && e.parent) {
                  const {
                      parent: N
                  } = e, M = Ki(N, U);
                  if (N.enteringChildren && M) {
                      const {
                          delayChildren: Q
                      } = M.transition || {};
                      R.delay = hE(N.enteringChildren, e, Q)
                  }
              }
              return {
                  animation: U,
                  options: R
              }
          }))
      }
      if (h.size) {
          const b = {};
          if (typeof c.initial != "boolean") {
              const v = Ki(e, Array.isArray(c.initial) ? c.initial[0] : c.initial);
              v && v.transition && (b.transition = v.transition)
          }
          h.forEach(v => {
              const y = e.getBaseTarget(v),
                  w = e.getValue(v);
              w && (w.liveStyle = !0), b[v] = y ?? null
          }), d.push({
              animation: b
          })
      }
      let m = !!d.length;
      return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (m = !1), r = !1, m ? t(d) : Promise.resolve()
  }

  function a(l, c) {
      var d;
      if (n[l].isActive === c) return Promise.resolve();
      (d = e.variantChildren) == null || d.forEach(h => {
          var f;
          return (f = h.animationState) == null ? void 0 : f.setActive(l, c)
      }), n[l].isActive = c;
      const u = o(l);
      for (const h in n) n[h].protectedKeys = {};
      return u
  }
  return {
      animateChanges: o,
      setActive: a,
      setAnimateFunction: i,
      getState: () => n,
      reset: () => {
          n = x0()
      }
  }
}

function KL(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !fE(t, e) : !1
}

function cs(e = !1) {
  return {
      isActive: e,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
  }
}

function x0() {
  return {
      animate: cs(!0),
      whileInView: cs(),
      whileHover: cs(),
      whileTap: cs(),
      whileDrag: cs(),
      whileFocus: cs(),
      exit: cs()
  }
}
class is {
  constructor(t) {
      this.isMounted = !1, this.node = t
  }
  update() {}
}
class qL extends is {
  constructor(t) {
      super(t), t.animationState || (t.animationState = HL(t))
  }
  updateAnimationControlsSubscription() {
      const {
          animate: t
      } = this.node.getProps();
      zu(t) && (this.unmountControls = t.subscribe(this.node))
  }
  mount() {
      this.updateAnimationControlsSubscription()
  }
  update() {
      const {
          animate: t
      } = this.node.getProps(), {
          animate: n
      } = this.node.prevProps || {};
      t !== n && this.updateAnimationControlsSubscription()
  }
  unmount() {
      var t;
      this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this)
  }
}
let GL = 0;
class QL extends is {
  constructor() {
      super(...arguments), this.id = GL++
  }
  update() {
      if (!this.node.presenceContext) return;
      const {
          isPresent: t,
          onExitComplete: n
      } = this.node.presenceContext, {
          isPresent: r
      } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || t === r) return;
      const s = this.node.animationState.setActive("exit", !t);
      n && !t && s.then(() => {
          n(this.id)
      })
  }
  mount() {
      const {
          register: t,
          onExitComplete: n
      } = this.node.presenceContext || {};
      n && n(this.id), t && (this.unmount = t(this.id))
  }
  unmount() {}
}
const YL = {
  animation: {
      Feature: qL
  },
  exit: {
      Feature: QL
  }
};

function Ba(e, t, n, r = {
  passive: !0
}) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n)
}

function hl(e) {
  return {
      point: {
          x: e.pageX,
          y: e.pageY
      }
  }
}
const JL = e => t => og(t) && e(t, hl(t));

function da(e, t, n, r) {
  return Ba(e, t, JL(n), r)
}
const mE = 1e-4,
  XL = 1 - mE,
  ZL = 1 + mE,
  gE = .01,
  e$ = 0 - gE,
  t$ = 0 + gE;

function lt(e) {
  return e.max - e.min
}

function n$(e, t, n) {
  return Math.abs(e - t) <= n
}

function b0(e, t, n, r = .5) {
  e.origin = r, e.originPoint = Ce(t.min, t.max, e.origin), e.scale = lt(n) / lt(t), e.translate = Ce(n.min, n.max, e.origin) - e.originPoint, (e.scale >= XL && e.scale <= ZL || isNaN(e.scale)) && (e.scale = 1), (e.translate >= e$ && e.translate <= t$ || isNaN(e.translate)) && (e.translate = 0)
}

function ha(e, t, n, r) {
  b0(e.x, t.x, n.x, r ? r.originX : void 0), b0(e.y, t.y, n.y, r ? r.originY : void 0)
}

function S0(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + lt(t)
}

function r$(e, t, n) {
  S0(e.x, t.x, n.x), S0(e.y, t.y, n.y)
}

function _0(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + lt(t)
}

function ou(e, t, n) {
  _0(e.x, t.x, n.x), _0(e.y, t.y, n.y)
}

function Dt(e) {
  return [e("x"), e("y")]
}
const yE = ({
      current: e
  }) => e ? e.ownerDocument.defaultView : null,
  E0 = (e, t) => Math.abs(e - t);

function s$(e, t) {
  const n = E0(e.x, t.x),
      r = E0(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2)
}
class vE {
  constructor(t, n, {
      transformPagePoint: r,
      contextWindow: s = window,
      dragSnapToOrigin: i = !1,
      distanceThreshold: o = 3
  } = {}) {
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
              if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
              const h = Gd(this.lastMoveEventInfo, this.history),
                  f = this.startEvent !== null,
                  x = s$(h.offset, {
                      x: 0,
                      y: 0
                  }) >= this.distanceThreshold;
              if (!f && !x) return;
              const {
                  point: m
              } = h, {
                  timestamp: b
              } = Ge;
              this.history.push({
                  ...m,
                  timestamp: b
              });
              const {
                  onStart: v,
                  onMove: y
              } = this.handlers;
              f || (v && v(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, h)
          }, this.handlePointerMove = (h, f) => {
              this.lastMoveEvent = h, this.lastMoveEventInfo = qd(f, this.transformPagePoint), Se.update(this.updatePoint, !0)
          }, this.handlePointerUp = (h, f) => {
              this.end();
              const {
                  onEnd: x,
                  onSessionEnd: m,
                  resumeAnimation: b
              } = this.handlers;
              if (this.dragSnapToOrigin && b && b(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
              const v = Gd(h.type === "pointercancel" ? this.lastMoveEventInfo : qd(f, this.transformPagePoint), this.history);
              this.startEvent && x && x(h, v), m && m(h, v)
          }, !og(t)) return;
      this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = o, this.contextWindow = s || window;
      const a = hl(t),
          l = qd(a, this.transformPagePoint),
          {
              point: c
          } = l,
          {
              timestamp: u
          } = Ge;
      this.history = [{
          ...c,
          timestamp: u
      }];
      const {
          onSessionStart: d
      } = n;
      d && d(t, Gd(l, this.history)), this.removeListeners = cl(da(this.contextWindow, "pointermove", this.handlePointerMove), da(this.contextWindow, "pointerup", this.handlePointerUp), da(this.contextWindow, "pointercancel", this.handlePointerUp))
  }
  updateHandlers(t) {
      this.handlers = t
  }
  end() {
      this.removeListeners && this.removeListeners(), Zr(this.updatePoint)
  }
}

function qd(e, t) {
  return t ? {
      point: t(e.point)
  } : e
}

function C0(e, t) {
  return {
      x: e.x - t.x,
      y: e.y - t.y
  }
}

function Gd({
  point: e
}, t) {
  return {
      point: e,
      delta: C0(e, wE(t)),
      offset: C0(e, i$(t)),
      velocity: o$(t, .1)
  }
}

function i$(e) {
  return e[0]
}

function wE(e) {
  return e[e.length - 1]
}

function o$(e, t) {
  if (e.length < 2) return {
      x: 0,
      y: 0
  };
  let n = e.length - 1,
      r = null;
  const s = wE(e);
  for (; n >= 0 && (r = e[n], !(s.timestamp - r.timestamp > Pn(t)));) n--;
  if (!r) return {
      x: 0,
      y: 0
  };
  const i = Vt(s.timestamp - r.timestamp);
  if (i === 0) return {
      x: 0,
      y: 0
  };
  const o = {
      x: (s.x - r.x) / i,
      y: (s.y - r.y) / i
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}

function a$(e, {
  min: t,
  max: n
}, r) {
  return t !== void 0 && e < t ? e = r ? Ce(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Ce(n, e, r.max) : Math.min(e, n)), e
}

function T0(e, t, n) {
  return {
      min: t !== void 0 ? e.min + t : void 0,
      max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  }
}

function l$(e, {
  top: t,
  left: n,
  bottom: r,
  right: s
}) {
  return {
      x: T0(e.x, n, s),
      y: T0(e.y, t, r)
  }
}

function k0(e, t) {
  let n = t.min - e.min,
      r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), {
      min: n,
      max: r
  }
}

function c$(e, t) {
  return {
      x: k0(e.x, t.x),
      y: k0(e.y, t.y)
  }
}

function u$(e, t) {
  let n = .5;
  const r = lt(e),
      s = lt(t);
  return s > r ? n = $a(t.min, t.max - r, e.min) : r > s && (n = $a(e.min, e.max - s, t.min)), Xn(0, 1, n)
}

function d$(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n
}
const rp = .35;

function h$(e = rp) {
  return e === !1 ? e = 0 : e === !0 && (e = rp), {
      x: R0(e, "left", "right"),
      y: R0(e, "top", "bottom")
  }
}

function R0(e, t, n) {
  return {
      min: P0(e, t),
      max: P0(e, n)
  }
}

function P0(e, t) {
  return typeof e == "number" ? e : e[t] || 0
}
const f$ = new WeakMap;
class p$ {
  constructor(t) {
      this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
          x: 0,
          y: 0
      }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Fe(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t
  }
  start(t, {
      snapToCursor: n = !1,
      distanceThreshold: r
  } = {}) {
      const {
          presenceContext: s
      } = this.visualElement;
      if (s && s.isPresent === !1) return;
      const i = d => {
              const {
                  dragSnapToOrigin: h
              } = this.getProps();
              h ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(hl(d).point)
          },
          o = (d, h) => {
              const {
                  drag: f,
                  dragPropagation: x,
                  onDragStart: m
              } = this.getProps();
              if (f && !x && (this.openDragLock && this.openDragLock(), this.openDragLock = xM(f), !this.openDragLock)) return;
              this.latestPointerEvent = d, this.latestPanInfo = h, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Dt(v => {
                  let y = this.getAxisMotionValue(v).get() || 0;
                  if (An.test(y)) {
                      const {
                          projection: w
                      } = this.visualElement;
                      if (w && w.layout) {
                          const S = w.layout.layoutBox[v];
                          S && (y = lt(S) * (parseFloat(y) / 100))
                      }
                  }
                  this.originPoint[v] = y
              }), m && Se.postRender(() => m(d, h)), tp(this.visualElement, "transform");
              const {
                  animationState: b
              } = this.visualElement;
              b && b.setActive("whileDrag", !0)
          },
          a = (d, h) => {
              this.latestPointerEvent = d, this.latestPanInfo = h;
              const {
                  dragPropagation: f,
                  dragDirectionLock: x,
                  onDirectionLock: m,
                  onDrag: b
              } = this.getProps();
              if (!f && !this.openDragLock) return;
              const {
                  offset: v
              } = h;
              if (x && this.currentDirection === null) {
                  this.currentDirection = m$(v), this.currentDirection !== null && m && m(this.currentDirection);
                  return
              }
              this.updateAxis("x", h.point, v), this.updateAxis("y", h.point, v), this.visualElement.render(), b && b(d, h)
          },
          l = (d, h) => {
              this.latestPointerEvent = d, this.latestPanInfo = h, this.stop(d, h), this.latestPointerEvent = null, this.latestPanInfo = null
          },
          c = () => Dt(d => {
              var h;
              return this.getAnimationState(d) === "paused" && ((h = this.getAxisMotionValue(d).animation) == null ? void 0 : h.play())
          }),
          {
              dragSnapToOrigin: u
          } = this.getProps();
      this.panSession = new vE(t, {
          onSessionStart: i,
          onStart: o,
          onMove: a,
          onSessionEnd: l,
          resumeAnimation: c
      }, {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin: u,
          distanceThreshold: r,
          contextWindow: yE(this.visualElement)
      })
  }
  stop(t, n) {
      const r = t || this.latestPointerEvent,
          s = n || this.latestPanInfo,
          i = this.isDragging;
      if (this.cancel(), !i || !s || !r) return;
      const {
          velocity: o
      } = s;
      this.startAnimation(o);
      const {
          onDragEnd: a
      } = this.getProps();
      a && Se.postRender(() => a(r, s))
  }
  cancel() {
      this.isDragging = !1;
      const {
          projection: t,
          animationState: n
      } = this.visualElement;
      t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
      const {
          dragPropagation: r
      } = this.getProps();
      !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1)
  }
  updateAxis(t, n, r) {
      const {
          drag: s
      } = this.getProps();
      if (!r || !Wl(t, s, this.currentDirection)) return;
      const i = this.getAxisMotionValue(t);
      let o = this.originPoint[t] + r[t];
      this.constraints && this.constraints[t] && (o = a$(o, this.constraints[t], this.elastic[t])), i.set(o)
  }
  resolveConstraints() {
      var i;
      const {
          dragConstraints: t,
          dragElastic: n
      } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (i = this.visualElement.projection) == null ? void 0 : i.layout, s = this.constraints;
      t && ji(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = l$(r.layoutBox, t) : this.constraints = !1, this.elastic = h$(n), s !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Dt(o => {
          this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = d$(r.layoutBox[o], this.constraints[o]))
      })
  }
  resolveRefConstraints() {
      const {
          dragConstraints: t,
          onMeasureDragConstraints: n
      } = this.getProps();
      if (!t || !ji(t)) return !1;
      const r = t.current,
          {
              projection: s
          } = this.visualElement;
      if (!s || !s.layout) return !1;
      const i = gL(r, s.root, this.visualElement.getTransformPagePoint());
      let o = c$(s.layout.layoutBox, i);
      if (n) {
          const a = n(fL(o));
          this.hasMutatedConstraints = !!a, a && (o = nE(a))
      }
      return o
  }
  startAnimation(t) {
      const {
          drag: n,
          dragMomentum: r,
          dragElastic: s,
          dragTransition: i,
          dragSnapToOrigin: o,
          onDragTransitionEnd: a
      } = this.getProps(), l = this.constraints || {}, c = Dt(u => {
          if (!Wl(u, n, this.currentDirection)) return;
          let d = l && l[u] || {};
          o && (d = {
              min: 0,
              max: 0
          });
          const h = s ? 200 : 1e6,
              f = s ? 40 : 1e7,
              x = {
                  type: "inertia",
                  velocity: r ? t[u] : 0,
                  bounceStiffness: h,
                  bounceDamping: f,
                  timeConstant: 750,
                  restDelta: 1,
                  restSpeed: 10,
                  ...i,
                  ...d
              };
          return this.startAxisValueAnimation(u, x)
      });
      return Promise.all(c).then(a)
  }
  startAxisValueAnimation(t, n) {
      const r = this.getAxisMotionValue(t);
      return tp(this.visualElement, t), r.start(gg(t, r, 0, n, this.visualElement, !1))
  }
  stopAnimation() {
      Dt(t => this.getAxisMotionValue(t).stop())
  }
  pauseAnimation() {
      Dt(t => {
          var n;
          return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause()
      })
  }
  getAnimationState(t) {
      var n;
      return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state
  }
  getAxisMotionValue(t) {
      const n = `_drag${t.toUpperCase()}`,
          r = this.visualElement.getProps(),
          s = r[n];
      return s || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0)
  }
  snapToCursor(t) {
      Dt(n => {
          const {
              drag: r
          } = this.getProps();
          if (!Wl(n, r, this.currentDirection)) return;
          const {
              projection: s
          } = this.visualElement, i = this.getAxisMotionValue(n);
          if (s && s.layout) {
              const {
                  min: o,
                  max: a
              } = s.layout.layoutBox[n];
              i.set(t[n] - Ce(o, a, .5))
          }
      })
  }
  scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const {
          drag: t,
          dragConstraints: n
      } = this.getProps(), {
          projection: r
      } = this.visualElement;
      if (!ji(n) || !r || !this.constraints) return;
      this.stopAnimation();
      const s = {
          x: 0,
          y: 0
      };
      Dt(o => {
          const a = this.getAxisMotionValue(o);
          if (a && this.constraints !== !1) {
              const l = a.get();
              s[o] = u$({
                  min: l,
                  max: l
              }, this.constraints[o])
          }
      });
      const {
          transformTemplate: i
      } = this.visualElement.getProps();
      this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Dt(o => {
          if (!Wl(o, t, null)) return;
          const a = this.getAxisMotionValue(o),
              {
                  min: l,
                  max: c
              } = this.constraints[o];
          a.set(Ce(l, c, s[o]))
      })
  }
  addListeners() {
      if (!this.visualElement.current) return;
      f$.set(this.visualElement, this);
      const t = this.visualElement.current,
          n = da(t, "pointerdown", l => {
              const {
                  drag: c,
                  dragListener: u = !0
              } = this.getProps();
              c && u && this.start(l)
          }),
          r = () => {
              const {
                  dragConstraints: l
              } = this.getProps();
              ji(l) && l.current && (this.constraints = this.resolveRefConstraints())
          },
          {
              projection: s
          } = this.visualElement,
          i = s.addEventListener("measure", r);
      s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), Se.read(r);
      const o = Ba(window, "resize", () => this.scalePositionWithinConstraints()),
          a = s.addEventListener("didUpdate", ({
              delta: l,
              hasLayoutChanged: c
          }) => {
              this.isDragging && c && (Dt(u => {
                  const d = this.getAxisMotionValue(u);
                  d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate))
              }), this.visualElement.render())
          });
      return () => {
          o(), n(), i(), a && a()
      }
  }
  getProps() {
      const t = this.visualElement.getProps(),
          {
              drag: n = !1,
              dragDirectionLock: r = !1,
              dragPropagation: s = !1,
              dragConstraints: i = !1,
              dragElastic: o = rp,
              dragMomentum: a = !0
          } = t;
      return {
          ...t,
          drag: n,
          dragDirectionLock: r,
          dragPropagation: s,
          dragConstraints: i,
          dragElastic: o,
          dragMomentum: a
      }
  }
}

function Wl(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e)
}

function m$(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n
}
class g$ extends is {
  constructor(t) {
      super(t), this.removeGroupControls = zt, this.removeListeners = zt, this.controls = new p$(t)
  }
  mount() {
      const {
          dragControls: t
      } = this.node.getProps();
      t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || zt
  }
  unmount() {
      this.removeGroupControls(), this.removeListeners()
  }
}
const A0 = e => (t, n) => {
  e && Se.postRender(() => e(t, n))
};
class y$ extends is {
  constructor() {
      super(...arguments), this.removePointerDownListener = zt
  }
  onPointerDown(t) {
      this.session = new vE(t, this.createPanHandlers(), {
          transformPagePoint: this.node.getTransformPagePoint(),
          contextWindow: yE(this.node)
      })
  }
  createPanHandlers() {
      const {
          onPanSessionStart: t,
          onPanStart: n,
          onPan: r,
          onPanEnd: s
      } = this.node.getProps();
      return {
          onSessionStart: A0(t),
          onStart: A0(n),
          onMove: r,
          onEnd: (i, o) => {
              delete this.session, s && Se.postRender(() => s(i, o))
          }
      }
  }
  mount() {
      this.removePointerDownListener = da(this.node.current, "pointerdown", t => this.onPointerDown(t))
  }
  update() {
      this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
      this.removePointerDownListener(), this.session && this.session.end()
  }
}
const vc = {
  hasAnimatedSinceResize: !0,
  hasEverUpdated: !1
};
let Qd = !1;
class v$ extends g.Component {
  componentDidMount() {
      const {
          visualElement: t,
          layoutGroup: n,
          switchLayoutGroup: r,
          layoutId: s
      } = this.props, {
          projection: i
      } = t;
      i && (n.group && n.group.add(i), r && r.register && s && r.register(i), Qd && i.root.didUpdate(), i.addEventListener("animationComplete", () => {
          this.safeToRemove()
      }), i.setOptions({
          ...i.options,
          onExitComplete: () => this.safeToRemove()
      })), vc.hasEverUpdated = !0
  }
  getSnapshotBeforeUpdate(t) {
      const {
          layoutDependency: n,
          visualElement: r,
          drag: s,
          isPresent: i
      } = this.props, {
          projection: o
      } = r;
      return o && (o.isPresent = i, Qd = !0, s || t.layoutDependency !== n || n === void 0 || t.isPresent !== i ? o.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? o.promote() : o.relegate() || Se.postRender(() => {
          const a = o.getStack();
          (!a || !a.members.length) && this.safeToRemove()
      }))), null
  }
  componentDidUpdate() {
      const {
          projection: t
      } = this.props.visualElement;
      t && (t.root.didUpdate(), ig.postRender(() => {
          !t.currentAnimation && t.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
      const {
          visualElement: t,
          layoutGroup: n,
          switchLayoutGroup: r
      } = this.props, {
          projection: s
      } = t;
      Qd = !0, s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s))
  }
  safeToRemove() {
      const {
          safeToRemove: t
      } = this.props;
      t && t()
  }
  render() {
      return null
  }
}

function xE(e) {
  const [t, n] = B_(), r = g.useContext(Fm);
  return p.jsx(v$, {
      ...e,
      layoutGroup: r,
      switchLayoutGroup: g.useContext(eE),
      isPresent: t,
      safeToRemove: n
  })
}

function w$(e, t, n) {
  const r = nt(e) ? e : vo(e);
  return r.start(gg("", r, t, n)), r.animation
}
const x$ = (e, t) => e.depth - t.depth;
class b$ {
  constructor() {
      this.children = [], this.isDirty = !1
  }
  add(t) {
      Bm(this.children, t), this.isDirty = !0
  }
  remove(t) {
      zm(this.children, t), this.isDirty = !0
  }
  forEach(t) {
      this.isDirty && this.children.sort(x$), this.isDirty = !1, this.children.forEach(t)
  }
}

function S$(e, t) {
  const n = wt.now(),
      r = ({
          timestamp: s
      }) => {
          const i = s - n;
          i >= t && (Zr(r), e(i - t))
      };
  return Se.setup(r, !0), () => Zr(r)
}
const bE = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  _$ = bE.length,
  N0 = e => typeof e == "string" ? parseFloat(e) : e,
  j0 = e => typeof e == "number" || q.test(e);

function E$(e, t, n, r, s, i) {
  s ? (e.opacity = Ce(0, n.opacity ?? 1, C$(r)), e.opacityExit = Ce(t.opacity ?? 1, 0, T$(r))) : i && (e.opacity = Ce(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let o = 0; o < _$; o++) {
      const a = `border${bE[o]}Radius`;
      let l = O0(t, a),
          c = O0(n, a);
      if (l === void 0 && c === void 0) continue;
      l || (l = 0), c || (c = 0), l === 0 || c === 0 || j0(l) === j0(c) ? (e[a] = Math.max(Ce(N0(l), N0(c), r), 0), (An.test(c) || An.test(l)) && (e[a] += "%")) : e[a] = c
  }(t.rotate || n.rotate) && (e.rotate = Ce(t.rotate || 0, n.rotate || 0, r))
}

function O0(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius
}
const C$ = SE(0, .5, a_),
  T$ = SE(.5, .95, zt);

function SE(e, t, n) {
  return r => r < e ? 0 : r > t ? 1 : n($a(e, t, r))
}

function I0(e, t) {
  e.min = t.min, e.max = t.max
}

function Xt(e, t) {
  I0(e.x, t.x), I0(e.y, t.y)
}

function D0(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin
}

function M0(e, t, n, r, s) {
  return e -= t, e = iu(e, 1 / n, r), s !== void 0 && (e = iu(e, 1 / s, r)), e
}

function k$(e, t = 0, n = 1, r = .5, s, i = e, o = e) {
  if (An.test(t) && (t = parseFloat(t), t = Ce(o.min, o.max, t / 100) - o.min), typeof t != "number") return;
  let a = Ce(i.min, i.max, r);
  e === i && (a -= t), e.min = M0(e.min, t, n, a, s), e.max = M0(e.max, t, n, a, s)
}

function L0(e, t, [n, r, s], i, o) {
  k$(e, t[n], t[r], t[s], t.scale, i, o)
}
const R$ = ["x", "scaleX", "originX"],
  P$ = ["y", "scaleY", "originY"];

function $0(e, t, n, r) {
  L0(e.x, t, R$, n ? n.x : void 0, r ? r.x : void 0), L0(e.y, t, P$, n ? n.y : void 0, r ? r.y : void 0)
}

function F0(e) {
  return e.translate === 0 && e.scale === 1
}

function _E(e) {
  return F0(e.x) && F0(e.y)
}

function U0(e, t) {
  return e.min === t.min && e.max === t.max
}

function A$(e, t) {
  return U0(e.x, t.x) && U0(e.y, t.y)
}

function V0(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max)
}

function EE(e, t) {
  return V0(e.x, t.x) && V0(e.y, t.y)
}

function B0(e) {
  return lt(e.x) / lt(e.y)
}

function z0(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint
}
class N$ {
  constructor() {
      this.members = []
  }
  add(t) {
      Bm(this.members, t), t.scheduleRender()
  }
  remove(t) {
      if (zm(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
          const n = this.members[this.members.length - 1];
          n && this.promote(n)
      }
  }
  relegate(t) {
      const n = this.members.findIndex(s => t === s);
      if (n === 0) return !1;
      let r;
      for (let s = n; s >= 0; s--) {
          const i = this.members[s];
          if (i.isPresent !== !1) {
              r = i;
              break
          }
      }
      return r ? (this.promote(r), !0) : !1
  }
  promote(t, n) {
      const r = this.lead;
      if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
          r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
          const {
              crossfade: s
          } = t.options;
          s === !1 && r.hide()
      }
  }
  exitAnimationComplete() {
      this.members.forEach(t => {
          const {
              options: n,
              resumingFrom: r
          } = t;
          n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete()
      })
  }
  scheduleRender() {
      this.members.forEach(t => {
          t.instance && t.scheduleRender(!1)
      })
  }
  removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}

function j$(e, t, n) {
  let r = "";
  const s = e.x.translate / t.x,
      i = e.y.translate / t.y,
      o = (n == null ? void 0 : n.z) || 0;
  if ((s || i || o) && (r = `translate3d(${s}px, ${i}px, ${o}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
      const {
          transformPerspective: c,
          rotate: u,
          rotateX: d,
          rotateY: h,
          skewX: f,
          skewY: x
      } = n;
      c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), d && (r += `rotateX(${d}deg) `), h && (r += `rotateY(${h}deg) `), f && (r += `skewX(${f}deg) `), x && (r += `skewY(${x}deg) `)
  }
  const a = e.x.scale * t.x,
      l = e.y.scale * t.y;
  return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none"
}
const Yd = ["", "X", "Y", "Z"],
  O$ = 1e3;
let I$ = 0;

function Jd(e, t, n, r) {
  const {
      latestValues: s
  } = t;
  s[e] && (n[e] = s[e], t.setStaticValue(e, 0), r && (r[e] = 0))
}

function CE(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e) return;
  const {
      visualElement: t
  } = e.options;
  if (!t) return;
  const n = uE(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
      const {
          layout: s,
          layoutId: i
      } = e.options;
      window.MotionCancelOptimisedAnimation(n, "transform", Se, !(s || i))
  }
  const {
      parent: r
  } = e;
  r && !r.hasCheckedOptimisedAppear && CE(r)
}

function TE({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: s
}) {
  return class {
      constructor(o = {}, a = t == null ? void 0 : t()) {
          this.id = I$++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
              x: 1,
              y: 1
          }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
              this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
          }, this.updateProjection = () => {
              this.projectionUpdateScheduled = !1, this.nodes.forEach(L$), this.nodes.forEach(V$), this.nodes.forEach(B$), this.nodes.forEach($$)
          }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
          for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
          this.root === this && (this.nodes = new b$)
      }
      addEventListener(o, a) {
          return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Hm), this.eventHandlers.get(o).add(a)
      }
      notifyListeners(o, ...a) {
          const l = this.eventHandlers.get(o);
          l && l.notify(...a)
      }
      hasListeners(o) {
          return this.eventHandlers.has(o)
      }
      mount(o) {
          if (this.instance) return;
          this.isSVG = V_(o) && !TM(o), this.instance = o;
          const {
              layoutId: a,
              layout: l,
              visualElement: c
          } = this.options;
          if (c && !c.current && c.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), e) {
              let u, d = 0;
              const h = () => this.root.updateBlockedByResize = !1;
              Se.read(() => {
                  d = window.innerWidth
              }), e(o, () => {
                  const f = window.innerWidth;
                  f !== d && (d = f, this.root.updateBlockedByResize = !0, u && u(), u = S$(h, 250), vc.hasAnimatedSinceResize && (vc.hasAnimatedSinceResize = !1, this.nodes.forEach(K0)))
              })
          }
          a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && c && (a || l) && this.addEventListener("didUpdate", ({
              delta: u,
              hasLayoutChanged: d,
              hasRelativeLayoutChanged: h,
              layout: f
          }) => {
              if (this.isTreeAnimationBlocked()) {
                  this.target = void 0, this.relativeTarget = void 0;
                  return
              }
              const x = this.options.transition || c.getDefaultTransition() || q$,
                  {
                      onLayoutAnimationStart: m,
                      onLayoutAnimationComplete: b
                  } = c.getProps(),
                  v = !this.targetLayout || !EE(this.targetLayout, f),
                  y = !d && h;
              if (this.options.layoutRoot || this.resumeFrom || y || d && (v || !this.currentAnimation)) {
                  this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
                  const w = {
                      ...rg(x, "layout"),
                      onPlay: m,
                      onComplete: b
                  };
                  (c.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0, w.type = !1), this.startAnimation(w), this.setAnimationOrigin(u, y)
              } else d || K0(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
              this.targetLayout = f
          })
      }
      unmount() {
          this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
          const o = this.getStack();
          o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Zr(this.updateProjection)
      }
      blockUpdate() {
          this.updateManuallyBlocked = !0
      }
      unblockUpdate() {
          this.updateManuallyBlocked = !1
      }
      isUpdateBlocked() {
          return this.updateManuallyBlocked || this.updateBlockedByResize
      }
      isTreeAnimationBlocked() {
          return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
      }
      startUpdate() {
          this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(z$), this.animationId++)
      }
      getTransformTemplate() {
          const {
              visualElement: o
          } = this.options;
          return o && o.getProps().transformTemplate
      }
      willUpdate(o = !0) {
          if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
              this.options.onExitComplete && this.options.onExitComplete();
              return
          }
          if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && CE(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
          this.isLayoutDirty = !0;
          for (let u = 0; u < this.path.length; u++) {
              const d = this.path[u];
              d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1)
          }
          const {
              layoutId: a,
              layout: l
          } = this.options;
          if (a === void 0 && !l) return;
          const c = this.getTransformTemplate();
          this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
      }
      update() {
          if (this.updateScheduled = !1, this.isUpdateBlocked()) {
              this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(W0);
              return
          }
          if (this.animationId <= this.animationCommitId) {
              this.nodes.forEach(H0);
              return
          }
          this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(U$), this.nodes.forEach(D$), this.nodes.forEach(M$)) : this.nodes.forEach(H0), this.clearAllSnapshots();
          const a = wt.now();
          Ge.delta = Xn(0, 1e3 / 60, a - Ge.timestamp), Ge.timestamp = a, Ge.isProcessing = !0, Fd.update.process(Ge), Fd.preRender.process(Ge), Fd.render.process(Ge), Ge.isProcessing = !1
      }
      didUpdate() {
          this.updateScheduled || (this.updateScheduled = !0, ig.read(this.scheduleUpdate))
      }
      clearAllSnapshots() {
          this.nodes.forEach(F$), this.sharedNodes.forEach(W$)
      }
      scheduleUpdateProjection() {
          this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Se.preRender(this.updateProjection, !1, !0))
      }
      scheduleCheckAfterUnmount() {
          Se.postRender(() => {
              this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
          })
      }
      updateSnapshot() {
          this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !lt(this.snapshot.measuredBox.x) && !lt(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
      }
      updateLayout() {
          if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
          if (this.resumeFrom && !this.resumeFrom.instance)
              for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
          const o = this.layout;
          this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Fe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
          const {
              visualElement: a
          } = this.options;
          a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
      }
      updateScroll(o = "measure") {
          let a = !!(this.options.layoutScroll && this.instance);
          if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && this.instance) {
              const l = r(this.instance);
              this.scroll = {
                  animationId: this.root.animationId,
                  phase: o,
                  isRoot: l,
                  offset: n(this.instance),
                  wasRoot: this.scroll ? this.scroll.isRoot : l
              }
          }
      }
      resetTransform() {
          if (!s) return;
          const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
              a = this.projectionDelta && !_E(this.projectionDelta),
              l = this.getTransformTemplate(),
              c = l ? l(this.latestValues, "") : void 0,
              u = c !== this.prevTransformTemplateValue;
          o && this.instance && (a || ps(this.latestValues) || u) && (s(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender())
      }
      measure(o = !0) {
          const a = this.measurePageBox();
          let l = this.removeElementScroll(a);
          return o && (l = this.removeTransform(l)), G$(l), {
              animationId: this.root.animationId,
              measuredBox: a,
              layoutBox: l,
              latestValues: {},
              source: this.id
          }
      }
      measurePageBox() {
          var c;
          const {
              visualElement: o
          } = this.options;
          if (!o) return Fe();
          const a = o.measureViewportBox();
          if (!(((c = this.scroll) == null ? void 0 : c.wasRoot) || this.path.some(Q$))) {
              const {
                  scroll: u
              } = this.root;
              u && (Oi(a.x, u.offset.x), Oi(a.y, u.offset.y))
          }
          return a
      }
      removeElementScroll(o) {
          var l;
          const a = Fe();
          if (Xt(a, o), (l = this.scroll) != null && l.wasRoot) return a;
          for (let c = 0; c < this.path.length; c++) {
              const u = this.path[c],
                  {
                      scroll: d,
                      options: h
                  } = u;
              u !== this.root && d && h.layoutScroll && (d.wasRoot && Xt(a, o), Oi(a.x, d.offset.x), Oi(a.y, d.offset.y))
          }
          return a
      }
      applyTransform(o, a = !1) {
          const l = Fe();
          Xt(l, o);
          for (let c = 0; c < this.path.length; c++) {
              const u = this.path[c];
              !a && u.options.layoutScroll && u.scroll && u !== u.root && Ii(l, {
                  x: -u.scroll.offset.x,
                  y: -u.scroll.offset.y
              }), ps(u.latestValues) && Ii(l, u.latestValues)
          }
          return ps(this.latestValues) && Ii(l, this.latestValues), l
      }
      removeTransform(o) {
          const a = Fe();
          Xt(a, o);
          for (let l = 0; l < this.path.length; l++) {
              const c = this.path[l];
              if (!c.instance || !ps(c.latestValues)) continue;
              Jf(c.latestValues) && c.updateSnapshot();
              const u = Fe(),
                  d = c.measurePageBox();
              Xt(u, d), $0(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
          }
          return ps(this.latestValues) && $0(a, this.latestValues), a
      }
      setTargetDelta(o) {
          this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
      }
      setOptions(o) {
          this.options = {
              ...this.options,
              ...o,
              crossfade: o.crossfade !== void 0 ? o.crossfade : !0
          }
      }
      clearMeasurements() {
          this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
      }
      forceRelativeParentToResolveTarget() {
          this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ge.timestamp && this.relativeParent.resolveTargetDelta(!0)
      }
      resolveTargetDelta(o = !1) {
          var f;
          const a = this.getLead();
          this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
          const l = !!this.resumingFrom || this !== a;
          if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || (f = this.parent) != null && f.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
          const {
              layout: u,
              layoutId: d
          } = this.options;
          if (!this.layout || !(u || d)) return;
          this.resolvedRelativeTargetAt = Ge.timestamp;
          const h = this.getClosestProjectingParent();
          h && this.linkedParentVersion !== h.layoutVersion && !h.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (h && h.layout ? this.createRelativeTarget(h, this.layout.layoutBox, h.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Fe(), this.targetWithTransforms = Fe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), r$(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Xt(this.target, this.layout.layoutBox), sE(this.target, this.targetDelta)) : Xt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? this.createRelativeTarget(h, this.target, h.target) : this.relativeParent = this.relativeTarget = void 0))
      }
      getClosestProjectingParent() {
          if (!(!this.parent || Jf(this.parent.latestValues) || rE(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
      }
      isProjecting() {
          return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
      }
      createRelativeTarget(o, a, l) {
          this.relativeParent = o, this.linkedParentVersion = o.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Fe(), this.relativeTargetOrigin = Fe(), ou(this.relativeTargetOrigin, a, l), Xt(this.relativeTarget, this.relativeTargetOrigin)
      }
      removeRelativeTarget() {
          this.relativeParent = this.relativeTarget = void 0
      }
      calcProjection() {
          var x;
          const o = this.getLead(),
              a = !!this.resumingFrom || this !== o;
          let l = !0;
          if ((this.isProjectionDirty || (x = this.parent) != null && x.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Ge.timestamp && (l = !1), l) return;
          const {
              layout: c,
              layoutId: u
          } = this.options;
          if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(c || u)) return;
          Xt(this.layoutCorrected, this.layout.layoutBox);
          const d = this.treeScale.x,
              h = this.treeScale.y;
          mL(this.layoutCorrected, this.treeScale, this.path, a), o.layout && !o.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (o.target = o.layout.layoutBox, o.targetWithTransforms = Fe());
          const {
              target: f
          } = o;
          if (!f) {
              this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
              return
          }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (D0(this.prevProjectionDelta.x, this.projectionDelta.x), D0(this.prevProjectionDelta.y, this.projectionDelta.y)), ha(this.projectionDelta, this.layoutCorrected, f, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== h || !z0(this.projectionDelta.x, this.prevProjectionDelta.x) || !z0(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", f))
      }
      hide() {
          this.isVisible = !1
      }
      show() {
          this.isVisible = !0
      }
      scheduleRender(o = !0) {
          var a;
          if ((a = this.options.visualElement) == null || a.scheduleRender(), o) {
              const l = this.getStack();
              l && l.scheduleRender()
          }
          this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
      }
      createProjectionDeltas() {
          this.prevProjectionDelta = Di(), this.projectionDelta = Di(), this.projectionDeltaWithTransform = Di()
      }
      setAnimationOrigin(o, a = !1) {
          const l = this.snapshot,
              c = l ? l.latestValues : {},
              u = {
                  ...this.latestValues
              },
              d = Di();
          (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
          const h = Fe(),
              f = l ? l.source : void 0,
              x = this.layout ? this.layout.source : void 0,
              m = f !== x,
              b = this.getStack(),
              v = !b || b.members.length <= 1,
              y = !!(m && !v && this.options.crossfade === !0 && !this.path.some(K$));
          this.animationProgress = 0;
          let w;
          this.mixTargetDelta = S => {
              const _ = S / 1e3;
              q0(d.x, o.x, _), q0(d.y, o.y, _), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ou(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), H$(this.relativeTarget, this.relativeTargetOrigin, h, _), w && A$(this.relativeTarget, w) && (this.isProjectionDirty = !1), w || (w = Fe()), Xt(w, this.relativeTarget)), m && (this.animationValues = u, E$(u, c, this.latestValues, _, y, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = _
          }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
      }
      startAnimation(o) {
          var a, l, c;
          this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || c.stop(), this.pendingAnimation && (Zr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Se.update(() => {
              vc.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = vo(0)), this.currentAnimation = w$(this.motionValue, [0, 1e3], {
                  ...o,
                  velocity: 0,
                  isSync: !0,
                  onUpdate: u => {
                      this.mixTargetDelta(u), o.onUpdate && o.onUpdate(u)
                  },
                  onStop: () => {},
                  onComplete: () => {
                      o.onComplete && o.onComplete(), this.completeAnimation()
                  }
              }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
          })
      }
      completeAnimation() {
          this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
          const o = this.getStack();
          o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
      }
      finishAnimation() {
          this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(O$), this.currentAnimation.stop()), this.completeAnimation()
      }
      applyTransformsToTarget() {
          const o = this.getLead();
          let {
              targetWithTransforms: a,
              target: l,
              layout: c,
              latestValues: u
          } = o;
          if (!(!a || !l || !c)) {
              if (this !== o && this.layout && c && kE(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                  l = this.target || Fe();
                  const d = lt(this.layout.layoutBox.x);
                  l.x.min = o.target.x.min, l.x.max = l.x.min + d;
                  const h = lt(this.layout.layoutBox.y);
                  l.y.min = o.target.y.min, l.y.max = l.y.min + h
              }
              Xt(a, l), Ii(a, u), ha(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
          }
      }
      registerSharedNode(o, a) {
          this.sharedNodes.has(o) || this.sharedNodes.set(o, new N$), this.sharedNodes.get(o).add(a);
          const c = a.options.initialPromotionConfig;
          a.promote({
              transition: c ? c.transition : void 0,
              preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
          })
      }
      isLead() {
          const o = this.getStack();
          return o ? o.lead === this : !0
      }
      getLead() {
          var a;
          const {
              layoutId: o
          } = this.options;
          return o ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this
      }
      getPrevLead() {
          var a;
          const {
              layoutId: o
          } = this.options;
          return o ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0
      }
      getStack() {
          const {
              layoutId: o
          } = this.options;
          if (o) return this.root.sharedNodes.get(o)
      }
      promote({
          needsReset: o,
          transition: a,
          preserveFollowOpacity: l
      } = {}) {
          const c = this.getStack();
          c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
              transition: a
          })
      }
      relegate() {
          const o = this.getStack();
          return o ? o.relegate(this) : !1
      }
      resetSkewAndRotation() {
          const {
              visualElement: o
          } = this.options;
          if (!o) return;
          let a = !1;
          const {
              latestValues: l
          } = o;
          if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return;
          const c = {};
          l.z && Jd("z", o, c, this.animationValues);
          for (let u = 0; u < Yd.length; u++) Jd(`rotate${Yd[u]}`, o, c, this.animationValues), Jd(`skew${Yd[u]}`, o, c, this.animationValues);
          o.render();
          for (const u in c) o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
          o.scheduleRender()
      }
      applyProjectionStyles(o, a) {
          if (!this.instance || this.isSVG) return;
          if (!this.isVisible) {
              o.visibility = "hidden";
              return
          }
          const l = this.getTransformTemplate();
          if (this.needsReset) {
              this.needsReset = !1, o.visibility = "", o.opacity = "", o.pointerEvents = yc(a == null ? void 0 : a.pointerEvents) || "", o.transform = l ? l(this.latestValues, "") : "none";
              return
          }
          const c = this.getLead();
          if (!this.projectionDelta || !this.layout || !c.target) {
              this.options.layoutId && (o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, o.pointerEvents = yc(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !ps(this.latestValues) && (o.transform = l ? l({}, "") : "none", this.hasProjected = !1);
              return
          }
          o.visibility = "";
          const u = c.animationValues || c.latestValues;
          this.applyTransformsToTarget();
          let d = j$(this.projectionDeltaWithTransform, this.treeScale, u);
          l && (d = l(u, d)), o.transform = d;
          const {
              x: h,
              y: f
          } = this.projectionDelta;
          o.transformOrigin = `${h.origin * 100}% ${f.origin * 100}% 0`, c.animationValues ? o.opacity = c === this ? u.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : u.opacityExit : o.opacity = c === this ? u.opacity !== void 0 ? u.opacity : "" : u.opacityExit !== void 0 ? u.opacityExit : 0;
          for (const x in Yf) {
              if (u[x] === void 0) continue;
              const {
                  correct: m,
                  applyTo: b,
                  isCSSVariable: v
              } = Yf[x], y = d === "none" ? u[x] : m(u[x], c);
              if (b) {
                  const w = b.length;
                  for (let S = 0; S < w; S++) o[b[S]] = y
              } else v ? this.options.visualElement.renderState.vars[x] = y : o[x] = y
          }
          this.options.layoutId && (o.pointerEvents = c === this ? yc(a == null ? void 0 : a.pointerEvents) || "" : "none")
      }
      clearSnapshot() {
          this.resumeFrom = this.snapshot = void 0
      }
      resetTree() {
          this.root.nodes.forEach(o => {
              var a;
              return (a = o.currentAnimation) == null ? void 0 : a.stop()
          }), this.root.nodes.forEach(W0), this.root.sharedNodes.clear()
      }
  }
}

function D$(e) {
  e.updateLayout()
}

function M$(e) {
  var n;
  const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
      const {
          layoutBox: r,
          measuredBox: s
      } = e.layout, {
          animationType: i
      } = e.options, o = t.source !== e.layout.source;
      i === "size" ? Dt(d => {
          const h = o ? t.measuredBox[d] : t.layoutBox[d],
              f = lt(h);
          h.min = r[d].min, h.max = h.min + f
      }) : kE(i, t.layoutBox, r) && Dt(d => {
          const h = o ? t.measuredBox[d] : t.layoutBox[d],
              f = lt(r[d]);
          h.max = h.min + f, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + f)
      });
      const a = Di();
      ha(a, r, t.layoutBox);
      const l = Di();
      o ? ha(l, e.applyTransform(s, !0), t.measuredBox) : ha(l, r, t.layoutBox);
      const c = !_E(a);
      let u = !1;
      if (!e.resumeFrom) {
          const d = e.getClosestProjectingParent();
          if (d && !d.resumeFrom) {
              const {
                  snapshot: h,
                  layout: f
              } = d;
              if (h && f) {
                  const x = Fe();
                  ou(x, t.layoutBox, h.layoutBox);
                  const m = Fe();
                  ou(m, r, f.layoutBox), EE(x, m) || (u = !0), d.options.layoutRoot && (e.relativeTarget = m, e.relativeTargetOrigin = x, e.relativeParent = d)
              }
          }
      }
      e.notifyListeners("didUpdate", {
          layout: r,
          snapshot: t,
          delta: l,
          layoutDelta: a,
          hasLayoutChanged: c,
          hasRelativeLayoutChanged: u
      })
  } else if (e.isLead()) {
      const {
          onExitComplete: r
      } = e.options;
      r && r()
  }
  e.options.transition = void 0
}

function L$(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}

function $$(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}

function F$(e) {
  e.clearSnapshot()
}

function W0(e) {
  e.clearMeasurements()
}

function H0(e) {
  e.isLayoutDirty = !1
}

function U$(e) {
  const {
      visualElement: t
  } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform()
}

function K0(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0
}

function V$(e) {
  e.resolveTargetDelta()
}

function B$(e) {
  e.calcProjection()
}

function z$(e) {
  e.resetSkewAndRotation()
}

function W$(e) {
  e.removeLeadSnapshot()
}

function q0(e, t, n) {
  e.translate = Ce(t.translate, 0, n), e.scale = Ce(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint
}

function G0(e, t, n, r) {
  e.min = Ce(t.min, n.min, r), e.max = Ce(t.max, n.max, r)
}

function H$(e, t, n, r) {
  G0(e.x, t.x, n.x, r), G0(e.y, t.y, n.y, r)
}

function K$(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0
}
const q$ = {
      duration: .45,
      ease: [.4, 0, .1, 1]
  },
  Q0 = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e),
  Y0 = Q0("applewebkit/") && !Q0("chrome/") ? Math.round : zt;

function J0(e) {
  e.min = Y0(e.min), e.max = Y0(e.max)
}

function G$(e) {
  J0(e.x), J0(e.y)
}

function kE(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !n$(B0(t), B0(n), .2)
}

function Q$(e) {
  var t;
  return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot)
}
const Y$ = TE({
      attachResizeListener: (e, t) => Ba(e, "resize", t),
      measureScroll: () => ({
          x: document.documentElement.scrollLeft || document.body.scrollLeft,
          y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => !0
  }),
  Xd = {
      current: void 0
  },
  RE = TE({
      measureScroll: e => ({
          x: e.scrollLeft,
          y: e.scrollTop
      }),
      defaultParent: () => {
          if (!Xd.current) {
              const e = new Y$({});
              e.mount(window), e.setOptions({
                  layoutScroll: !0
              }), Xd.current = e
          }
          return Xd.current
      },
      resetTransform: (e, t) => {
          e.style.transform = t !== void 0 ? t : "none"
      },
      checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed"
  }),
  J$ = {
      pan: {
          Feature: y$
      },
      drag: {
          Feature: g$,
          ProjectionNode: RE,
          MeasureLayout: xE
      }
  };

function X0(e, t, n) {
  const {
      props: r
  } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const s = "onHover" + n,
      i = r[s];
  i && Se.postRender(() => i(t, hl(t)))
}
class X$ extends is {
  mount() {
      const {
          current: t
      } = this.node;
      t && (this.unmount = bM(t, (n, r) => (X0(this.node, r, "Start"), s => X0(this.node, s, "End"))))
  }
  unmount() {}
}
class Z$ extends is {
  constructor() {
      super(...arguments), this.isActive = !1
  }
  onFocus() {
      let t = !1;
      try {
          t = this.node.current.matches(":focus-visible")
      } catch {
          t = !0
      }!t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
  }
  onBlur() {
      !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
  }
  mount() {
      this.unmount = cl(Ba(this.node.current, "focus", () => this.onFocus()), Ba(this.node.current, "blur", () => this.onBlur()))
  }
  unmount() {}
}

function Z0(e, t, n) {
  const {
      props: r
  } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled) return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const s = "onTap" + (n === "End" ? "" : n),
      i = r[s];
  i && Se.postRender(() => i(t, hl(t)))
}
class eF extends is {
  mount() {
      const {
          current: t
      } = this.node;
      t && (this.unmount = CM(t, (n, r) => (Z0(this.node, r, "Start"), (s, {
          success: i
      }) => Z0(this.node, s, i ? "End" : "Cancel")), {
          useGlobalTarget: this.node.props.globalTapTarget
      }))
  }
  unmount() {}
}
const sp = new WeakMap,
  Zd = new WeakMap,
  tF = e => {
      const t = sp.get(e.target);
      t && t(e)
  },
  nF = e => {
      e.forEach(tF)
  };

function rF({
  root: e,
  ...t
}) {
  const n = e || document;
  Zd.has(n) || Zd.set(n, {});
  const r = Zd.get(n),
      s = JSON.stringify(t);
  return r[s] || (r[s] = new IntersectionObserver(nF, {
      root: e,
      ...t
  })), r[s]
}

function sF(e, t, n) {
  const r = rF(t);
  return sp.set(e, n), r.observe(e), () => {
      sp.delete(e), r.unobserve(e)
  }
}
const iF = {
  some: 0,
  all: 1
};
class oF extends is {
  constructor() {
      super(...arguments), this.hasEnteredView = !1, this.isInView = !1
  }
  startObserver() {
      this.unmount();
      const {
          viewport: t = {}
      } = this.node.getProps(), {
          root: n,
          margin: r,
          amount: s = "some",
          once: i
      } = t, o = {
          root: n ? n.current : void 0,
          rootMargin: r,
          threshold: typeof s == "number" ? s : iF[s]
      }, a = l => {
          const {
              isIntersecting: c
          } = l;
          if (this.isInView === c || (this.isInView = c, i && !c && this.hasEnteredView)) return;
          c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
          const {
              onViewportEnter: u,
              onViewportLeave: d
          } = this.node.getProps(), h = c ? u : d;
          h && h(l)
      };
      return sF(this.node.current, o, a)
  }
  mount() {
      this.startObserver()
  }
  update() {
      if (typeof IntersectionObserver > "u") return;
      const {
          props: t,
          prevProps: n
      } = this.node;
      ["amount", "margin", "root"].some(aF(t, n)) && this.startObserver()
  }
  unmount() {}
}

function aF({
  viewport: e = {}
}, {
  viewport: t = {}
} = {}) {
  return n => e[n] !== t[n]
}
const lF = {
      inView: {
          Feature: oF
      },
      tap: {
          Feature: eF
      },
      focus: {
          Feature: Z$
      },
      hover: {
          Feature: X$
      }
  },
  cF = {
      layout: {
          ProjectionNode: RE,
          MeasureLayout: xE
      }
  },
  uF = {
      ...YL,
      ...lF,
      ...J$,
      ...cF
  },
  Y = hL(uF, CL),
  dF = "/assets/hero-video-1230-C27srnl9.mp4";

function hF({
  name1: e,
  name2: t,
  date: n,
  subtitle: r
}) {
  const s = new Date(n),
      i = s.getDate(),
      o = s.toLocaleDateString("es-ES", {
          month: "long"
      }).toUpperCase(),
      a = s.getFullYear(),
      l = s.toLocaleDateString("es-ES", {
          weekday: "long"
      }).toUpperCase(),
      c = () => {
          const u = document.getElementById("rsvp");
          u == null || u.scrollIntoView({
              behavior: "smooth"
          })
      };
  return p.jsxs("section", {
      className: "relative min-h-screen overflow-hidden bg-background",
      children: [p.jsx("video", {
          src: dF,
          className: "absolute inset-0 w-full h-full object-cover",
          style: {
              objectPosition: "center center"
          },
          autoPlay: !0,
          loop: !0,
          muted: !0,
          playsInline: !0
      }), p.jsxs("div", {
          className: "relative z-20 min-h-screen flex flex-col items-center justify-center",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              animate: {
                  opacity: 1,
                  y: 0
              },
              transition: {
                  duration: 1,
                  delay: .3
              },
              className: "text-center px-8 max-w-sm mx-auto",
              children: [p.jsx(Y.p, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: 1
                  },
                  transition: {
                      duration: .8,
                      delay: .2
                  },
                  className: "font-script text-3xl md:text-4xl text-neutral-700 mb-6",
                  style: {
                      textShadow: "0.5px 0.5px 0px rgba(60, 40, 30, 0.3), -0.3px 0.3px 0px rgba(60, 40, 30, 0.1)",
                      filter: "url(#ink-texture)"
                  },
                  children: "Save the date"
              }), p.jsxs(Y.h1, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: 1
                  },
                  transition: {
                      duration: .8,
                      delay: .4
                  },
                  className: "font-display text-2xl md:text-3xl tracking-[0.15em] text-neutral-800 uppercase mb-6",
                  style: {
                      textShadow: "0.3px 0.3px 0.5px rgba(40, 30, 20, 0.4)"
                  },
                  children: [e, " & ", t]
              }), p.jsx(Y.p, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: 1
                  },
                  transition: {
                      duration: .8,
                      delay: .6
                  },
                  className: "font-script text-xl md:text-2xl text-neutral-600 mb-8",
                  style: {
                      textShadow: "0.4px 0.4px 0px rgba(60, 40, 30, 0.25), -0.2px 0.2px 0px rgba(60, 40, 30, 0.1)"
                  },
                  children: "Nos casamos!"
              }), p.jsxs(Y.div, {
                  initial: {
                      opacity: 0,
                      y: 10
                  },
                  animate: {
                      opacity: 1,
                      y: 0
                  },
                  transition: {
                      duration: .8,
                      delay: .8
                  },
                  className: "flex items-center justify-center gap-4 text-neutral-700 mb-2",
                  style: {
                      textShadow: "0.2px 0.2px 0.3px rgba(40, 30, 20, 0.3)"
                  },
                  children: [p.jsx("span", {
                      className: "font-display text-sm md:text-base tracking-[0.1em]",
                      children: o
                  }), p.jsx("span", {
                      className: "text-neutral-400",
                      children: "|"
                  }), p.jsx("span", {
                      className: "font-display text-xl md:text-2xl",
                      children: i
                  }), p.jsx("span", {
                      className: "text-neutral-400",
                      children: "|"
                  }), p.jsx("span", {
                      className: "font-display text-sm md:text-base tracking-[0.1em]",
                      children: l
                  })]
              }), p.jsx(Y.p, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: 1
                  },
                  transition: {
                      duration: .8,
                      delay: 1
                  },
                  className: "font-display text-base md:text-lg text-neutral-600 tracking-widest",
                  style: {
                      textShadow: "0.2px 0.2px 0.3px rgba(40, 30, 20, 0.3)"
                  },
                  children: a
              })]
          }), p.jsxs(Y.button, {
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: 1
              },
              transition: {
                  duration: .8,
                  delay: 1.2
              },
              onClick: c,
              className: "absolute bottom-8 flex flex-col items-center gap-2 text-foreground/50 hover:text-primary transition-colors cursor-pointer",
              children: [p.jsx("span", {
                  className: "text-[10px] tracking-[0.3em] uppercase font-body font-light",
                  children: "Confirma asistencia"
              }), p.jsx(Y.div, {
                  animate: {
                      y: [0, 6, 0]
                  },
                  transition: {
                      duration: 1.5,
                      repeat: 1 / 0,
                      ease: "easeInOut"
                  },
                  children: p.jsx(bm, {
                      className: "w-5 h-5"
                  })
              })]
          })]
      })]
  })
}

function fF({
  targetDate: e
}) {
  const [t, n] = g.useState({
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0
  });
  g.useEffect(() => {
      const s = () => {
          const o = e.includes("T") ? new Date(e) : new Date(`${e}T00:00:00`);
          if (Number.isNaN(o.getTime())) {
              n({
                  days: 0,
                  hours: 0,
                  minutes: 0,
                  seconds: 0
              });
              return
          }
          o.setHours(17, 0, 0, 0);
          const a = o.getTime() - new Date().getTime();
          a > 0 ? n({
              days: Math.floor(a / 864e5),
              hours: Math.floor(a / 36e5 % 24),
              minutes: Math.floor(a / 1e3 / 60 % 60),
              seconds: Math.floor(a / 1e3 % 60)
          }) : n({
              days: 0,
              hours: 0,
              minutes: 0,
              seconds: 0
          })
      };
      s();
      const i = setInterval(s, 1e3);
      return () => clearInterval(i)
  }, [e]);
  const r = [{
      value: t.days,
      label: "Das"
  }, {
      value: t.hours,
      label: "Horas"
  }, {
      value: t.minutes,
      label: "Minutos"
  }, {
      value: t.seconds,
      label: "Segundos"
  }];
  return p.jsx("section", {
      id: "countdown",
      className: "section-padding bg-background",
      children: p.jsxs("div", {
          className: "max-w-4xl mx-auto text-center",
          children: [p.jsx(Y.p, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-primary text-[10px] font-body tracking-[0.4em] uppercase mb-4",
              children: "Cuenta atrs"
          }), p.jsx(Y.h2, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .1
              },
              className: "font-script text-4xl md:text-5xl text-foreground mb-16",
              children: "Para el gran da"
          }), p.jsx(Y.div, {
              initial: {
                  opacity: 0,
                  y: 30
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .8,
                  delay: .2
              },
              className: "grid grid-cols-4 gap-2 md:gap-8 max-w-2xl mx-auto",
              children: r.map((s, i) => p.jsxs(Y.div, {
                  initial: {
                      opacity: 0,
                      scale: .9
                  },
                  whileInView: {
                      opacity: 1,
                      scale: 1
                  },
                  viewport: {
                      once: !0
                  },
                  transition: {
                      duration: .5,
                      delay: .3 + i * .1
                  },
                  className: "flex flex-col items-center",
                  children: [p.jsx("div", {
                      className: "bg-card border border-border rounded-lg p-4 md:p-6 shadow-soft w-full",
                      children: p.jsx("span", {
                          className: "block font-display text-3xl md:text-5xl lg:text-6xl font-normal text-foreground tracking-tight tabular-nums",
                          children: String(s.value).padStart(2, "0")
                      })
                  }), p.jsx("span", {
                      className: "block mt-3 text-[9px] md:text-[10px] tracking-[0.2em] uppercase text-muted-foreground font-body",
                      children: s.label
                  })]
              }, s.label))
          })]
      })
  })
}
const yg = ju("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
      variants: {
          variant: {
              default: "bg-primary text-primary-foreground hover:bg-primary/90",
              destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
              outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
              secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
              ghost: "hover:bg-accent hover:text-accent-foreground",
              link: "text-primary underline-offset-4 hover:underline"
          },
          size: {
              default: "h-10 px-4 py-2",
              sm: "h-9 rounded-md px-3",
              lg: "h-11 rounded-md px-8",
              icon: "h-10 w-10"
          }
      },
      defaultVariants: {
          variant: "default",
          size: "default"
      }
  }),
  Nn = g.forwardRef(({
      className: e,
      variant: t,
      size: n,
      asChild: r = !1,
      ...s
  }, i) => {
      const o = r ? LP : "button";
      return p.jsx(o, {
          className: ee(yg({
              variant: t,
              size: n,
              className: e
          })),
          ref: i,
          ...s
      })
  });
Nn.displayName = "Button";

function pF(e) {
  return `https://www.google.com/maps?q=${encodeURIComponent(e)}&output=embed`
}

function mF({
  location: e = "Masia Can Cortada",
  address: t,
  mapsUrl: n,
  startTime: r = "16:30",
  endTime: s = "02:30",
  weddingDate: i
}) {
  const o = (c, u, d, h) => {
          const f = new Date(`${h}T${u}:00`),
              x = new Date(f.getTime() + 10 * 60 * 60 * 1e3),
              m = b => b.toISOString().replace(/-|:|\.\d\d\d/g, "");
          return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(c)}&dates=${m(f)}/${m(x)}&location=${encodeURIComponent(d)}`
      },
      a = e || "Masia Can Cortada",
      l = t ? `${a}, ${t}` : a;
  return p.jsx("section", {
      className: "section-padding bg-ivory relative",
      children: p.jsxs("div", {
          className: "max-w-4xl mx-auto relative z-10",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-16",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-2",
                  children: "El lugar"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body tracking-wide",
                  children: "Donde celebraremos nuestro amor"
              })]
          }), p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 30
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "bg-card/95 backdrop-blur-sm border border-border p-8 md:p-12 rounded-lg shadow-elegant text-center",
              children: [p.jsx("div", {
                  className: "w-16 h-16 mx-auto mb-6 rounded-full bg-secondary flex items-center justify-center",
                  children: p.jsx(Hc, {
                      className: "w-7 h-7 text-primary"
                  })
              }), p.jsx("h3", {
                  className: "font-display text-2xl text-foreground mb-4",
                  children: a
              }), p.jsxs("div", {
                  className: "space-y-3 mb-6",
                  children: [t && p.jsx("p", {
                      className: "text-sm text-muted-foreground font-body",
                      children: t
                  }), p.jsxs("div", {
                      className: "flex items-center justify-center gap-2 mt-4 text-muted-foreground",
                      children: [p.jsx(M1, {
                          className: "w-4 h-4 text-primary"
                      }), p.jsxs("span", {
                          className: "font-body",
                          children: ["De ", r, "h a ", s, "h"]
                      })]
                  })]
              }), p.jsx("div", {
                  className: "mb-6 rounded-lg overflow-hidden border border-border",
                  children: p.jsx("iframe", {
                      src: pF(l),
                      width: "100%",
                      height: "250",
                      style: {
                          border: 0
                      },
                      allowFullScreen: !0,
                      loading: "lazy",
                      referrerPolicy: "no-referrer-when-downgrade",
                      title: `Mapa de ${a}`,
                      className: "hover:opacity-90 transition-opacity duration-300"
                  })
              }), p.jsxs("div", {
                  className: "flex flex-col sm:flex-row gap-3 justify-center",
                  children: [n && p.jsx(Nn, {
                      variant: "outline",
                      size: "sm",
                      className: "gap-2 border-primary/40 text-foreground hover:bg-primary hover:text-primary-foreground rounded-lg",
                      asChild: !0,
                      children: p.jsxs("a", {
                          href: n,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          children: [p.jsx(Hc, {
                              className: "w-4 h-4"
                          }), "Abrir en Maps"]
                      })
                  }), p.jsx(Nn, {
                      variant: "outline",
                      size: "sm",
                      className: "gap-2 border-primary/40 text-foreground hover:bg-primary hover:text-primary-foreground rounded-lg",
                      asChild: !0,
                      children: p.jsxs("a", {
                          href: o("Boda Fernanda y Gregorio", r, l, i),
                          target: "_blank",
                          rel: "noopener noreferrer",
                          children: [p.jsx(NA, {
                              className: "w-4 h-4"
                          }), "Aadir al calendario"]
                      })
                  })]
              })]
          })]
      })
  })
}
const ew = [{
  time: "17:00",
  title: "Civl",
  description: "Nos damos el S",
  icon: p.jsx(Hc, {
      className: "w-5 h-5"
  })
}, {
  time: "18:00",
  title: "Recepcin",
  description: "Les damos la bienvenida",
  icon: p.jsx(VA, {
      className: "w-5 h-5"
  })
}, {
  time: "20:00",
  title: "Cena",
  description: "Banquete nupcial",
  icon: p.jsx(YA, {
      className: "w-5 h-5"
  })
}, , {
  time: "21:00",
  title: "Fiesta",
  description: "A bailar!",
  icon: p.jsx(HA, {
      className: "w-5 h-5"
  })
}];

function gF() {
  return p.jsx("section", {
      className: "section-padding bg-ivory",
      children: p.jsxs("div", {
          className: "max-w-5xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-16",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-2",
                  children: "Programa del da"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body tracking-wide",
                  children: "Nuestra celebracin paso a paso"
              })]
          }), p.jsxs("div", {
              className: "relative",
              children: [p.jsxs("div", {
                  className: "hidden md:block",
                  children: [p.jsx("div", {
                      className: "absolute top-16 left-0 right-0 h-px bg-border"
                  }), p.jsx("div", {
                      className: "grid grid-cols-7 gap-2",
                      children: ew.map((e, t) => p.jsxs(Y.div, {
                          initial: {
                              opacity: 0,
                              y: 20
                          },
                          whileInView: {
                              opacity: 1,
                              y: 0
                          },
                          viewport: {
                              once: !0
                          },
                          transition: {
                              duration: .5,
                              delay: t * .08
                          },
                          className: "flex flex-col items-center text-center group",
                          children: [p.jsx("div", {
                              className: "bg-primary text-primary-foreground px-3 py-1.5 rounded-full text-sm font-display font-medium mb-4",
                              children: e.time
                          }), p.jsx("div", {
                              className: "w-14 h-14 rounded-full bg-background border-2 border-border flex items-center justify-center text-primary mb-4 shadow-soft group-hover:border-primary group-hover:scale-110 transition-all duration-300 z-10",
                              children: e.icon
                          }), p.jsx("h3", {
                              className: "font-display text-base lg:text-lg text-foreground mb-1 leading-tight",
                              children: e.title
                          }), e.description && p.jsx("p", {
                              className: "text-muted-foreground font-body text-xs leading-relaxed px-1",
                              children: e.description
                          })]
                      }, e.time))
                  })]
              }), p.jsxs("div", {
                  className: "md:hidden relative",
                  children: [p.jsx("div", {
                      className: "absolute left-6 top-0 bottom-0 w-px bg-border"
                  }), p.jsx("div", {
                      className: "space-y-6",
                      children: ew.map((e, t) => p.jsxs(Y.div, {
                          initial: {
                              opacity: 0,
                              x: -20
                          },
                          whileInView: {
                              opacity: 1,
                              x: 0
                          },
                          viewport: {
                              once: !0
                          },
                          transition: {
                              duration: .4,
                              delay: t * .05
                          },
                          className: "flex items-start gap-4 pl-1",
                          children: [p.jsx("div", {
                              className: "w-11 h-11 rounded-full bg-background border-2 border-border flex items-center justify-center text-primary flex-shrink-0 shadow-soft z-10",
                              children: e.icon
                          }), p.jsxs("div", {
                              className: "flex-1 pt-1",
                              children: [p.jsxs("div", {
                                  className: "flex items-baseline gap-3 mb-0.5",
                                  children: [p.jsx("span", {
                                      className: "bg-primary text-primary-foreground px-2 py-0.5 rounded text-xs font-display font-medium",
                                      children: e.time
                                  }), p.jsx("h3", {
                                      className: "font-display text-lg text-foreground",
                                      children: e.title
                                  })]
                              }), e.description && p.jsx("p", {
                                  className: "text-muted-foreground font-body text-sm",
                                  children: e.description
                              })]
                          })]
                      }, e.time))
                  })]
              })]
          }), p.jsx(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .3
              },
              className: "text-center mt-12",
              children: p.jsx("p", {
                  className: "font-body text-foreground text-lg font-medium",
                  children: "No nios!"
              })
          })]
      })
  })
}
var En = function() {
  return En = Object.assign || function(t) {
      for (var n, r = 1, s = arguments.length; r < s; r++) {
          n = arguments[r];
          for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
      }
      return t
  }, En.apply(this, arguments)
};

function No(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++) t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]);
  return n
}

function yF(e, t, n, r) {
  function s(i) {
      return i instanceof n ? i : new n(function(o) {
          o(i)
      })
  }
  return new(n || (n = Promise))(function(i, o) {
      function a(u) {
          try {
              c(r.next(u))
          } catch (d) {
              o(d)
          }
      }

      function l(u) {
          try {
              c(r.throw(u))
          } catch (d) {
              o(d)
          }
      }

      function c(u) {
          u.done ? i(u.value) : s(u.value).then(a, l)
      }
      c((r = r.apply(e, t || [])).next())
  })
}

function vF(e, t, n) {
  if (n || arguments.length === 2)
      for (var r = 0, s = t.length, i; r < s; r++)(i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t))
}
const wF = e => e ? (...t) => e(...t) : (...t) => fetch(...t);
class vg extends Error {
  constructor(t, n = "FunctionsError", r) {
      super(t), this.name = n, this.context = r
  }
}
class xF extends vg {
  constructor(t) {
      super("Failed to send a request to the Edge Function", "FunctionsFetchError", t)
  }
}
class tw extends vg {
  constructor(t) {
      super("Relay Error invoking the Edge Function", "FunctionsRelayError", t)
  }
}
class nw extends vg {
  constructor(t) {
      super("Edge Function returned a non-2xx status code", "FunctionsHttpError", t)
  }
}
var ip;
(function(e) {
  e.Any = "any", e.ApNortheast1 = "ap-northeast-1", e.ApNortheast2 = "ap-northeast-2", e.ApSouth1 = "ap-south-1", e.ApSoutheast1 = "ap-southeast-1", e.ApSoutheast2 = "ap-southeast-2", e.CaCentral1 = "ca-central-1", e.EuCentral1 = "eu-central-1", e.EuWest1 = "eu-west-1", e.EuWest2 = "eu-west-2", e.EuWest3 = "eu-west-3", e.SaEast1 = "sa-east-1", e.UsEast1 = "us-east-1", e.UsWest1 = "us-west-1", e.UsWest2 = "us-west-2"
})(ip || (ip = {}));
class bF {
  constructor(t, {
      headers: n = {},
      customFetch: r,
      region: s = ip.Any
  } = {}) {
      this.url = t, this.headers = n, this.region = s, this.fetch = wF(r)
  }
  setAuth(t) {
      this.headers.Authorization = `Bearer ${t}`
  }
  invoke(t) {
      return yF(this, arguments, void 0, function*(n, r = {}) {
          var s;
          let i, o;
          try {
              const {
                  headers: a,
                  method: l,
                  body: c,
                  signal: u,
                  timeout: d
              } = r;
              let h = {},
                  {
                      region: f
                  } = r;
              f || (f = this.region);
              const x = new URL(`${this.url}/${n}`);
              f && f !== "any" && (h["x-region"] = f, x.searchParams.set("forceFunctionRegion", f));
              let m;
              c && (a && !Object.prototype.hasOwnProperty.call(a, "Content-Type") || !a) ? typeof Blob < "u" && c instanceof Blob || c instanceof ArrayBuffer ? (h["Content-Type"] = "application/octet-stream", m = c) : typeof c == "string" ? (h["Content-Type"] = "text/plain", m = c) : typeof FormData < "u" && c instanceof FormData ? m = c : (h["Content-Type"] = "application/json", m = JSON.stringify(c)) : m = c;
              let b = u;
              d && (o = new AbortController, i = setTimeout(() => o.abort(), d), u ? (b = o.signal, u.addEventListener("abort", () => o.abort())) : b = o.signal);
              const v = yield this.fetch(x.toString(), {
                  method: l || "POST",
                  headers: Object.assign(Object.assign(Object.assign({}, h), this.headers), a),
                  body: m,
                  signal: b
              }).catch(_ => {
                  throw new xF(_)
              }), y = v.headers.get("x-relay-error");
              if (y && y === "true") throw new tw(v);
              if (!v.ok) throw new nw(v);
              let w = ((s = v.headers.get("Content-Type")) !== null && s !== void 0 ? s : "text/plain").split(";")[0].trim(),
                  S;
              return w === "application/json" ? S = yield v.json(): w === "application/octet-stream" || w === "application/pdf" ? S = yield v.blob(): w === "text/event-stream" ? S = v : w === "multipart/form-data" ? S = yield v.formData(): S = yield v.text(), {
                  data: S,
                  error: null,
                  response: v
              }
          } catch (a) {
              return {
                  data: null,
                  error: a,
                  response: a instanceof nw || a instanceof tw ? a.context : void 0
              }
          } finally {
              i && clearTimeout(i)
          }
      })
  }
}
var SF = class extends Error {
      constructor(e) {
          super(e.message), this.name = "PostgrestError", this.details = e.details, this.hint = e.hint, this.code = e.code
      }
  },
  _F = class {
      constructor(e) {
          var t, n;
          this.shouldThrowOnError = !1, this.method = e.method, this.url = e.url, this.headers = new Headers(e.headers), this.schema = e.schema, this.body = e.body, this.shouldThrowOnError = (t = e.shouldThrowOnError) !== null && t !== void 0 ? t : !1, this.signal = e.signal, this.isMaybeSingle = (n = e.isMaybeSingle) !== null && n !== void 0 ? n : !1, e.fetch ? this.fetch = e.fetch : this.fetch = fetch
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      setHeader(e, t) {
          return this.headers = new Headers(this.headers), this.headers.set(e, t), this
      }
      then(e, t) {
          var n = this;
          this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)), this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
          const r = this.fetch;
          let s = r(this.url.toString(), {
              method: this.method,
              headers: this.headers,
              body: JSON.stringify(this.body),
              signal: this.signal
          }).then(async i => {
              let o = null,
                  a = null,
                  l = null,
                  c = i.status,
                  u = i.statusText;
              if (i.ok) {
                  var d, h;
                  if (n.method !== "HEAD") {
                      var f;
                      const v = await i.text();
                      v === "" || (n.headers.get("Accept") === "text/csv" || n.headers.get("Accept") && (!((f = n.headers.get("Accept")) === null || f === void 0) && f.includes("application/vnd.pgrst.plan+text")) ? a = v : a = JSON.parse(v))
                  }
                  const m = (d = n.headers.get("Prefer")) === null || d === void 0 ? void 0 : d.match(/count=(exact|planned|estimated)/),
                      b = (h = i.headers.get("content-range")) === null || h === void 0 ? void 0 : h.split("/");
                  m && b && b.length > 1 && (l = parseInt(b[1])), n.isMaybeSingle && n.method === "GET" && Array.isArray(a) && (a.length > 1 ? (o = {
                      code: "PGRST116",
                      details: `Results contain ${a.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                      hint: null,
                      message: "JSON object requested, multiple (or no) rows returned"
                  }, a = null, l = null, c = 406, u = "Not Acceptable") : a.length === 1 ? a = a[0] : a = null)
              } else {
                  var x;
                  const m = await i.text();
                  try {
                      o = JSON.parse(m), Array.isArray(o) && i.status === 404 && (a = [], o = null, c = 200, u = "OK")
                  } catch {
                      i.status === 404 && m === "" ? (c = 204, u = "No Content") : o = {
                          message: m
                      }
                  }
                  if (o && n.isMaybeSingle && (!(o == null || (x = o.details) === null || x === void 0) && x.includes("0 rows")) && (o = null, c = 200, u = "OK"), o && n.shouldThrowOnError) throw new SF(o)
              }
              return {
                  error: o,
                  data: a,
                  count: l,
                  status: c,
                  statusText: u
              }
          });
          return this.shouldThrowOnError || (s = s.catch(i => {
              var o;
              let a = "";
              const l = i == null ? void 0 : i.cause;
              if (l) {
                  var c, u, d, h;
                  const x = (c = l == null ? void 0 : l.message) !== null && c !== void 0 ? c : "",
                      m = (u = l == null ? void 0 : l.code) !== null && u !== void 0 ? u : "";
                  a = `${(d = i == null ? void 0 : i.name) !== null && d !== void 0 ? d : "FetchError"}: ${i == null ? void 0 : i.message}`, a += `

Caused by: ${(h = l == null ? void 0 : l.name) !== null && h !== void 0 ? h : "Error"}: ${x}`, m && (a += ` (${m})`), l != null && l.stack && (a += `
${l.stack}`)
              } else {
                  var f;
                  a = (f = i == null ? void 0 : i.stack) !== null && f !== void 0 ? f : ""
              }
              return {
                  error: {
                      message: `${(o = i == null ? void 0 : i.name) !== null && o !== void 0 ? o : "FetchError"}: ${i == null ? void 0 : i.message}`,
                      details: a,
                      hint: "",
                      code: ""
                  },
                  data: null,
                  count: null,
                  status: 0,
                  statusText: ""
              }
          })), s.then(e, t)
      }
      returns() {
          return this
      }
      overrideTypes() {
          return this
      }
  },
  EF = class extends _F {
      select(e) {
          let t = !1;
          const n = (e ?? "*").split("").map(r => /\s/.test(r) && !t ? "" : (r === '"' && (t = !t), r)).join("");
          return this.url.searchParams.set("select", n), this.headers.append("Prefer", "return=representation"), this
      }
      order(e, {
          ascending: t = !0,
          nullsFirst: n,
          foreignTable: r,
          referencedTable: s = r
      } = {}) {
          const i = s ? `${s}.order` : "order",
              o = this.url.searchParams.get(i);
          return this.url.searchParams.set(i, `${o ? `${o},` : ""}${e}.${t ? "asc" : "desc"}${n === void 0 ? "" : n ? ".nullsfirst" : ".nullslast"}`), this
      }
      limit(e, {
          foreignTable: t,
          referencedTable: n = t
      } = {}) {
          const r = typeof n > "u" ? "limit" : `${n}.limit`;
          return this.url.searchParams.set(r, `${e}`), this
      }
      range(e, t, {
          foreignTable: n,
          referencedTable: r = n
      } = {}) {
          const s = typeof r > "u" ? "offset" : `${r}.offset`,
              i = typeof r > "u" ? "limit" : `${r}.limit`;
          return this.url.searchParams.set(s, `${e}`), this.url.searchParams.set(i, `${t - e + 1}`), this
      }
      abortSignal(e) {
          return this.signal = e, this
      }
      single() {
          return this.headers.set("Accept", "application/vnd.pgrst.object+json"), this
      }
      maybeSingle() {
          return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"), this.isMaybeSingle = !0, this
      }
      csv() {
          return this.headers.set("Accept", "text/csv"), this
      }
      geojson() {
          return this.headers.set("Accept", "application/geo+json"), this
      }
      explain({
          analyze: e = !1,
          verbose: t = !1,
          settings: n = !1,
          buffers: r = !1,
          wal: s = !1,
          format: i = "text"
      } = {}) {
          var o;
          const a = [e ? "analyze" : null, t ? "verbose" : null, n ? "settings" : null, r ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|"),
              l = (o = this.headers.get("Accept")) !== null && o !== void 0 ? o : "application/json";
          return this.headers.set("Accept", `application/vnd.pgrst.plan+${i}; for="${l}"; options=${a};`), i === "json" ? this : this
      }
      rollback() {
          return this.headers.append("Prefer", "tx=rollback"), this
      }
      returns() {
          return this
      }
      maxAffected(e) {
          return this.headers.append("Prefer", "handling=strict"), this.headers.append("Prefer", `max-affected=${e}`), this
      }
  };
const rw = new RegExp("[,()]");
var gi = class extends EF {
      eq(e, t) {
          return this.url.searchParams.append(e, `eq.${t}`), this
      }
      neq(e, t) {
          return this.url.searchParams.append(e, `neq.${t}`), this
      }
      gt(e, t) {
          return this.url.searchParams.append(e, `gt.${t}`), this
      }
      gte(e, t) {
          return this.url.searchParams.append(e, `gte.${t}`), this
      }
      lt(e, t) {
          return this.url.searchParams.append(e, `lt.${t}`), this
      }
      lte(e, t) {
          return this.url.searchParams.append(e, `lte.${t}`), this
      }
      like(e, t) {
          return this.url.searchParams.append(e, `like.${t}`), this
      }
      likeAllOf(e, t) {
          return this.url.searchParams.append(e, `like(all).{${t.join(",")}}`), this
      }
      likeAnyOf(e, t) {
          return this.url.searchParams.append(e, `like(any).{${t.join(",")}}`), this
      }
      ilike(e, t) {
          return this.url.searchParams.append(e, `ilike.${t}`), this
      }
      ilikeAllOf(e, t) {
          return this.url.searchParams.append(e, `ilike(all).{${t.join(",")}}`), this
      }
      ilikeAnyOf(e, t) {
          return this.url.searchParams.append(e, `ilike(any).{${t.join(",")}}`), this
      }
      regexMatch(e, t) {
          return this.url.searchParams.append(e, `match.${t}`), this
      }
      regexIMatch(e, t) {
          return this.url.searchParams.append(e, `imatch.${t}`), this
      }
      is(e, t) {
          return this.url.searchParams.append(e, `is.${t}`), this
      }
      isDistinct(e, t) {
          return this.url.searchParams.append(e, `isdistinct.${t}`), this
      }
      in(e, t) {
          const n = Array.from(new Set(t)).map(r => typeof r == "string" && rw.test(r) ? `"${r}"` : `${r}`).join(",");
          return this.url.searchParams.append(e, `in.(${n})`), this
      }
      notIn(e, t) {
          const n = Array.from(new Set(t)).map(r => typeof r == "string" && rw.test(r) ? `"${r}"` : `${r}`).join(",");
          return this.url.searchParams.append(e, `not.in.(${n})`), this
      }
      contains(e, t) {
          return typeof t == "string" ? this.url.searchParams.append(e, `cs.${t}`) : Array.isArray(t) ? this.url.searchParams.append(e, `cs.{${t.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(t)}`), this
      }
      containedBy(e, t) {
          return typeof t == "string" ? this.url.searchParams.append(e, `cd.${t}`) : Array.isArray(t) ? this.url.searchParams.append(e, `cd.{${t.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(t)}`), this
      }
      rangeGt(e, t) {
          return this.url.searchParams.append(e, `sr.${t}`), this
      }
      rangeGte(e, t) {
          return this.url.searchParams.append(e, `nxl.${t}`), this
      }
      rangeLt(e, t) {
          return this.url.searchParams.append(e, `sl.${t}`), this
      }
      rangeLte(e, t) {
          return this.url.searchParams.append(e, `nxr.${t}`), this
      }
      rangeAdjacent(e, t) {
          return this.url.searchParams.append(e, `adj.${t}`), this
      }
      overlaps(e, t) {
          return typeof t == "string" ? this.url.searchParams.append(e, `ov.${t}`) : this.url.searchParams.append(e, `ov.{${t.join(",")}}`), this
      }
      textSearch(e, t, {
          config: n,
          type: r
      } = {}) {
          let s = "";
          r === "plain" ? s = "pl" : r === "phrase" ? s = "ph" : r === "websearch" && (s = "w");
          const i = n === void 0 ? "" : `(${n})`;
          return this.url.searchParams.append(e, `${s}fts${i}.${t}`), this
      }
      match(e) {
          return Object.entries(e).forEach(([t, n]) => {
              this.url.searchParams.append(t, `eq.${n}`)
          }), this
      }
      not(e, t, n) {
          return this.url.searchParams.append(e, `not.${t}.${n}`), this
      }
      or(e, {
          foreignTable: t,
          referencedTable: n = t
      } = {}) {
          const r = n ? `${n}.or` : "or";
          return this.url.searchParams.append(r, `(${e})`), this
      }
      filter(e, t, n) {
          return this.url.searchParams.append(e, `${t}.${n}`), this
      }
  },
  CF = class {
      constructor(e, {
          headers: t = {},
          schema: n,
          fetch: r
      }) {
          this.url = e, this.headers = new Headers(t), this.schema = n, this.fetch = r
      }
      select(e, t) {
          const {
              head: n = !1,
              count: r
          } = t ?? {}, s = n ? "HEAD" : "GET";
          let i = !1;
          const o = (e ?? "*").split("").map(a => /\s/.test(a) && !i ? "" : (a === '"' && (i = !i), a)).join("");
          return this.url.searchParams.set("select", o), r && this.headers.append("Prefer", `count=${r}`), new gi({
              method: s,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              fetch: this.fetch
          })
      }
      insert(e, {
          count: t,
          defaultToNull: n = !0
      } = {}) {
          var r;
          const s = "POST";
          if (t && this.headers.append("Prefer", `count=${t}`), n || this.headers.append("Prefer", "missing=default"), Array.isArray(e)) {
              const i = e.reduce((o, a) => o.concat(Object.keys(a)), []);
              if (i.length > 0) {
                  const o = [...new Set(i)].map(a => `"${a}"`);
                  this.url.searchParams.set("columns", o.join(","))
              }
          }
          return new gi({
              method: s,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: (r = this.fetch) !== null && r !== void 0 ? r : fetch
          })
      }
      upsert(e, {
          onConflict: t,
          ignoreDuplicates: n = !1,
          count: r,
          defaultToNull: s = !0
      } = {}) {
          var i;
          const o = "POST";
          if (this.headers.append("Prefer", `resolution=${n ? "ignore" : "merge"}-duplicates`), t !== void 0 && this.url.searchParams.set("on_conflict", t), r && this.headers.append("Prefer", `count=${r}`), s || this.headers.append("Prefer", "missing=default"), Array.isArray(e)) {
              const a = e.reduce((l, c) => l.concat(Object.keys(c)), []);
              if (a.length > 0) {
                  const l = [...new Set(a)].map(c => `"${c}"`);
                  this.url.searchParams.set("columns", l.join(","))
              }
          }
          return new gi({
              method: o,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
          })
      }
      update(e, {
          count: t
      } = {}) {
          var n;
          const r = "PATCH";
          return t && this.headers.append("Prefer", `count=${t}`), new gi({
              method: r,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              body: e,
              fetch: (n = this.fetch) !== null && n !== void 0 ? n : fetch
          })
      }
      delete({
          count: e
      } = {}) {
          var t;
          const n = "DELETE";
          return e && this.headers.append("Prefer", `count=${e}`), new gi({
              method: n,
              url: this.url,
              headers: this.headers,
              schema: this.schema,
              fetch: (t = this.fetch) !== null && t !== void 0 ? t : fetch
          })
      }
  },
  TF = class PE {
      constructor(t, {
          headers: n = {},
          schema: r,
          fetch: s
      } = {}) {
          this.url = t, this.headers = new Headers(n), this.schemaName = r, this.fetch = s
      }
      from(t) {
          if (!t || typeof t != "string" || t.trim() === "") throw new Error("Invalid relation name: relation must be a non-empty string.");
          return new CF(new URL(`${this.url}/${t}`), {
              headers: new Headers(this.headers),
              schema: this.schemaName,
              fetch: this.fetch
          })
      }
      schema(t) {
          return new PE(this.url, {
              headers: this.headers,
              schema: t,
              fetch: this.fetch
          })
      }
      rpc(t, n = {}, {
          head: r = !1,
          get: s = !1,
          count: i
      } = {}) {
          var o;
          let a;
          const l = new URL(`${this.url}/rpc/${t}`);
          let c;
          r || s ? (a = r ? "HEAD" : "GET", Object.entries(n).filter(([d, h]) => h !== void 0).map(([d, h]) => [d, Array.isArray(h) ? `{${h.join(",")}}` : `${h}`]).forEach(([d, h]) => {
              l.searchParams.append(d, h)
          })) : (a = "POST", c = n);
          const u = new Headers(this.headers);
          return i && u.set("Prefer", `count=${i}`), new gi({
              method: a,
              url: l,
              headers: u,
              schema: this.schemaName,
              body: c,
              fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
          })
      }
  };
class kF {
  constructor() {}
  static detectEnvironment() {
      var t;
      if (typeof WebSocket < "u") return {
          type: "native",
          constructor: WebSocket
      };
      if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u") return {
          type: "native",
          constructor: globalThis.WebSocket
      };
      if (typeof global < "u" && typeof global.WebSocket < "u") return {
          type: "native",
          constructor: global.WebSocket
      };
      if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u") return {
          type: "cloudflare",
          error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
          workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
      if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((t = navigator.userAgent) === null || t === void 0) && t.includes("Vercel-Edge"))) return {
          type: "unsupported",
          error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
          workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
      if (typeof process < "u") {
          const n = process.versions;
          if (n && n.node) {
              const r = n.node,
                  s = parseInt(r.replace(/^v/, "").split(".")[0]);
              return s >= 22 ? typeof globalThis.WebSocket < "u" ? {
                  type: "native",
                  constructor: globalThis.WebSocket
              } : {
                  type: "unsupported",
                  error: `Node.js ${s} detected but native WebSocket not found.`,
                  workaround: "Provide a WebSocket implementation via the transport option."
              } : {
                  type: "unsupported",
                  error: `Node.js ${s} detected without native WebSocket support.`,
                  workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
              }
          }
      }
      return {
          type: "unsupported",
          error: "Unknown JavaScript runtime without WebSocket support.",
          workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
      }
  }
  static getWebSocketConstructor() {
      const t = this.detectEnvironment();
      if (t.constructor) return t.constructor;
      let n = t.error || "WebSocket not supported in this environment.";
      throw t.workaround && (n += `

Suggested solution: ${t.workaround}`), new Error(n)
  }
  static createWebSocket(t, n) {
      const r = this.getWebSocketConstructor();
      return new r(t, n)
  }
  static isWebSocketSupported() {
      try {
          const t = this.detectEnvironment();
          return t.type === "native" || t.type === "ws"
      } catch {
          return !1
      }
  }
}
const RF = "2.89.0",
  PF = `realtime-js/${RF}`,
  AE = "1.0.0",
  AF = "2.0.0",
  sw = AE,
  op = 1e4,
  NF = 1e3,
  jF = 100;
var xr;
(function(e) {
  e[e.connecting = 0] = "connecting", e[e.open = 1] = "open", e[e.closing = 2] = "closing", e[e.closed = 3] = "closed"
})(xr || (xr = {}));
var $e;
(function(e) {
  e.closed = "closed", e.errored = "errored", e.joined = "joined", e.joining = "joining", e.leaving = "leaving"
})($e || ($e = {}));
var ln;
(function(e) {
  e.close = "phx_close", e.error = "phx_error", e.join = "phx_join", e.reply = "phx_reply", e.leave = "phx_leave", e.access_token = "access_token"
})(ln || (ln = {}));
var ap;
(function(e) {
  e.websocket = "websocket"
})(ap || (ap = {}));
var xs;
(function(e) {
  e.Connecting = "connecting", e.Open = "open", e.Closing = "closing", e.Closed = "closed"
})(xs || (xs = {}));
class OF {
  constructor(t) {
      this.HEADER_LENGTH = 1, this.USER_BROADCAST_PUSH_META_LENGTH = 6, this.KINDS = {
          userBroadcastPush: 3,
          userBroadcast: 4
      }, this.BINARY_ENCODING = 0, this.JSON_ENCODING = 1, this.BROADCAST_EVENT = "broadcast", this.allowedMetadataKeys = [], this.allowedMetadataKeys = t ?? []
  }
  encode(t, n) {
      if (t.event === this.BROADCAST_EVENT && !(t.payload instanceof ArrayBuffer) && typeof t.payload.event == "string") return n(this._binaryEncodeUserBroadcastPush(t));
      let r = [t.join_ref, t.ref, t.topic, t.event, t.payload];
      return n(JSON.stringify(r))
  }
  _binaryEncodeUserBroadcastPush(t) {
      var n;
      return this._isArrayBuffer((n = t.payload) === null || n === void 0 ? void 0 : n.payload) ? this._encodeBinaryUserBroadcastPush(t) : this._encodeJsonUserBroadcastPush(t)
  }
  _encodeBinaryUserBroadcastPush(t) {
      var n, r;
      const s = (r = (n = t.payload) === null || n === void 0 ? void 0 : n.payload) !== null && r !== void 0 ? r : new ArrayBuffer(0);
      return this._encodeUserBroadcastPush(t, this.BINARY_ENCODING, s)
  }
  _encodeJsonUserBroadcastPush(t) {
      var n, r;
      const s = (r = (n = t.payload) === null || n === void 0 ? void 0 : n.payload) !== null && r !== void 0 ? r : {},
          o = new TextEncoder().encode(JSON.stringify(s)).buffer;
      return this._encodeUserBroadcastPush(t, this.JSON_ENCODING, o)
  }
  _encodeUserBroadcastPush(t, n, r) {
      var s, i;
      const o = t.topic,
          a = (s = t.ref) !== null && s !== void 0 ? s : "",
          l = (i = t.join_ref) !== null && i !== void 0 ? i : "",
          c = t.payload.event,
          u = this.allowedMetadataKeys ? this._pick(t.payload, this.allowedMetadataKeys) : {},
          d = Object.keys(u).length === 0 ? "" : JSON.stringify(u);
      if (l.length > 255) throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);
      if (a.length > 255) throw new Error(`ref length ${a.length} exceeds maximum of 255`);
      if (o.length > 255) throw new Error(`topic length ${o.length} exceeds maximum of 255`);
      if (c.length > 255) throw new Error(`userEvent length ${c.length} exceeds maximum of 255`);
      if (d.length > 255) throw new Error(`metadata length ${d.length} exceeds maximum of 255`);
      const h = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + c.length + d.length,
          f = new ArrayBuffer(this.HEADER_LENGTH + h);
      let x = new DataView(f),
          m = 0;
      x.setUint8(m++, this.KINDS.userBroadcastPush), x.setUint8(m++, l.length), x.setUint8(m++, a.length), x.setUint8(m++, o.length), x.setUint8(m++, c.length), x.setUint8(m++, d.length), x.setUint8(m++, n), Array.from(l, v => x.setUint8(m++, v.charCodeAt(0))), Array.from(a, v => x.setUint8(m++, v.charCodeAt(0))), Array.from(o, v => x.setUint8(m++, v.charCodeAt(0))), Array.from(c, v => x.setUint8(m++, v.charCodeAt(0))), Array.from(d, v => x.setUint8(m++, v.charCodeAt(0)));
      var b = new Uint8Array(f.byteLength + r.byteLength);
      return b.set(new Uint8Array(f), 0), b.set(new Uint8Array(r), f.byteLength), b.buffer
  }
  decode(t, n) {
      if (this._isArrayBuffer(t)) {
          let r = this._binaryDecode(t);
          return n(r)
      }
      if (typeof t == "string") {
          const r = JSON.parse(t),
              [s, i, o, a, l] = r;
          return n({
              join_ref: s,
              ref: i,
              topic: o,
              event: a,
              payload: l
          })
      }
      return n({})
  }
  _binaryDecode(t) {
      const n = new DataView(t),
          r = n.getUint8(0),
          s = new TextDecoder;
      switch (r) {
          case this.KINDS.userBroadcast:
              return this._decodeUserBroadcast(t, n, s)
      }
  }
  _decodeUserBroadcast(t, n, r) {
      const s = n.getUint8(1),
          i = n.getUint8(2),
          o = n.getUint8(3),
          a = n.getUint8(4);
      let l = this.HEADER_LENGTH + 4;
      const c = r.decode(t.slice(l, l + s));
      l = l + s;
      const u = r.decode(t.slice(l, l + i));
      l = l + i;
      const d = r.decode(t.slice(l, l + o));
      l = l + o;
      const h = t.slice(l, t.byteLength),
          f = a === this.JSON_ENCODING ? JSON.parse(r.decode(h)) : h,
          x = {
              type: this.BROADCAST_EVENT,
              event: u,
              payload: f
          };
      return o > 0 && (x.meta = JSON.parse(d)), {
          join_ref: null,
          ref: null,
          topic: c,
          event: this.BROADCAST_EVENT,
          payload: x
      }
  }
  _isArrayBuffer(t) {
      var n;
      return t instanceof ArrayBuffer || ((n = t == null ? void 0 : t.constructor) === null || n === void 0 ? void 0 : n.name) === "ArrayBuffer"
  }
  _pick(t, n) {
      return !t || typeof t != "object" ? {} : Object.fromEntries(Object.entries(t).filter(([r]) => n.includes(r)))
  }
}
class NE {
  constructor(t, n) {
      this.callback = t, this.timerCalc = n, this.timer = void 0, this.tries = 0, this.callback = t, this.timerCalc = n
  }
  reset() {
      this.tries = 0, clearTimeout(this.timer), this.timer = void 0
  }
  scheduleTimeout() {
      clearTimeout(this.timer), this.timer = setTimeout(() => {
          this.tries = this.tries + 1, this.callback()
      }, this.timerCalc(this.tries + 1))
  }
}
var pe;
(function(e) {
  e.abstime = "abstime", e.bool = "bool", e.date = "date", e.daterange = "daterange", e.float4 = "float4", e.float8 = "float8", e.int2 = "int2", e.int4 = "int4", e.int4range = "int4range", e.int8 = "int8", e.int8range = "int8range", e.json = "json", e.jsonb = "jsonb", e.money = "money", e.numeric = "numeric", e.oid = "oid", e.reltime = "reltime", e.text = "text", e.time = "time", e.timestamp = "timestamp", e.timestamptz = "timestamptz", e.timetz = "timetz", e.tsrange = "tsrange", e.tstzrange = "tstzrange"
})(pe || (pe = {}));
const iw = (e, t, n = {}) => {
      var r;
      const s = (r = n.skipTypes) !== null && r !== void 0 ? r : [];
      return t ? Object.keys(t).reduce((i, o) => (i[o] = IF(o, e, t, s), i), {}) : {}
  },
  IF = (e, t, n, r) => {
      const s = t.find(a => a.name === e),
          i = s == null ? void 0 : s.type,
          o = n[e];
      return i && !r.includes(i) ? jE(i, o) : lp(o)
  },
  jE = (e, t) => {
      if (e.charAt(0) === "_") {
          const n = e.slice(1, e.length);
          return $F(t, n)
      }
      switch (e) {
          case pe.bool:
              return DF(t);
          case pe.float4:
          case pe.float8:
          case pe.int2:
          case pe.int4:
          case pe.int8:
          case pe.numeric:
          case pe.oid:
              return MF(t);
          case pe.json:
          case pe.jsonb:
              return LF(t);
          case pe.timestamp:
              return FF(t);
          case pe.abstime:
          case pe.date:
          case pe.daterange:
          case pe.int4range:
          case pe.int8range:
          case pe.money:
          case pe.reltime:
          case pe.text:
          case pe.time:
          case pe.timestamptz:
          case pe.timetz:
          case pe.tsrange:
          case pe.tstzrange:
              return lp(t);
          default:
              return lp(t)
      }
  },
  lp = e => e,
  DF = e => {
      switch (e) {
          case "t":
              return !0;
          case "f":
              return !1;
          default:
              return e
      }
  },
  MF = e => {
      if (typeof e == "string") {
          const t = parseFloat(e);
          if (!Number.isNaN(t)) return t
      }
      return e
  },
  LF = e => {
      if (typeof e == "string") try {
          return JSON.parse(e)
      } catch {
          return e
      }
      return e
  },
  $F = (e, t) => {
      if (typeof e != "string") return e;
      const n = e.length - 1,
          r = e[n];
      if (e[0] === "{" && r === "}") {
          let i;
          const o = e.slice(1, n);
          try {
              i = JSON.parse("[" + o + "]")
          } catch {
              i = o ? o.split(",") : []
          }
          return i.map(a => jE(t, a))
      }
      return e
  },
  FF = e => typeof e == "string" ? e.replace(" ", "T") : e,
  OE = e => {
      const t = new URL(e);
      return t.protocol = t.protocol.replace(/^ws/i, "http"), t.pathname = t.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""), t.pathname === "" || t.pathname === "/" ? t.pathname = "/api/broadcast" : t.pathname = t.pathname + "/api/broadcast", t.href
  };
class eh {
  constructor(t, n, r = {}, s = op) {
      this.channel = t, this.event = n, this.payload = r, this.timeout = s, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null
  }
  resend(t) {
      this.timeout = t, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send()
  }
  send() {
      this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({
          topic: this.channel.topic,
          event: this.event,
          payload: this.payload,
          ref: this.ref,
          join_ref: this.channel._joinRef()
      }))
  }
  updatePayload(t) {
      this.payload = Object.assign(Object.assign({}, this.payload), t)
  }
  receive(t, n) {
      var r;
      return this._hasReceived(t) && n((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response), this.recHooks.push({
          status: t,
          callback: n
      }), this
  }
  startTimeout() {
      if (this.timeoutTimer) return;
      this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref);
      const t = n => {
          this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = n, this._matchReceive(n)
      };
      this.channel._on(this.refEvent, {}, t), this.timeoutTimer = setTimeout(() => {
          this.trigger("timeout", {})
      }, this.timeout)
  }
  trigger(t, n) {
      this.refEvent && this.channel._trigger(this.refEvent, {
          status: t,
          response: n
      })
  }
  destroy() {
      this._cancelRefEvent(), this._cancelTimeout()
  }
  _cancelRefEvent() {
      this.refEvent && this.channel._off(this.refEvent, {})
  }
  _cancelTimeout() {
      clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0
  }
  _matchReceive({
      status: t,
      response: n
  }) {
      this.recHooks.filter(r => r.status === t).forEach(r => r.callback(n))
  }
  _hasReceived(t) {
      return this.receivedResp && this.receivedResp.status === t
  }
}
var ow;
(function(e) {
  e.SYNC = "sync", e.JOIN = "join", e.LEAVE = "leave"
})(ow || (ow = {}));
class fa {
  constructor(t, n) {
      this.channel = t, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.enabled = !1, this.caller = {
          onJoin: () => {},
          onLeave: () => {},
          onSync: () => {}
      };
      const r = (n == null ? void 0 : n.events) || {
          state: "presence_state",
          diff: "presence_diff"
      };
      this.channel._on(r.state, {}, s => {
          const {
              onJoin: i,
              onLeave: o,
              onSync: a
          } = this.caller;
          this.joinRef = this.channel._joinRef(), this.state = fa.syncState(this.state, s, i, o), this.pendingDiffs.forEach(l => {
              this.state = fa.syncDiff(this.state, l, i, o)
          }), this.pendingDiffs = [], a()
      }), this.channel._on(r.diff, {}, s => {
          const {
              onJoin: i,
              onLeave: o,
              onSync: a
          } = this.caller;
          this.inPendingSyncState() ? this.pendingDiffs.push(s) : (this.state = fa.syncDiff(this.state, s, i, o), a())
      }), this.onJoin((s, i, o) => {
          this.channel._trigger("presence", {
              event: "join",
              key: s,
              currentPresences: i,
              newPresences: o
          })
      }), this.onLeave((s, i, o) => {
          this.channel._trigger("presence", {
              event: "leave",
              key: s,
              currentPresences: i,
              leftPresences: o
          })
      }), this.onSync(() => {
          this.channel._trigger("presence", {
              event: "sync"
          })
      })
  }
  static syncState(t, n, r, s) {
      const i = this.cloneDeep(t),
          o = this.transformState(n),
          a = {},
          l = {};
      return this.map(i, (c, u) => {
          o[c] || (l[c] = u)
      }), this.map(o, (c, u) => {
          const d = i[c];
          if (d) {
              const h = u.map(b => b.presence_ref),
                  f = d.map(b => b.presence_ref),
                  x = u.filter(b => f.indexOf(b.presence_ref) < 0),
                  m = d.filter(b => h.indexOf(b.presence_ref) < 0);
              x.length > 0 && (a[c] = x), m.length > 0 && (l[c] = m)
          } else a[c] = u
      }), this.syncDiff(i, {
          joins: a,
          leaves: l
      }, r, s)
  }
  static syncDiff(t, n, r, s) {
      const {
          joins: i,
          leaves: o
      } = {
          joins: this.transformState(n.joins),
          leaves: this.transformState(n.leaves)
      };
      return r || (r = () => {}), s || (s = () => {}), this.map(i, (a, l) => {
          var c;
          const u = (c = t[a]) !== null && c !== void 0 ? c : [];
          if (t[a] = this.cloneDeep(l), u.length > 0) {
              const d = t[a].map(f => f.presence_ref),
                  h = u.filter(f => d.indexOf(f.presence_ref) < 0);
              t[a].unshift(...h)
          }
          r(a, u, l)
      }), this.map(o, (a, l) => {
          let c = t[a];
          if (!c) return;
          const u = l.map(d => d.presence_ref);
          c = c.filter(d => u.indexOf(d.presence_ref) < 0), t[a] = c, s(a, c, l), c.length === 0 && delete t[a]
      }), t
  }
  static map(t, n) {
      return Object.getOwnPropertyNames(t).map(r => n(r, t[r]))
  }
  static transformState(t) {
      return t = this.cloneDeep(t), Object.getOwnPropertyNames(t).reduce((n, r) => {
          const s = t[r];
          return "metas" in s ? n[r] = s.metas.map(i => (i.presence_ref = i.phx_ref, delete i.phx_ref, delete i.phx_ref_prev, i)) : n[r] = s, n
      }, {})
  }
  static cloneDeep(t) {
      return JSON.parse(JSON.stringify(t))
  }
  onJoin(t) {
      this.caller.onJoin = t
  }
  onLeave(t) {
      this.caller.onLeave = t
  }
  onSync(t) {
      this.caller.onSync = t
  }
  inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef()
  }
}
var aw;
(function(e) {
  e.ALL = "*", e.INSERT = "INSERT", e.UPDATE = "UPDATE", e.DELETE = "DELETE"
})(aw || (aw = {}));
var pa;
(function(e) {
  e.BROADCAST = "broadcast", e.PRESENCE = "presence", e.POSTGRES_CHANGES = "postgres_changes", e.SYSTEM = "system"
})(pa || (pa = {}));
var $n;
(function(e) {
  e.SUBSCRIBED = "SUBSCRIBED", e.TIMED_OUT = "TIMED_OUT", e.CLOSED = "CLOSED", e.CHANNEL_ERROR = "CHANNEL_ERROR"
})($n || ($n = {}));
class Mi {
  constructor(t, n = {
      config: {}
  }, r) {
      var s, i;
      if (this.topic = t, this.params = n, this.socket = r, this.bindings = {}, this.state = $e.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = t.replace(/^realtime:/i, ""), this.params.config = Object.assign({
              broadcast: {
                  ack: !1,
                  self: !1
              },
              presence: {
                  key: "",
                  enabled: !1
              },
              private: !1
          }, n.config), this.timeout = this.socket.timeout, this.joinPush = new eh(this, ln.join, this.params, this.timeout), this.rejoinTimer = new NE(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
              this.state = $e.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(o => o.send()), this.pushBuffer = []
          }), this._onClose(() => {
              this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = $e.closed, this.socket._remove(this)
          }), this._onError(o => {
              this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o), this.state = $e.errored, this.rejoinTimer.scheduleTimeout())
          }), this.joinPush.receive("timeout", () => {
              this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = $e.errored, this.rejoinTimer.scheduleTimeout())
          }), this.joinPush.receive("error", o => {
              this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o), this.state = $e.errored, this.rejoinTimer.scheduleTimeout())
          }), this._on(ln.reply, {}, (o, a) => {
              this._trigger(this._replyEventName(a), o)
          }), this.presence = new fa(this), this.broadcastEndpointURL = OE(this.socket.endPoint), this.private = this.params.config.private || !1, !this.private && (!((i = (s = this.params.config) === null || s === void 0 ? void 0 : s.broadcast) === null || i === void 0) && i.replay)) throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`
  }
  subscribe(t, n = this.timeout) {
      var r, s, i;
      if (this.socket.isConnected() || this.socket.connect(), this.state == $e.closed) {
          const {
              config: {
                  broadcast: o,
                  presence: a,
                  private: l
              }
          } = this.params, c = (s = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map(f => f.filter)) !== null && s !== void 0 ? s : [], u = !!this.bindings[pa.PRESENCE] && this.bindings[pa.PRESENCE].length > 0 || ((i = this.params.config.presence) === null || i === void 0 ? void 0 : i.enabled) === !0, d = {}, h = {
              broadcast: o,
              presence: Object.assign(Object.assign({}, a), {
                  enabled: u
              }),
              postgres_changes: c,
              private: l
          };
          this.socket.accessTokenValue && (d.access_token = this.socket.accessTokenValue), this._onError(f => t == null ? void 0 : t($n.CHANNEL_ERROR, f)), this._onClose(() => t == null ? void 0 : t($n.CLOSED)), this.updateJoinPayload(Object.assign({
              config: h
          }, d)), this.joinedOnce = !0, this._rejoin(n), this.joinPush.receive("ok", async ({
              postgres_changes: f
          }) => {
              var x;
              if (this.socket._isManualToken() || this.socket.setAuth(), f === void 0) {
                  t == null || t($n.SUBSCRIBED);
                  return
              } else {
                  const m = this.bindings.postgres_changes,
                      b = (x = m == null ? void 0 : m.length) !== null && x !== void 0 ? x : 0,
                      v = [];
                  for (let y = 0; y < b; y++) {
                      const w = m[y],
                          {
                              filter: {
                                  event: S,
                                  schema: _,
                                  table: E,
                                  filter: T
                              }
                          } = w,
                          k = f && f[y];
                      if (k && k.event === S && Mi.isFilterValueEqual(k.schema, _) && Mi.isFilterValueEqual(k.table, E) && Mi.isFilterValueEqual(k.filter, T)) v.push(Object.assign(Object.assign({}, w), {
                          id: k.id
                      }));
                      else {
                          this.unsubscribe(), this.state = $e.errored, t == null || t($n.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                          return
                      }
                  }
                  this.bindings.postgres_changes = v, t && t($n.SUBSCRIBED);
                  return
              }
          }).receive("error", f => {
              this.state = $e.errored, t == null || t($n.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(f).join(", ") || "error")))
          }).receive("timeout", () => {
              t == null || t($n.TIMED_OUT)
          })
      }
      return this
  }
  presenceState() {
      return this.presence.state
  }
  async track(t, n = {}) {
      return await this.send({
          type: "presence",
          event: "track",
          payload: t
      }, n.timeout || this.timeout)
  }
  async untrack(t = {}) {
      return await this.send({
          type: "presence",
          event: "untrack"
      }, t)
  }
  on(t, n, r) {
      return this.state === $e.joined && t === pa.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`), this.unsubscribe().then(async () => await this.subscribe())), this._on(t, n, r)
  }
  async httpSend(t, n, r = {}) {
      var s;
      if (n == null) return Promise.reject("Payload is required for httpSend()");
      const i = {
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
      };
      this.socket.accessTokenValue && (i.Authorization = `Bearer ${this.socket.accessTokenValue}`);
      const o = {
              method: "POST",
              headers: i,
              body: JSON.stringify({
                  messages: [{
                      topic: this.subTopic,
                      event: t,
                      payload: n,
                      private: this.private
                  }]
              })
          },
          a = await this._fetchWithTimeout(this.broadcastEndpointURL, o, (s = r.timeout) !== null && s !== void 0 ? s : this.timeout);
      if (a.status === 202) return {
          success: !0
      };
      let l = a.statusText;
      try {
          const c = await a.json();
          l = c.error || c.message || l
      } catch {}
      return Promise.reject(new Error(l))
  }
  async send(t, n = {}) {
      var r, s;
      if (!this._canPush() && t.type === "broadcast") {
          console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
          const {
              event: i,
              payload: o
          } = t, a = {
              apikey: this.socket.apiKey ? this.socket.apiKey : "",
              "Content-Type": "application/json"
          };
          this.socket.accessTokenValue && (a.Authorization = `Bearer ${this.socket.accessTokenValue}`);
          const l = {
              method: "POST",
              headers: a,
              body: JSON.stringify({
                  messages: [{
                      topic: this.subTopic,
                      event: i,
                      payload: o,
                      private: this.private
                  }]
              })
          };
          try {
              const c = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (r = n.timeout) !== null && r !== void 0 ? r : this.timeout);
              return await ((s = c.body) === null || s === void 0 ? void 0 : s.cancel()), c.ok ? "ok" : "error"
          } catch (c) {
              return c.name === "AbortError" ? "timed out" : "error"
          }
      } else return new Promise(i => {
          var o, a, l;
          const c = this._push(t.type, t, n.timeout || this.timeout);
          t.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && i("ok"), c.receive("ok", () => i("ok")), c.receive("error", () => i("error")), c.receive("timeout", () => i("timed out"))
      })
  }
  updateJoinPayload(t) {
      this.joinPush.updatePayload(t)
  }
  unsubscribe(t = this.timeout) {
      this.state = $e.leaving;
      const n = () => {
          this.socket.log("channel", `leave ${this.topic}`), this._trigger(ln.close, "leave", this._joinRef())
      };
      this.joinPush.destroy();
      let r = null;
      return new Promise(s => {
          r = new eh(this, ln.leave, {}, t), r.receive("ok", () => {
              n(), s("ok")
          }).receive("timeout", () => {
              n(), s("timed out")
          }).receive("error", () => {
              s("error")
          }), r.send(), this._canPush() || r.trigger("ok", {})
      }).finally(() => {
          r == null || r.destroy()
      })
  }
  teardown() {
      this.pushBuffer.forEach(t => t.destroy()), this.pushBuffer = [], this.rejoinTimer.reset(), this.joinPush.destroy(), this.state = $e.closed, this.bindings = {}
  }
  async _fetchWithTimeout(t, n, r) {
      const s = new AbortController,
          i = setTimeout(() => s.abort(), r),
          o = await this.socket.fetch(t, Object.assign(Object.assign({}, n), {
              signal: s.signal
          }));
      return clearTimeout(i), o
  }
  _push(t, n, r = this.timeout) {
      if (!this.joinedOnce) throw `tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
      let s = new eh(this, t, n, r);
      return this._canPush() ? s.send() : this._addToPushBuffer(s), s
  }
  _addToPushBuffer(t) {
      if (t.startTimeout(), this.pushBuffer.push(t), this.pushBuffer.length > jF) {
          const n = this.pushBuffer.shift();
          n && (n.destroy(), this.socket.log("channel", `discarded push due to buffer overflow: ${n.event}`, n.payload))
      }
  }
  _onMessage(t, n, r) {
      return n
  }
  _isMember(t) {
      return this.topic === t
  }
  _joinRef() {
      return this.joinPush.ref
  }
  _trigger(t, n, r) {
      var s, i;
      const o = t.toLocaleLowerCase(),
          {
              close: a,
              error: l,
              leave: c,
              join: u
          } = ln;
      if (r && [a, l, c, u].indexOf(o) >= 0 && r !== this._joinRef()) return;
      let h = this._onMessage(o, n, r);
      if (n && !h) throw "channel onMessage callbacks must return the payload, modified or unmodified";
      ["insert", "update", "delete"].includes(o) ? (s = this.bindings.postgres_changes) === null || s === void 0 || s.filter(f => {
          var x, m, b;
          return ((x = f.filter) === null || x === void 0 ? void 0 : x.event) === "*" || ((b = (m = f.filter) === null || m === void 0 ? void 0 : m.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase()) === o
      }).map(f => f.callback(h, r)) : (i = this.bindings[o]) === null || i === void 0 || i.filter(f => {
          var x, m, b, v, y, w;
          if (["broadcast", "presence", "postgres_changes"].includes(o))
              if ("id" in f) {
                  const S = f.id,
                      _ = (x = f.filter) === null || x === void 0 ? void 0 : x.event;
                  return S && ((m = n.ids) === null || m === void 0 ? void 0 : m.includes(S)) && (_ === "*" || (_ == null ? void 0 : _.toLocaleLowerCase()) === ((b = n.data) === null || b === void 0 ? void 0 : b.type.toLocaleLowerCase()))
              } else {
                  const S = (y = (v = f == null ? void 0 : f.filter) === null || v === void 0 ? void 0 : v.event) === null || y === void 0 ? void 0 : y.toLocaleLowerCase();
                  return S === "*" || S === ((w = n == null ? void 0 : n.event) === null || w === void 0 ? void 0 : w.toLocaleLowerCase())
              }
          else return f.type.toLocaleLowerCase() === o
      }).map(f => {
          if (typeof h == "object" && "ids" in h) {
              const x = h.data,
                  {
                      schema: m,
                      table: b,
                      commit_timestamp: v,
                      type: y,
                      errors: w
                  } = x;
              h = Object.assign(Object.assign({}, {
                  schema: m,
                  table: b,
                  commit_timestamp: v,
                  eventType: y,
                  new: {},
                  old: {},
                  errors: w
              }), this._getPayloadRecords(x))
          }
          f.callback(h, r)
      })
  }
  _isClosed() {
      return this.state === $e.closed
  }
  _isJoined() {
      return this.state === $e.joined
  }
  _isJoining() {
      return this.state === $e.joining
  }
  _isLeaving() {
      return this.state === $e.leaving
  }
  _replyEventName(t) {
      return `chan_reply_${t}`
  }
  _on(t, n, r) {
      const s = t.toLocaleLowerCase(),
          i = {
              type: s,
              filter: n,
              callback: r
          };
      return this.bindings[s] ? this.bindings[s].push(i) : this.bindings[s] = [i], this
  }
  _off(t, n) {
      const r = t.toLocaleLowerCase();
      return this.bindings[r] && (this.bindings[r] = this.bindings[r].filter(s => {
          var i;
          return !(((i = s.type) === null || i === void 0 ? void 0 : i.toLocaleLowerCase()) === r && Mi.isEqual(s.filter, n))
      })), this
  }
  static isEqual(t, n) {
      if (Object.keys(t).length !== Object.keys(n).length) return !1;
      for (const r in t)
          if (t[r] !== n[r]) return !1;
      return !0
  }
  static isFilterValueEqual(t, n) {
      return (t ?? void 0) === (n ?? void 0)
  }
  _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin()
  }
  _onClose(t) {
      this._on(ln.close, {}, t)
  }
  _onError(t) {
      this._on(ln.error, {}, n => t(n))
  }
  _canPush() {
      return this.socket.isConnected() && this._isJoined()
  }
  _rejoin(t = this.timeout) {
      this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = $e.joining, this.joinPush.resend(t))
  }
  _getPayloadRecords(t) {
      const n = {
          new: {},
          old: {}
      };
      return (t.type === "INSERT" || t.type === "UPDATE") && (n.new = iw(t.columns, t.record)), (t.type === "UPDATE" || t.type === "DELETE") && (n.old = iw(t.columns, t.old_record)), n
  }
}
const th = () => {},
  Hl = {
      HEARTBEAT_INTERVAL: 25e3,
      RECONNECT_DELAY: 10,
      HEARTBEAT_TIMEOUT_FALLBACK: 100
  },
  UF = [1e3, 2e3, 5e3, 1e4],
  VF = 1e4,
  BF = `
addEventListener("message", (e) => {
  if (e.data.event === "start") {
    setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
  }
});`;
class zF {
  constructor(t, n) {
      var r;
      if (this.accessTokenValue = null, this.apiKey = null, this._manuallySetToken = !1, this.channels = new Array, this.endPoint = "", this.httpEndpoint = "", this.headers = {}, this.params = {}, this.timeout = op, this.transport = null, this.heartbeatIntervalMs = Hl.HEARTBEAT_INTERVAL, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.heartbeatCallback = th, this.ref = 0, this.reconnectTimer = null, this.vsn = sw, this.logger = th, this.conn = null, this.sendBuffer = [], this.serializer = new OF, this.stateChangeCallbacks = {
              open: [],
              close: [],
              error: [],
              message: []
          }, this.accessToken = null, this._connectionState = "disconnected", this._wasManualDisconnect = !1, this._authPromise = null, this._resolveFetch = s => s ? (...i) => s(...i) : (...i) => fetch(...i), !(!((r = n == null ? void 0 : n.params) === null || r === void 0) && r.apikey)) throw new Error("API key is required to connect to Realtime");
      this.apiKey = n.params.apikey, this.endPoint = `${t}/${ap.websocket}`, this.httpEndpoint = OE(t), this._initializeOptions(n), this._setupReconnectionTimer(), this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch)
  }
  connect() {
      if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
          if (this._setConnectionState("connecting"), this.accessToken && !this._authPromise && this._setAuthSafely("connect"), this.transport) this.conn = new this.transport(this.endpointURL());
          else try {
              this.conn = kF.createWebSocket(this.endpointURL())
          } catch (t) {
              this._setConnectionState("disconnected");
              const n = t.message;
              throw n.includes("Node.js") ? new Error(`${n}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

npm install ws

import ws from "ws"
const client = new RealtimeClient(url, {
  ...options,
  transport: ws
})`) : new Error(`WebSocket not available: ${n}`)
          }
          this._setupConnectionHandlers()
      }
  }
  endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, {
          vsn: this.vsn
      }))
  }
  disconnect(t, n) {
      if (!this.isDisconnecting())
          if (this._setConnectionState("disconnecting", !0), this.conn) {
              const r = setTimeout(() => {
                  this._setConnectionState("disconnected")
              }, 100);
              this.conn.onclose = () => {
                  clearTimeout(r), this._setConnectionState("disconnected")
              }, typeof this.conn.close == "function" && (t ? this.conn.close(t, n ?? "") : this.conn.close()), this._teardownConnection()
          } else this._setConnectionState("disconnected")
  }
  getChannels() {
      return this.channels
  }
  async removeChannel(t) {
      const n = await t.unsubscribe();
      return this.channels.length === 0 && this.disconnect(), n
  }
  async removeAllChannels() {
      const t = await Promise.all(this.channels.map(n => n.unsubscribe()));
      return this.channels = [], this.disconnect(), t
  }
  log(t, n, r) {
      this.logger(t, n, r)
  }
  connectionState() {
      switch (this.conn && this.conn.readyState) {
          case xr.connecting:
              return xs.Connecting;
          case xr.open:
              return xs.Open;
          case xr.closing:
              return xs.Closing;
          default:
              return xs.Closed
      }
  }
  isConnected() {
      return this.connectionState() === xs.Open
  }
  isConnecting() {
      return this._connectionState === "connecting"
  }
  isDisconnecting() {
      return this._connectionState === "disconnecting"
  }
  channel(t, n = {
      config: {}
  }) {
      const r = `realtime:${t}`,
          s = this.getChannels().find(i => i.topic === r);
      if (s) return s;
      {
          const i = new Mi(`realtime:${t}`, n, this);
          return this.channels.push(i), i
      }
  }
  push(t) {
      const {
          topic: n,
          event: r,
          payload: s,
          ref: i
      } = t, o = () => {
          this.encode(t, a => {
              var l;
              (l = this.conn) === null || l === void 0 || l.send(a)
          })
      };
      this.log("push", `${n} ${r} (${i})`, s), this.isConnected() ? o() : this.sendBuffer.push(o)
  }
  async setAuth(t = null) {
      this._authPromise = this._performAuth(t);
      try {
          await this._authPromise
      } finally {
          this._authPromise = null
      }
  }
  _isManualToken() {
      return this._manuallySetToken
  }
  async sendHeartbeat() {
      var t;
      if (!this.isConnected()) {
          try {
              this.heartbeatCallback("disconnected")
          } catch (n) {
              this.log("error", "error in heartbeat callback", n)
          }
          return
      }
      if (this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
          try {
              this.heartbeatCallback("timeout")
          } catch (n) {
              this.log("error", "error in heartbeat callback", n)
          }
          this._wasManualDisconnect = !1, (t = this.conn) === null || t === void 0 || t.close(NF, "heartbeat timeout"), setTimeout(() => {
              var n;
              this.isConnected() || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout()
          }, Hl.HEARTBEAT_TIMEOUT_FALLBACK);
          return
      }
      this.pendingHeartbeatRef = this._makeRef(), this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef
      });
      try {
          this.heartbeatCallback("sent")
      } catch (n) {
          this.log("error", "error in heartbeat callback", n)
      }
      this._setAuthSafely("heartbeat")
  }
  onHeartbeat(t) {
      this.heartbeatCallback = t
  }
  flushSendBuffer() {
      this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(t => t()), this.sendBuffer = [])
  }
  _makeRef() {
      let t = this.ref + 1;
      return t === this.ref ? this.ref = 0 : this.ref = t, this.ref.toString()
  }
  _leaveOpenTopic(t) {
      let n = this.channels.find(r => r.topic === t && (r._isJoined() || r._isJoining()));
      n && (this.log("transport", `leaving duplicate topic "${t}"`), n.unsubscribe())
  }
  _remove(t) {
      this.channels = this.channels.filter(n => n.topic !== t.topic)
  }
  _onConnMessage(t) {
      this.decode(t.data, n => {
          if (n.topic === "phoenix" && n.event === "phx_reply") try {
              this.heartbeatCallback(n.payload.status === "ok" ? "ok" : "error")
          } catch (c) {
              this.log("error", "error in heartbeat callback", c)
          }
          n.ref && n.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
          const {
              topic: r,
              event: s,
              payload: i,
              ref: o
          } = n, a = o ? `(${o})` : "", l = i.status || "";
          this.log("receive", `${l} ${r} ${s} ${a}`.trim(), i), this.channels.filter(c => c._isMember(r)).forEach(c => c._trigger(s, i, o)), this._triggerStateCallbacks("message", n)
      })
  }
  _clearTimer(t) {
      var n;
      t === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer), this.heartbeatTimer = void 0) : t === "reconnect" && ((n = this.reconnectTimer) === null || n === void 0 || n.reset())
  }
  _clearAllTimers() {
      this._clearTimer("heartbeat"), this._clearTimer("reconnect")
  }
  _setupConnectionHandlers() {
      this.conn && ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"), this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = t => this._onConnError(t), this.conn.onmessage = t => this._onConnMessage(t), this.conn.onclose = t => this._onConnClose(t), this.conn.readyState === xr.open && this._onConnOpen())
  }
  _teardownConnection() {
      if (this.conn) {
          if (this.conn.readyState === xr.open || this.conn.readyState === xr.connecting) try {
              this.conn.close()
          } catch (t) {
              this.log("error", "Error closing connection", t)
          }
          this.conn.onopen = null, this.conn.onerror = null, this.conn.onmessage = null, this.conn.onclose = null, this.conn = null
      }
      this._clearAllTimers(), this._terminateWorker(), this.channels.forEach(t => t.teardown())
  }
  _onConnOpen() {
      this._setConnectionState("connected"), this.log("transport", `connected to ${this.endpointURL()}`), (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then(() => {
          this.flushSendBuffer()
      }).catch(n => {
          this.log("error", "error waiting for auth on connect", n), this.flushSendBuffer()
      }), this._clearTimer("reconnect"), this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(), this._triggerStateCallbacks("open")
  }
  _startHeartbeat() {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs)
  }
  _startWorkerHeartbeat() {
      this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
      const t = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(t), this.workerRef.onerror = n => {
          this.log("worker", "worker error", n.message), this._terminateWorker()
      }, this.workerRef.onmessage = n => {
          n.data.event === "keepAlive" && this.sendHeartbeat()
      }, this.workerRef.postMessage({
          event: "start",
          interval: this.heartbeatIntervalMs
      })
  }
  _terminateWorker() {
      this.workerRef && (this.log("worker", "terminating worker"), this.workerRef.terminate(), this.workerRef = void 0)
  }
  _onConnClose(t) {
      var n;
      this._setConnectionState("disconnected"), this.log("transport", "close", t), this._triggerChanError(), this._clearTimer("heartbeat"), this._wasManualDisconnect || (n = this.reconnectTimer) === null || n === void 0 || n.scheduleTimeout(), this._triggerStateCallbacks("close", t)
  }
  _onConnError(t) {
      this._setConnectionState("disconnected"), this.log("transport", `${t}`), this._triggerChanError(), this._triggerStateCallbacks("error", t)
  }
  _triggerChanError() {
      this.channels.forEach(t => t._trigger(ln.error))
  }
  _appendParams(t, n) {
      if (Object.keys(n).length === 0) return t;
      const r = t.match(/\?/) ? "&" : "?",
          s = new URLSearchParams(n);
      return `${t}${r}${s}`
  }
  _workerObjectUrl(t) {
      let n;
      if (t) n = t;
      else {
          const r = new Blob([BF], {
              type: "application/javascript"
          });
          n = URL.createObjectURL(r)
      }
      return n
  }
  _setConnectionState(t, n = !1) {
      this._connectionState = t, t === "connecting" ? this._wasManualDisconnect = !1 : t === "disconnecting" && (this._wasManualDisconnect = n)
  }
  async _performAuth(t = null) {
      let n, r = !1;
      if (t) n = t, r = !0;
      else if (this.accessToken) try {
          n = await this.accessToken()
      } catch (s) {
          this.log("error", "Error fetching access token from callback", s), n = this.accessTokenValue
      } else n = this.accessTokenValue;
      r ? this._manuallySetToken = !0 : this.accessToken && (this._manuallySetToken = !1), this.accessTokenValue != n && (this.accessTokenValue = n, this.channels.forEach(s => {
          const i = {
              access_token: n,
              version: PF
          };
          n && s.updateJoinPayload(i), s.joinedOnce && s._isJoined() && s._push(ln.access_token, {
              access_token: n
          })
      }))
  }
  async _waitForAuthIfNeeded() {
      this._authPromise && await this._authPromise
  }
  _setAuthSafely(t = "general") {
      this._isManualToken() || this.setAuth().catch(n => {
          this.log("error", `Error setting auth in ${t}`, n)
      })
  }
  _triggerStateCallbacks(t, n) {
      try {
          this.stateChangeCallbacks[t].forEach(r => {
              try {
                  r(n)
              } catch (s) {
                  this.log("error", `error in ${t} callback`, s)
              }
          })
      } catch (r) {
          this.log("error", `error triggering ${t} callbacks`, r)
      }
  }
  _setupReconnectionTimer() {
      this.reconnectTimer = new NE(async () => {
          setTimeout(async () => {
              await this._waitForAuthIfNeeded(), this.isConnected() || this.connect()
          }, Hl.RECONNECT_DELAY)
      }, this.reconnectAfterMs)
  }
  _initializeOptions(t) {
      var n, r, s, i, o, a, l, c, u, d, h, f;
      switch (this.transport = (n = t == null ? void 0 : t.transport) !== null && n !== void 0 ? n : null, this.timeout = (r = t == null ? void 0 : t.timeout) !== null && r !== void 0 ? r : op, this.heartbeatIntervalMs = (s = t == null ? void 0 : t.heartbeatIntervalMs) !== null && s !== void 0 ? s : Hl.HEARTBEAT_INTERVAL, this.worker = (i = t == null ? void 0 : t.worker) !== null && i !== void 0 ? i : !1, this.accessToken = (o = t == null ? void 0 : t.accessToken) !== null && o !== void 0 ? o : null, this.heartbeatCallback = (a = t == null ? void 0 : t.heartbeatCallback) !== null && a !== void 0 ? a : th, this.vsn = (l = t == null ? void 0 : t.vsn) !== null && l !== void 0 ? l : sw, t != null && t.params && (this.params = t.params), t != null && t.logger && (this.logger = t.logger), (t != null && t.logLevel || t != null && t.log_level) && (this.logLevel = t.logLevel || t.log_level, this.params = Object.assign(Object.assign({}, this.params), {
              log_level: this.logLevel
          })), this.reconnectAfterMs = (c = t == null ? void 0 : t.reconnectAfterMs) !== null && c !== void 0 ? c : x => UF[x - 1] || VF, this.vsn) {
          case AE:
              this.encode = (u = t == null ? void 0 : t.encode) !== null && u !== void 0 ? u : (x, m) => m(JSON.stringify(x)), this.decode = (d = t == null ? void 0 : t.decode) !== null && d !== void 0 ? d : (x, m) => m(JSON.parse(x));
              break;
          case AF:
              this.encode = (h = t == null ? void 0 : t.encode) !== null && h !== void 0 ? h : this.serializer.encode.bind(this.serializer), this.decode = (f = t == null ? void 0 : t.decode) !== null && f !== void 0 ? f : this.serializer.decode.bind(this.serializer);
              break;
          default:
              throw new Error(`Unsupported serializer version: ${this.vsn}`)
      }
      if (this.worker) {
          if (typeof window < "u" && !window.Worker) throw new Error("Web Worker is not supported");
          this.workerUrl = t == null ? void 0 : t.workerUrl
      }
  }
}
var za = class extends Error {
  constructor(e, t) {
      var n;
      super(e), this.name = "IcebergError", this.status = t.status, this.icebergType = t.icebergType, this.icebergCode = t.icebergCode, this.details = t.details, this.isCommitStateUnknown = t.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(t.status) && ((n = t.icebergType) == null ? void 0 : n.includes("CommitState")) === !0
  }
  isNotFound() {
      return this.status === 404
  }
  isConflict() {
      return this.status === 409
  }
  isAuthenticationTimeout() {
      return this.status === 419
  }
};

function WF(e, t, n) {
  const r = new URL(t, e);
  if (n)
      for (const [s, i] of Object.entries(n)) i !== void 0 && r.searchParams.set(s, i);
  return r.toString()
}
async function HF(e) {
  return !e || e.type === "none" ? {} : e.type === "bearer" ? {
      Authorization: `Bearer ${e.token}`
  } : e.type === "header" ? {
      [e.name]: e.value
  } : e.type === "custom" ? await e.getHeaders() : {}
}

function KF(e) {
  const t = e.fetchImpl ?? globalThis.fetch;
  return {
      async request({
          method: n,
          path: r,
          query: s,
          body: i,
          headers: o
      }) {
          const a = WF(e.baseUrl, r, s),
              l = await HF(e.auth),
              c = await t(a, {
                  method: n,
                  headers: {
                      ...i ? {
                          "Content-Type": "application/json"
                      } : {},
                      ...l,
                      ...o
                  },
                  body: i ? JSON.stringify(i) : void 0
              }),
              u = await c.text(),
              d = (c.headers.get("content-type") || "").includes("application/json"),
              h = d && u ? JSON.parse(u) : u;
          if (!c.ok) {
              const f = d ? h : void 0,
                  x = f == null ? void 0 : f.error;
              throw new za((x == null ? void 0 : x.message) ?? `Request failed with status ${c.status}`, {
                  status: c.status,
                  icebergType: x == null ? void 0 : x.type,
                  icebergCode: x == null ? void 0 : x.code,
                  details: f
              })
          }
          return {
              status: c.status,
              headers: c.headers,
              data: h
          }
      }
  }
}

function Kl(e) {
  return e.join("")
}
var qF = class {
  constructor(e, t = "") {
      this.client = e, this.prefix = t
  }
  async listNamespaces(e) {
      const t = e ? {
          parent: Kl(e.namespace)
      } : void 0;
      return (await this.client.request({
          method: "GET",
          path: `${this.prefix}/namespaces`,
          query: t
      })).data.namespaces.map(r => ({
          namespace: r
      }))
  }
  async createNamespace(e, t) {
      const n = {
          namespace: e.namespace,
          properties: t == null ? void 0 : t.properties
      };
      return (await this.client.request({
          method: "POST",
          path: `${this.prefix}/namespaces`,
          body: n
      })).data
  }
  async dropNamespace(e) {
      await this.client.request({
          method: "DELETE",
          path: `${this.prefix}/namespaces/${Kl(e.namespace)}`
      })
  }
  async loadNamespaceMetadata(e) {
      return {
          properties: (await this.client.request({
              method: "GET",
              path: `${this.prefix}/namespaces/${Kl(e.namespace)}`
          })).data.properties
      }
  }
  async namespaceExists(e) {
      try {
          return await this.client.request({
              method: "HEAD",
              path: `${this.prefix}/namespaces/${Kl(e.namespace)}`
          }), !0
      } catch (t) {
          if (t instanceof za && t.status === 404) return !1;
          throw t
      }
  }
  async createNamespaceIfNotExists(e, t) {
      try {
          return await this.createNamespace(e, t)
      } catch (n) {
          if (n instanceof za && n.status === 409) return;
          throw n
      }
  }
};

function ai(e) {
  return e.join("")
}
var GF = class {
      constructor(e, t = "", n) {
          this.client = e, this.prefix = t, this.accessDelegation = n
      }
      async listTables(e) {
          return (await this.client.request({
              method: "GET",
              path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables`
          })).data.identifiers
      }
      async createTable(e, t) {
          const n = {};
          return this.accessDelegation && (n["X-Iceberg-Access-Delegation"] = this.accessDelegation), (await this.client.request({
              method: "POST",
              path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables`,
              body: t,
              headers: n
          })).data.metadata
      }
      async updateTable(e, t) {
          const n = await this.client.request({
              method: "POST",
              path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables/${e.name}`,
              body: t
          });
          return {
              "metadata-location": n.data["metadata-location"],
              metadata: n.data.metadata
          }
      }
      async dropTable(e, t) {
          await this.client.request({
              method: "DELETE",
              path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables/${e.name}`,
              query: {
                  purgeRequested: String((t == null ? void 0 : t.purge) ?? !1)
              }
          })
      }
      async loadTable(e) {
          const t = {};
          return this.accessDelegation && (t["X-Iceberg-Access-Delegation"] = this.accessDelegation), (await this.client.request({
              method: "GET",
              path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables/${e.name}`,
              headers: t
          })).data.metadata
      }
      async tableExists(e) {
          const t = {};
          this.accessDelegation && (t["X-Iceberg-Access-Delegation"] = this.accessDelegation);
          try {
              return await this.client.request({
                  method: "HEAD",
                  path: `${this.prefix}/namespaces/${ai(e.namespace)}/tables/${e.name}`,
                  headers: t
              }), !0
          } catch (n) {
              if (n instanceof za && n.status === 404) return !1;
              throw n
          }
      }
      async createTableIfNotExists(e, t) {
          try {
              return await this.createTable(e, t)
          } catch (n) {
              if (n instanceof za && n.status === 409) return await this.loadTable({
                  namespace: e.namespace,
                  name: t.name
              });
              throw n
          }
      }
  },
  QF = class {
      constructor(e) {
          var r;
          let t = "v1";
          e.catalogName && (t += `/${e.catalogName}`);
          const n = e.baseUrl.endsWith("/") ? e.baseUrl : `${e.baseUrl}/`;
          this.client = KF({
              baseUrl: n,
              auth: e.auth,
              fetchImpl: e.fetch
          }), this.accessDelegation = (r = e.accessDelegation) == null ? void 0 : r.join(","), this.namespaceOps = new qF(this.client, t), this.tableOps = new GF(this.client, t, this.accessDelegation)
      }
      async listNamespaces(e) {
          return this.namespaceOps.listNamespaces(e)
      }
      async createNamespace(e, t) {
          return this.namespaceOps.createNamespace(e, t)
      }
      async dropNamespace(e) {
          await this.namespaceOps.dropNamespace(e)
      }
      async loadNamespaceMetadata(e) {
          return this.namespaceOps.loadNamespaceMetadata(e)
      }
      async listTables(e) {
          return this.tableOps.listTables(e)
      }
      async createTable(e, t) {
          return this.tableOps.createTable(e, t)
      }
      async updateTable(e, t) {
          return this.tableOps.updateTable(e, t)
      }
      async dropTable(e, t) {
          await this.tableOps.dropTable(e, t)
      }
      async loadTable(e) {
          return this.tableOps.loadTable(e)
      }
      async namespaceExists(e) {
          return this.namespaceOps.namespaceExists(e)
      }
      async tableExists(e) {
          return this.tableOps.tableExists(e)
      }
      async createNamespaceIfNotExists(e, t) {
          return this.namespaceOps.createNamespaceIfNotExists(e, t)
      }
      async createTableIfNotExists(e, t) {
          return this.tableOps.createTableIfNotExists(e, t)
      }
  },
  Hu = class extends Error {
      constructor(e) {
          super(e), this.__isStorageError = !0, this.name = "StorageError"
      }
  };

function _e(e) {
  return typeof e == "object" && e !== null && "__isStorageError" in e
}
var YF = class extends Hu {
      constructor(e, t, n) {
          super(e), this.name = "StorageApiError", this.status = t, this.statusCode = n
      }
      toJSON() {
          return {
              name: this.name,
              message: this.message,
              status: this.status,
              statusCode: this.statusCode
          }
      }
  },
  cp = class extends Hu {
      constructor(e, t) {
          super(e), this.name = "StorageUnknownError", this.originalError = t
      }
  };
const wg = e => e ? (...t) => e(...t) : (...t) => fetch(...t),
  JF = () => Response,
  up = e => {
      if (Array.isArray(e)) return e.map(n => up(n));
      if (typeof e == "function" || e !== Object(e)) return e;
      const t = {};
      return Object.entries(e).forEach(([n, r]) => {
          const s = n.replace(/([-_][a-z])/gi, i => i.toUpperCase().replace(/[-_]/g, ""));
          t[s] = up(r)
      }), t
  },
  XF = e => {
      if (typeof e != "object" || e === null) return !1;
      const t = Object.getPrototypeOf(e);
      return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
  },
  ZF = e => !e || typeof e != "string" || e.length === 0 || e.length > 100 || e.trim() !== e || e.includes("/") || e.includes("\\") ? !1 : /^[\w!.\*'() &$@=;:+,?-]+$/.test(e);

function Wa(e) {
  "@babel/helpers - typeof";
  return Wa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }, Wa(e)
}

function e4(e, t) {
  if (Wa(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
      var r = n.call(e, t || "default");
      if (Wa(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}

function t4(e) {
  var t = e4(e, "string");
  return Wa(t) == "symbol" ? t : t + ""
}

function n4(e, t, n) {
  return (t = t4(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
  }) : e[t] = n, e
}

function lw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(s) {
          return Object.getOwnPropertyDescriptor(e, s).enumerable
      })), n.push.apply(n, r)
  }
  return n
}

function K(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? lw(Object(n), !0).forEach(function(r) {
          n4(e, r, n[r])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lw(Object(n)).forEach(function(r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
      })
  }
  return e
}
const nh = e => {
      var t;
      return e.msg || e.message || e.error_description || (typeof e.error == "string" ? e.error : (t = e.error) === null || t === void 0 ? void 0 : t.message) || JSON.stringify(e)
  },
  r4 = async (e, t, n) => {
      e instanceof await JF() && !(n != null && n.noResolveJson) ? e.json().then(r => {
          const s = e.status || 500,
              i = (r == null ? void 0 : r.statusCode) || s + "";
          t(new YF(nh(r), s, i))
      }).catch(r => {
          t(new cp(nh(r), r))
      }) : t(new cp(nh(e), e))
  }, s4 = (e, t, n, r) => {
      const s = {
          method: e,
          headers: (t == null ? void 0 : t.headers) || {}
      };
      return e === "GET" || !r ? s : (XF(r) ? (s.headers = K({
          "Content-Type": "application/json"
      }, t == null ? void 0 : t.headers), s.body = JSON.stringify(r)) : s.body = r, t != null && t.duplex && (s.duplex = t.duplex), K(K({}, s), n))
  };
async function fl(e, t, n, r, s, i) {
  return new Promise((o, a) => {
      e(n, s4(t, r, s, i)).then(l => {
          if (!l.ok) throw l;
          return r != null && r.noResolveJson ? l : l.json()
      }).then(l => o(l)).catch(l => r4(l, a, r))
  })
}
async function Ha(e, t, n, r) {
  return fl(e, "GET", t, n, r)
}
async function rn(e, t, n, r, s) {
  return fl(e, "POST", t, r, s, n)
}
async function dp(e, t, n, r, s) {
  return fl(e, "PUT", t, r, s, n)
}
async function i4(e, t, n, r) {
  return fl(e, "HEAD", t, K(K({}, n), {}, {
      noResolveJson: !0
  }), r)
}
async function xg(e, t, n, r, s) {
  return fl(e, "DELETE", t, r, s, n)
}
var o4 = class {
  constructor(e, t) {
      this.downloadFn = e, this.shouldThrowOnError = t
  }
  then(e, t) {
      return this.execute().then(e, t)
  }
  async execute() {
      var e = this;
      try {
          return {
              data: (await e.downloadFn()).body,
              error: null
          }
      } catch (t) {
          if (e.shouldThrowOnError) throw t;
          if (_e(t)) return {
              data: null,
              error: t
          };
          throw t
      }
  }
};
let IE;
IE = Symbol.toStringTag;
var a4 = class {
  constructor(e, t) {
      this.downloadFn = e, this.shouldThrowOnError = t, this[IE] = "BlobDownloadBuilder", this.promise = null
  }
  asStream() {
      return new o4(this.downloadFn, this.shouldThrowOnError)
  }
  then(e, t) {
      return this.getPromise().then(e, t)
  } catch (e) {
      return this.getPromise().catch(e)
  } finally(e) {
      return this.getPromise().finally(e)
  }
  getPromise() {
      return this.promise || (this.promise = this.execute()), this.promise
  }
  async execute() {
      var e = this;
      try {
          return {
              data: await (await e.downloadFn()).blob(),
              error: null
          }
      } catch (t) {
          if (e.shouldThrowOnError) throw t;
          if (_e(t)) return {
              data: null,
              error: t
          };
          throw t
      }
  }
};
const l4 = {
      limit: 100,
      offset: 0,
      sortBy: {
          column: "name",
          order: "asc"
      }
  },
  cw = {
      cacheControl: "3600",
      contentType: "text/plain;charset=UTF-8",
      upsert: !1
  };
var c4 = class {
  constructor(e, t = {}, n, r) {
      this.shouldThrowOnError = !1, this.url = e, this.headers = t, this.bucketId = n, this.fetch = wg(r)
  }
  throwOnError() {
      return this.shouldThrowOnError = !0, this
  }
  async uploadOrUpdate(e, t, n, r) {
      var s = this;
      try {
          let i;
          const o = K(K({}, cw), r);
          let a = K(K({}, s.headers), e === "POST" && {
              "x-upsert": String(o.upsert)
          });
          const l = o.metadata;
          typeof Blob < "u" && n instanceof Blob ? (i = new FormData, i.append("cacheControl", o.cacheControl), l && i.append("metadata", s.encodeMetadata(l)), i.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (i = n, i.has("cacheControl") || i.append("cacheControl", o.cacheControl), l && !i.has("metadata") && i.append("metadata", s.encodeMetadata(l))) : (i = n, a["cache-control"] = `max-age=${o.cacheControl}`, a["content-type"] = o.contentType, l && (a["x-metadata"] = s.toBase64(s.encodeMetadata(l))), (typeof ReadableStream < "u" && i instanceof ReadableStream || i && typeof i == "object" && "pipe" in i && typeof i.pipe == "function") && !o.duplex && (o.duplex = "half")), r != null && r.headers && (a = K(K({}, a), r.headers));
          const c = s._removeEmptyFolders(t),
              u = s._getFinalPath(c),
              d = await (e == "PUT" ? dp : rn)(s.fetch, `${s.url}/object/${u}`, i, K({
                  headers: a
              }, o != null && o.duplex ? {
                  duplex: o.duplex
              } : {}));
          return {
              data: {
                  path: c,
                  id: d.Id,
                  fullPath: d.Key
              },
              error: null
          }
      } catch (i) {
          if (s.shouldThrowOnError) throw i;
          if (_e(i)) return {
              data: null,
              error: i
          };
          throw i
      }
  }
  async upload(e, t, n) {
      return this.uploadOrUpdate("POST", e, t, n)
  }
  async uploadToSignedUrl(e, t, n, r) {
      var s = this;
      const i = s._removeEmptyFolders(e),
          o = s._getFinalPath(i),
          a = new URL(s.url + `/object/upload/sign/${o}`);
      a.searchParams.set("token", t);
      try {
          let l;
          const c = K({
                  upsert: cw.upsert
              }, r),
              u = K(K({}, s.headers), {
                  "x-upsert": String(c.upsert)
              });
          return typeof Blob < "u" && n instanceof Blob ? (l = new FormData, l.append("cacheControl", c.cacheControl), l.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (l = n, l.append("cacheControl", c.cacheControl)) : (l = n, u["cache-control"] = `max-age=${c.cacheControl}`, u["content-type"] = c.contentType), {
              data: {
                  path: i,
                  fullPath: (await dp(s.fetch, a.toString(), l, {
                      headers: u
                  })).Key
              },
              error: null
          }
      } catch (l) {
          if (s.shouldThrowOnError) throw l;
          if (_e(l)) return {
              data: null,
              error: l
          };
          throw l
      }
  }
  async createSignedUploadUrl(e, t) {
      var n = this;
      try {
          let r = n._getFinalPath(e);
          const s = K({}, n.headers);
          t != null && t.upsert && (s["x-upsert"] = "true");
          const i = await rn(n.fetch, `${n.url}/object/upload/sign/${r}`, {}, {
                  headers: s
              }),
              o = new URL(n.url + i.url),
              a = o.searchParams.get("token");
          if (!a) throw new Hu("No token returned by API");
          return {
              data: {
                  signedUrl: o.toString(),
                  path: e,
                  token: a
              },
              error: null
          }
      } catch (r) {
          if (n.shouldThrowOnError) throw r;
          if (_e(r)) return {
              data: null,
              error: r
          };
          throw r
      }
  }
  async update(e, t, n) {
      return this.uploadOrUpdate("PUT", e, t, n)
  }
  async move(e, t, n) {
      var r = this;
      try {
          return {
              data: await rn(r.fetch, `${r.url}/object/move`, {
                  bucketId: r.bucketId,
                  sourceKey: e,
                  destinationKey: t,
                  destinationBucket: n == null ? void 0 : n.destinationBucket
              }, {
                  headers: r.headers
              }),
              error: null
          }
      } catch (s) {
          if (r.shouldThrowOnError) throw s;
          if (_e(s)) return {
              data: null,
              error: s
          };
          throw s
      }
  }
  async copy(e, t, n) {
      var r = this;
      try {
          return {
              data: {
                  path: (await rn(r.fetch, `${r.url}/object/copy`, {
                      bucketId: r.bucketId,
                      sourceKey: e,
                      destinationKey: t,
                      destinationBucket: n == null ? void 0 : n.destinationBucket
                  }, {
                      headers: r.headers
                  })).Key
              },
              error: null
          }
      } catch (s) {
          if (r.shouldThrowOnError) throw s;
          if (_e(s)) return {
              data: null,
              error: s
          };
          throw s
      }
  }
  async createSignedUrl(e, t, n) {
      var r = this;
      try {
          let s = r._getFinalPath(e),
              i = await rn(r.fetch, `${r.url}/object/sign/${s}`, K({
                  expiresIn: t
              }, n != null && n.transform ? {
                  transform: n.transform
              } : {}), {
                  headers: r.headers
              });
          const o = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
          return i = {
              signedUrl: encodeURI(`${r.url}${i.signedURL}${o}`)
          }, {
              data: i,
              error: null
          }
      } catch (s) {
          if (r.shouldThrowOnError) throw s;
          if (_e(s)) return {
              data: null,
              error: s
          };
          throw s
      }
  }
  async createSignedUrls(e, t, n) {
      var r = this;
      try {
          const s = await rn(r.fetch, `${r.url}/object/sign/${r.bucketId}`, {
                  expiresIn: t,
                  paths: e
              }, {
                  headers: r.headers
              }),
              i = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
          return {
              data: s.map(o => K(K({}, o), {}, {
                  signedUrl: o.signedURL ? encodeURI(`${r.url}${o.signedURL}${i}`) : null
              })),
              error: null
          }
      } catch (s) {
          if (r.shouldThrowOnError) throw s;
          if (_e(s)) return {
              data: null,
              error: s
          };
          throw s
      }
  }
  download(e, t) {
      const n = typeof(t == null ? void 0 : t.transform) < "u" ? "render/image/authenticated" : "object",
          r = this.transformOptsToQueryString((t == null ? void 0 : t.transform) || {}),
          s = r ? `?${r}` : "",
          i = this._getFinalPath(e),
          o = () => Ha(this.fetch, `${this.url}/${n}/${i}${s}`, {
              headers: this.headers,
              noResolveJson: !0
          });
      return new a4(o, this.shouldThrowOnError)
  }
  async info(e) {
      var t = this;
      const n = t._getFinalPath(e);
      try {
          return {
              data: up(await Ha(t.fetch, `${t.url}/object/info/${n}`, {
                  headers: t.headers
              })),
              error: null
          }
      } catch (r) {
          if (t.shouldThrowOnError) throw r;
          if (_e(r)) return {
              data: null,
              error: r
          };
          throw r
      }
  }
  async exists(e) {
      var t = this;
      const n = t._getFinalPath(e);
      try {
          return await i4(t.fetch, `${t.url}/object/${n}`, {
              headers: t.headers
          }), {
              data: !0,
              error: null
          }
      } catch (r) {
          if (t.shouldThrowOnError) throw r;
          if (_e(r) && r instanceof cp) {
              const s = r.originalError;
              if ([400, 404].includes(s == null ? void 0 : s.status)) return {
                  data: !1,
                  error: r
              }
          }
          throw r
      }
  }
  getPublicUrl(e, t) {
      const n = this._getFinalPath(e),
          r = [],
          s = t != null && t.download ? `download=${t.download === !0 ? "" : t.download}` : "";
      s !== "" && r.push(s);
      const i = typeof(t == null ? void 0 : t.transform) < "u" ? "render/image" : "object",
          o = this.transformOptsToQueryString((t == null ? void 0 : t.transform) || {});
      o !== "" && r.push(o);
      let a = r.join("&");
      return a !== "" && (a = `?${a}`), {
          data: {
              publicUrl: encodeURI(`${this.url}/${i}/public/${n}${a}`)
          }
      }
  }
  async remove(e) {
      var t = this;
      try {
          return {
              data: await xg(t.fetch, `${t.url}/object/${t.bucketId}`, {
                  prefixes: e
              }, {
                  headers: t.headers
              }),
              error: null
          }
      } catch (n) {
          if (t.shouldThrowOnError) throw n;
          if (_e(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async list(e, t, n) {
      var r = this;
      try {
          const s = K(K(K({}, l4), t), {}, {
              prefix: e || ""
          });
          return {
              data: await rn(r.fetch, `${r.url}/object/list/${r.bucketId}`, s, {
                  headers: r.headers
              }, n),
              error: null
          }
      } catch (s) {
          if (r.shouldThrowOnError) throw s;
          if (_e(s)) return {
              data: null,
              error: s
          };
          throw s
      }
  }
  async listV2(e, t) {
      var n = this;
      try {
          const r = K({}, e);
          return {
              data: await rn(n.fetch, `${n.url}/object/list-v2/${n.bucketId}`, r, {
                  headers: n.headers
              }, t),
              error: null
          }
      } catch (r) {
          if (n.shouldThrowOnError) throw r;
          if (_e(r)) return {
              data: null,
              error: r
          };
          throw r
      }
  }
  encodeMetadata(e) {
      return JSON.stringify(e)
  }
  toBase64(e) {
      return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
  }
  _getFinalPath(e) {
      return `${this.bucketId}/${e.replace(/^\/+/, "")}`
  }
  _removeEmptyFolders(e) {
      return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
  }
  transformOptsToQueryString(e) {
      const t = [];
      return e.width && t.push(`width=${e.width}`), e.height && t.push(`height=${e.height}`), e.resize && t.push(`resize=${e.resize}`), e.format && t.push(`format=${e.format}`), e.quality && t.push(`quality=${e.quality}`), t.join("&")
  }
};
const DE = "2.89.0",
  ME = {
      "X-Client-Info": `storage-js/${DE}`
  };
var u4 = class {
      constructor(e, t = {}, n, r) {
          this.shouldThrowOnError = !1;
          const s = new URL(e);
          r != null && r.useNewHostname && /supabase\.(co|in|red)$/.test(s.hostname) && !s.hostname.includes("storage.supabase.") && (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")), this.url = s.href.replace(/\/$/, ""), this.headers = K(K({}, ME), t), this.fetch = wg(n)
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      async listBuckets(e) {
          var t = this;
          try {
              const n = t.listBucketOptionsToQueryString(e);
              return {
                  data: await Ha(t.fetch, `${t.url}/bucket${n}`, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async getBucket(e) {
          var t = this;
          try {
              return {
                  data: await Ha(t.fetch, `${t.url}/bucket/${e}`, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async createBucket(e, t = {
          public: !1
      }) {
          var n = this;
          try {
              return {
                  data: await rn(n.fetch, `${n.url}/bucket`, {
                      id: e,
                      name: e,
                      type: t.type,
                      public: t.public,
                      file_size_limit: t.fileSizeLimit,
                      allowed_mime_types: t.allowedMimeTypes
                  }, {
                      headers: n.headers
                  }),
                  error: null
              }
          } catch (r) {
              if (n.shouldThrowOnError) throw r;
              if (_e(r)) return {
                  data: null,
                  error: r
              };
              throw r
          }
      }
      async updateBucket(e, t) {
          var n = this;
          try {
              return {
                  data: await dp(n.fetch, `${n.url}/bucket/${e}`, {
                      id: e,
                      name: e,
                      public: t.public,
                      file_size_limit: t.fileSizeLimit,
                      allowed_mime_types: t.allowedMimeTypes
                  }, {
                      headers: n.headers
                  }),
                  error: null
              }
          } catch (r) {
              if (n.shouldThrowOnError) throw r;
              if (_e(r)) return {
                  data: null,
                  error: r
              };
              throw r
          }
      }
      async emptyBucket(e) {
          var t = this;
          try {
              return {
                  data: await rn(t.fetch, `${t.url}/bucket/${e}/empty`, {}, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async deleteBucket(e) {
          var t = this;
          try {
              return {
                  data: await xg(t.fetch, `${t.url}/bucket/${e}`, {}, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      listBucketOptionsToQueryString(e) {
          const t = {};
          return e && ("limit" in e && (t.limit = String(e.limit)), "offset" in e && (t.offset = String(e.offset)), e.search && (t.search = e.search), e.sortColumn && (t.sortColumn = e.sortColumn), e.sortOrder && (t.sortOrder = e.sortOrder)), Object.keys(t).length > 0 ? "?" + new URLSearchParams(t).toString() : ""
      }
  },
  d4 = class {
      constructor(e, t = {}, n) {
          this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = K(K({}, ME), t), this.fetch = wg(n)
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      async createBucket(e) {
          var t = this;
          try {
              return {
                  data: await rn(t.fetch, `${t.url}/bucket`, {
                      name: e
                  }, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async listBuckets(e) {
          var t = this;
          try {
              const n = new URLSearchParams;
              (e == null ? void 0 : e.limit) !== void 0 && n.set("limit", e.limit.toString()), (e == null ? void 0 : e.offset) !== void 0 && n.set("offset", e.offset.toString()), e != null && e.sortColumn && n.set("sortColumn", e.sortColumn), e != null && e.sortOrder && n.set("sortOrder", e.sortOrder), e != null && e.search && n.set("search", e.search);
              const r = n.toString(),
                  s = r ? `${t.url}/bucket?${r}` : `${t.url}/bucket`;
              return {
                  data: await Ha(t.fetch, s, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async deleteBucket(e) {
          var t = this;
          try {
              return {
                  data: await xg(t.fetch, `${t.url}/bucket/${e}`, {}, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (_e(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      from(e) {
          var t = this;
          if (!ZF(e)) throw new Hu("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
          const n = new QF({
                  baseUrl: this.url,
                  catalogName: e,
                  auth: {
                      type: "custom",
                      getHeaders: async () => t.headers
                  },
                  fetch: this.fetch
              }),
              r = this.shouldThrowOnError;
          return new Proxy(n, {
              get(s, i) {
                  const o = s[i];
                  return typeof o != "function" ? o : async (...a) => {
                      try {
                          return {
                              data: await o.apply(s, a),
                              error: null
                          }
                      } catch (l) {
                          if (r) throw l;
                          return {
                              data: null,
                              error: l
                          }
                      }
                  }
              }
          })
      }
  };
const bg = {
  "X-Client-Info": `storage-js/${DE}`,
  "Content-Type": "application/json"
};
var LE = class extends Error {
  constructor(e) {
      super(e), this.__isStorageVectorsError = !0, this.name = "StorageVectorsError"
  }
};

function Tt(e) {
  return typeof e == "object" && e !== null && "__isStorageVectorsError" in e
}
var rh = class extends LE {
      constructor(e, t, n) {
          super(e), this.name = "StorageVectorsApiError", this.status = t, this.statusCode = n
      }
      toJSON() {
          return {
              name: this.name,
              message: this.message,
              status: this.status,
              statusCode: this.statusCode
          }
      }
  },
  h4 = class extends LE {
      constructor(e, t) {
          super(e), this.name = "StorageVectorsUnknownError", this.originalError = t
      }
  };
const Sg = e => e ? (...t) => e(...t) : (...t) => fetch(...t),
  f4 = e => {
      if (typeof e != "object" || e === null) return !1;
      const t = Object.getPrototypeOf(e);
      return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
  },
  uw = e => e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
  p4 = async (e, t, n) => {
      if (e && typeof e == "object" && "status" in e && "ok" in e && typeof e.status == "number" && !(n != null && n.noResolveJson)) {
          const r = e.status || 500,
              s = e;
          if (typeof s.json == "function") s.json().then(i => {
              const o = (i == null ? void 0 : i.statusCode) || (i == null ? void 0 : i.code) || r + "";
              t(new rh(uw(i), r, o))
          }).catch(() => {
              const i = r + "";
              t(new rh(s.statusText || `HTTP ${r} error`, r, i))
          });
          else {
              const i = r + "";
              t(new rh(s.statusText || `HTTP ${r} error`, r, i))
          }
      } else t(new h4(uw(e), e))
  }, m4 = (e, t, n, r) => {
      const s = {
          method: e,
          headers: (t == null ? void 0 : t.headers) || {}
      };
      return r ? (f4(r) ? (s.headers = K({
          "Content-Type": "application/json"
      }, t == null ? void 0 : t.headers), s.body = JSON.stringify(r)) : s.body = r, K(K({}, s), n)) : s
  };
async function g4(e, t, n, r, s, i) {
  return new Promise((o, a) => {
      e(n, m4(t, r, s, i)).then(l => {
          if (!l.ok) throw l;
          if (r != null && r.noResolveJson) return l;
          const c = l.headers.get("content-type");
          return !c || !c.includes("application/json") ? {} : l.json()
      }).then(l => o(l)).catch(l => p4(l, a, r))
  })
}
async function kt(e, t, n, r, s) {
  return g4(e, "POST", t, r, s, n)
}
var y4 = class {
      constructor(e, t = {}, n) {
          this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = K(K({}, bg), t), this.fetch = Sg(n)
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      async createIndex(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/CreateIndex`, e, {
                      headers: t.headers
                  }) || {},
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async getIndex(e, t) {
          var n = this;
          try {
              return {
                  data: await kt(n.fetch, `${n.url}/GetIndex`, {
                      vectorBucketName: e,
                      indexName: t
                  }, {
                      headers: n.headers
                  }),
                  error: null
              }
          } catch (r) {
              if (n.shouldThrowOnError) throw r;
              if (Tt(r)) return {
                  data: null,
                  error: r
              };
              throw r
          }
      }
      async listIndexes(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/ListIndexes`, e, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async deleteIndex(e, t) {
          var n = this;
          try {
              return {
                  data: await kt(n.fetch, `${n.url}/DeleteIndex`, {
                      vectorBucketName: e,
                      indexName: t
                  }, {
                      headers: n.headers
                  }) || {},
                  error: null
              }
          } catch (r) {
              if (n.shouldThrowOnError) throw r;
              if (Tt(r)) return {
                  data: null,
                  error: r
              };
              throw r
          }
      }
  },
  v4 = class {
      constructor(e, t = {}, n) {
          this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = K(K({}, bg), t), this.fetch = Sg(n)
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      async putVectors(e) {
          var t = this;
          try {
              if (e.vectors.length < 1 || e.vectors.length > 500) throw new Error("Vector batch size must be between 1 and 500 items");
              return {
                  data: await kt(t.fetch, `${t.url}/PutVectors`, e, {
                      headers: t.headers
                  }) || {},
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async getVectors(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/GetVectors`, e, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async listVectors(e) {
          var t = this;
          try {
              if (e.segmentCount !== void 0) {
                  if (e.segmentCount < 1 || e.segmentCount > 16) throw new Error("segmentCount must be between 1 and 16");
                  if (e.segmentIndex !== void 0 && (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount)) throw new Error(`segmentIndex must be between 0 and ${e.segmentCount - 1}`)
              }
              return {
                  data: await kt(t.fetch, `${t.url}/ListVectors`, e, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async queryVectors(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/QueryVectors`, e, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async deleteVectors(e) {
          var t = this;
          try {
              if (e.keys.length < 1 || e.keys.length > 500) throw new Error("Keys batch size must be between 1 and 500 items");
              return {
                  data: await kt(t.fetch, `${t.url}/DeleteVectors`, e, {
                      headers: t.headers
                  }) || {},
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
  },
  w4 = class {
      constructor(e, t = {}, n) {
          this.shouldThrowOnError = !1, this.url = e.replace(/\/$/, ""), this.headers = K(K({}, bg), t), this.fetch = Sg(n)
      }
      throwOnError() {
          return this.shouldThrowOnError = !0, this
      }
      async createBucket(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/CreateVectorBucket`, {
                      vectorBucketName: e
                  }, {
                      headers: t.headers
                  }) || {},
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async getBucket(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/GetVectorBucket`, {
                      vectorBucketName: e
                  }, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async listBuckets(e = {}) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/ListVectorBuckets`, e, {
                      headers: t.headers
                  }),
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
      async deleteBucket(e) {
          var t = this;
          try {
              return {
                  data: await kt(t.fetch, `${t.url}/DeleteVectorBucket`, {
                      vectorBucketName: e
                  }, {
                      headers: t.headers
                  }) || {},
                  error: null
              }
          } catch (n) {
              if (t.shouldThrowOnError) throw n;
              if (Tt(n)) return {
                  data: null,
                  error: n
              };
              throw n
          }
      }
  },
  x4 = class extends w4 {
      constructor(e, t = {}) {
          super(e, t.headers || {}, t.fetch)
      }
      from(e) {
          return new b4(this.url, this.headers, e, this.fetch)
      }
      async createBucket(e) {
          var t = () => super.createBucket,
              n = this;
          return t().call(n, e)
      }
      async getBucket(e) {
          var t = () => super.getBucket,
              n = this;
          return t().call(n, e)
      }
      async listBuckets(e = {}) {
          var t = () => super.listBuckets,
              n = this;
          return t().call(n, e)
      }
      async deleteBucket(e) {
          var t = () => super.deleteBucket,
              n = this;
          return t().call(n, e)
      }
  },
  b4 = class extends y4 {
      constructor(e, t, n, r) {
          super(e, t, r), this.vectorBucketName = n
      }
      async createIndex(e) {
          var t = () => super.createIndex,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName
          }))
      }
      async listIndexes(e = {}) {
          var t = () => super.listIndexes,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName
          }))
      }
      async getIndex(e) {
          var t = () => super.getIndex,
              n = this;
          return t().call(n, n.vectorBucketName, e)
      }
      async deleteIndex(e) {
          var t = () => super.deleteIndex,
              n = this;
          return t().call(n, n.vectorBucketName, e)
      }
      index(e) {
          return new S4(this.url, this.headers, this.vectorBucketName, e, this.fetch)
      }
  },
  S4 = class extends v4 {
      constructor(e, t, n, r, s) {
          super(e, t, s), this.vectorBucketName = n, this.indexName = r
      }
      async putVectors(e) {
          var t = () => super.putVectors,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName,
              indexName: n.indexName
          }))
      }
      async getVectors(e) {
          var t = () => super.getVectors,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName,
              indexName: n.indexName
          }))
      }
      async listVectors(e = {}) {
          var t = () => super.listVectors,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName,
              indexName: n.indexName
          }))
      }
      async queryVectors(e) {
          var t = () => super.queryVectors,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName,
              indexName: n.indexName
          }))
      }
      async deleteVectors(e) {
          var t = () => super.deleteVectors,
              n = this;
          return t().call(n, K(K({}, e), {}, {
              vectorBucketName: n.vectorBucketName,
              indexName: n.indexName
          }))
      }
  },
  _4 = class extends u4 {
      constructor(e, t = {}, n, r) {
          super(e, t, n, r)
      }
      from(e) {
          return new c4(this.url, this.headers, e, this.fetch)
      }
      get vectors() {
          return new x4(this.url + "/vector", {
              headers: this.headers,
              fetch: this.fetch
          })
      }
      get analytics() {
          return new d4(this.url + "/iceberg", this.headers, this.fetch)
      }
  };
const $E = "2.89.0",
  yi = 30 * 1e3,
  hp = 3,
  sh = hp * yi,
  E4 = "http://localhost:9999",
  C4 = "supabase.auth.token",
  T4 = {
      "X-Client-Info": `gotrue-js/${$E}`
  },
  fp = "X-Supabase-Api-Version",
  FE = {
      "2024-01-01": {
          timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
          name: "2024-01-01"
      }
  },
  k4 = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  R4 = 10 * 60 * 1e3;
class Ka extends Error {
  constructor(t, n, r) {
      super(t), this.__isAuthError = !0, this.name = "AuthError", this.status = n, this.code = r
  }
}

function V(e) {
  return typeof e == "object" && e !== null && "__isAuthError" in e
}
class P4 extends Ka {
  constructor(t, n, r) {
      super(t, n, r), this.name = "AuthApiError", this.status = n, this.code = r
  }
}

function A4(e) {
  return V(e) && e.name === "AuthApiError"
}
class bs extends Ka {
  constructor(t, n) {
      super(t), this.name = "AuthUnknownError", this.originalError = n
  }
}
class nr extends Ka {
  constructor(t, n, r, s) {
      super(t, r, s), this.name = n, this.status = r
  }
}
class _t extends nr {
  constructor() {
      super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
  }
}

function N4(e) {
  return V(e) && e.name === "AuthSessionMissingError"
}
class li extends nr {
  constructor() {
      super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
  }
}
class ql extends nr {
  constructor(t) {
      super(t, "AuthInvalidCredentialsError", 400, void 0)
  }
}
class Gl extends nr {
  constructor(t, n = null) {
      super(t, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = n
  }
  toJSON() {
      return {
          name: this.name,
          message: this.message,
          status: this.status,
          details: this.details
      }
  }
}

function j4(e) {
  return V(e) && e.name === "AuthImplicitGrantRedirectError"
}
class dw extends nr {
  constructor(t, n = null) {
      super(t, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = n
  }
  toJSON() {
      return {
          name: this.name,
          message: this.message,
          status: this.status,
          details: this.details
      }
  }
}
class O4 extends nr {
  constructor() {
      super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.", "AuthPKCECodeVerifierMissingError", 400, "pkce_code_verifier_not_found")
  }
}
class pp extends nr {
  constructor(t, n) {
      super(t, "AuthRetryableFetchError", n, void 0)
  }
}

function ih(e) {
  return V(e) && e.name === "AuthRetryableFetchError"
}
class hw extends nr {
  constructor(t, n, r) {
      super(t, "AuthWeakPasswordError", n, "weak_password"), this.reasons = r
  }
}
class mp extends nr {
  constructor(t) {
      super(t, "AuthInvalidJwtError", 400, "invalid_jwt")
  }
}
const au = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),
  fw = ` 	
\r=`.split(""),
  I4 = (() => {
      const e = new Array(128);
      for (let t = 0; t < e.length; t += 1) e[t] = -1;
      for (let t = 0; t < fw.length; t += 1) e[fw[t].charCodeAt(0)] = -2;
      for (let t = 0; t < au.length; t += 1) e[au[t].charCodeAt(0)] = t;
      return e
  })();

function pw(e, t, n) {
  if (e !== null)
      for (t.queue = t.queue << 8 | e, t.queuedBits += 8; t.queuedBits >= 6;) {
          const r = t.queue >> t.queuedBits - 6 & 63;
          n(au[r]), t.queuedBits -= 6
      } else if (t.queuedBits > 0)
          for (t.queue = t.queue << 6 - t.queuedBits, t.queuedBits = 6; t.queuedBits >= 6;) {
              const r = t.queue >> t.queuedBits - 6 & 63;
              n(au[r]), t.queuedBits -= 6
          }
}

function UE(e, t, n) {
  const r = I4[e];
  if (r > -1)
      for (t.queue = t.queue << 6 | r, t.queuedBits += 6; t.queuedBits >= 8;) n(t.queue >> t.queuedBits - 8 & 255), t.queuedBits -= 8;
  else {
      if (r === -2) return;
      throw new Error(`Invalid Base64-URL character "${String.fromCharCode(e)}"`)
  }
}

function mw(e) {
  const t = [],
      n = o => {
          t.push(String.fromCodePoint(o))
      },
      r = {
          utf8seq: 0,
          codepoint: 0
      },
      s = {
          queue: 0,
          queuedBits: 0
      },
      i = o => {
          L4(o, r, n)
      };
  for (let o = 0; o < e.length; o += 1) UE(e.charCodeAt(o), s, i);
  return t.join("")
}

function D4(e, t) {
  if (e <= 127) {
      t(e);
      return
  } else if (e <= 2047) {
      t(192 | e >> 6), t(128 | e & 63);
      return
  } else if (e <= 65535) {
      t(224 | e >> 12), t(128 | e >> 6 & 63), t(128 | e & 63);
      return
  } else if (e <= 1114111) {
      t(240 | e >> 18), t(128 | e >> 12 & 63), t(128 | e >> 6 & 63), t(128 | e & 63);
      return
  }
  throw new Error(`Unrecognized Unicode codepoint: ${e.toString(16)}`)
}

function M4(e, t) {
  for (let n = 0; n < e.length; n += 1) {
      let r = e.charCodeAt(n);
      if (r > 55295 && r <= 56319) {
          const s = (r - 55296) * 1024 & 65535;
          r = (e.charCodeAt(n + 1) - 56320 & 65535 | s) + 65536, n += 1
      }
      D4(r, t)
  }
}

function L4(e, t, n) {
  if (t.utf8seq === 0) {
      if (e <= 127) {
          n(e);
          return
      }
      for (let r = 1; r < 6; r += 1)
          if (!(e >> 7 - r & 1)) {
              t.utf8seq = r;
              break
          } if (t.utf8seq === 2) t.codepoint = e & 31;
      else if (t.utf8seq === 3) t.codepoint = e & 15;
      else if (t.utf8seq === 4) t.codepoint = e & 7;
      else throw new Error("Invalid UTF-8 sequence");
      t.utf8seq -= 1
  } else if (t.utf8seq > 0) {
      if (e <= 127) throw new Error("Invalid UTF-8 sequence");
      t.codepoint = t.codepoint << 6 | e & 63, t.utf8seq -= 1, t.utf8seq === 0 && n(t.codepoint)
  }
}

function qi(e) {
  const t = [],
      n = {
          queue: 0,
          queuedBits: 0
      },
      r = s => {
          t.push(s)
      };
  for (let s = 0; s < e.length; s += 1) UE(e.charCodeAt(s), n, r);
  return new Uint8Array(t)
}

function $4(e) {
  const t = [];
  return M4(e, n => t.push(n)), new Uint8Array(t)
}

function ks(e) {
  const t = [],
      n = {
          queue: 0,
          queuedBits: 0
      },
      r = s => {
          t.push(s)
      };
  return e.forEach(s => pw(s, n, r)), pw(null, n, r), t.join("")
}

function F4(e) {
  return Math.round(Date.now() / 1e3) + e
}

function U4() {
  return Symbol("auth-callback")
}
const Ke = () => typeof window < "u" && typeof document < "u",
  us = {
      tested: !1,
      writable: !1
  },
  VE = () => {
      if (!Ke()) return !1;
      try {
          if (typeof globalThis.localStorage != "object") return !1
      } catch {
          return !1
      }
      if (us.tested) return us.writable;
      const e = `lswt-${Math.random()}${Math.random()}`;
      try {
          globalThis.localStorage.setItem(e, e), globalThis.localStorage.removeItem(e), us.tested = !0, us.writable = !0
      } catch {
          us.tested = !0, us.writable = !1
      }
      return us.writable
  };

function V4(e) {
  const t = {},
      n = new URL(e);
  if (n.hash && n.hash[0] === "#") try {
      new URLSearchParams(n.hash.substring(1)).forEach((s, i) => {
          t[i] = s
      })
  } catch {}
  return n.searchParams.forEach((r, s) => {
      t[s] = r
  }), t
}
const BE = e => e ? (...t) => e(...t) : (...t) => fetch(...t),
  B4 = e => typeof e == "object" && e !== null && "status" in e && "ok" in e && "json" in e && typeof e.json == "function",
  vi = async (e, t, n) => {
      await e.setItem(t, JSON.stringify(n))
  }, ds = async (e, t) => {
      const n = await e.getItem(t);
      if (!n) return null;
      try {
          return JSON.parse(n)
      } catch {
          return n
      }
  }, He = async (e, t) => {
      await e.removeItem(t)
  };
class Ku {
  constructor() {
      this.promise = new Ku.promiseConstructor((t, n) => {
          this.resolve = t, this.reject = n
      })
  }
}
Ku.promiseConstructor = Promise;

function oh(e) {
  const t = e.split(".");
  if (t.length !== 3) throw new mp("Invalid JWT structure");
  for (let r = 0; r < t.length; r++)
      if (!k4.test(t[r])) throw new mp("JWT not in base64url format");
  return {
      header: JSON.parse(mw(t[0])),
      payload: JSON.parse(mw(t[1])),
      signature: qi(t[2]),
      raw: {
          header: t[0],
          payload: t[1]
      }
  }
}
async function z4(e) {
  return await new Promise(t => {
      setTimeout(() => t(null), e)
  })
}

function W4(e, t) {
  return new Promise((r, s) => {
      (async () => {
          for (let i = 0; i < 1 / 0; i++) try {
              const o = await e(i);
              if (!t(i, null, o)) {
                  r(o);
                  return
              }
          } catch (o) {
              if (!t(i, o)) {
                  s(o);
                  return
              }
          }
      })()
  })
}

function H4(e) {
  return ("0" + e.toString(16)).substr(-2)
}

function K4() {
  const t = new Uint32Array(56);
  if (typeof crypto > "u") {
      const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
          r = n.length;
      let s = "";
      for (let i = 0; i < 56; i++) s += n.charAt(Math.floor(Math.random() * r));
      return s
  }
  return crypto.getRandomValues(t), Array.from(t, H4).join("")
}
async function q4(e) {
  const n = new TextEncoder().encode(e),
      r = await crypto.subtle.digest("SHA-256", n),
      s = new Uint8Array(r);
  return Array.from(s).map(i => String.fromCharCode(i)).join("")
}
async function G4(e) {
  if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u")) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), e;
  const n = await q4(e);
  return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function ci(e, t, n = !1) {
  const r = K4();
  let s = r;
  n && (s += "/PASSWORD_RECOVERY"), await vi(e, `${t}-code-verifier`, s);
  const i = await G4(r);
  return [i, r === i ? "plain" : "s256"]
}
const Q4 = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;

function Y4(e) {
  const t = e.headers.get(fp);
  if (!t || !t.match(Q4)) return null;
  try {
      return new Date(`${t}T00:00:00.0Z`)
  } catch {
      return null
  }
}

function J4(e) {
  if (!e) throw new Error("Missing exp claim");
  const t = Math.floor(Date.now() / 1e3);
  if (e <= t) throw new Error("JWT has expired")
}

function X4(e) {
  switch (e) {
      case "RS256":
          return {
              name: "RSASSA-PKCS1-v1_5", hash: {
                  name: "SHA-256"
              }
          };
      case "ES256":
          return {
              name: "ECDSA", namedCurve: "P-256", hash: {
                  name: "SHA-256"
              }
          };
      default:
          throw new Error("Invalid alg claim")
  }
}
const Z4 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;

function ui(e) {
  if (!Z4.test(e)) throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}

function ah() {
  const e = {};
  return new Proxy(e, {
      get: (t, n) => {
          if (n === "__isUserNotAvailableProxy") return !0;
          if (typeof n == "symbol") {
              const r = n.toString();
              if (r === "Symbol(Symbol.toPrimitive)" || r === "Symbol(Symbol.toStringTag)" || r === "Symbol(util.inspect.custom)") return
          }
          throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${n}" property of the session object is not supported. Please use getUser() instead.`)
      },
      set: (t, n) => {
          throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
      },
      deleteProperty: (t, n) => {
          throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${n}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
      }
  })
}

function e3(e, t) {
  return new Proxy(e, {
      get: (n, r, s) => {
          if (r === "__isInsecureUserWarningProxy") return !0;
          if (typeof r == "symbol") {
              const i = r.toString();
              if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)" || i === "Symbol(nodejs.util.inspect.custom)") return Reflect.get(n, r, s)
          }
          return !t.value && typeof r == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), t.value = !0), Reflect.get(n, r, s)
      }
  })
}

function gw(e) {
  return JSON.parse(JSON.stringify(e))
}
const ms = e => e.msg || e.message || e.error_description || e.error || JSON.stringify(e),
  t3 = [502, 503, 504];
async function yw(e) {
  var t;
  if (!B4(e)) throw new pp(ms(e), 0);
  if (t3.includes(e.status)) throw new pp(ms(e), e.status);
  let n;
  try {
      n = await e.json()
  } catch (i) {
      throw new bs(ms(i), i)
  }
  let r;
  const s = Y4(e);
  if (s && s.getTime() >= FE["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? r = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (r = n.error_code), r) {
      if (r === "weak_password") throw new hw(ms(n), e.status, ((t = n.weak_password) === null || t === void 0 ? void 0 : t.reasons) || []);
      if (r === "session_not_found") throw new _t
  } else if (typeof n == "object" && n && typeof n.weak_password == "object" && n.weak_password && Array.isArray(n.weak_password.reasons) && n.weak_password.reasons.length && n.weak_password.reasons.reduce((i, o) => i && typeof o == "string", !0)) throw new hw(ms(n), e.status, n.weak_password.reasons);
  throw new P4(ms(n), e.status || 500, r)
}
const n3 = (e, t, n, r) => {
  const s = {
      method: e,
      headers: (t == null ? void 0 : t.headers) || {}
  };
  return e === "GET" ? s : (s.headers = Object.assign({
      "Content-Type": "application/json;charset=UTF-8"
  }, t == null ? void 0 : t.headers), s.body = JSON.stringify(r), Object.assign(Object.assign({}, s), n))
};
async function H(e, t, n, r) {
  var s;
  const i = Object.assign({}, r == null ? void 0 : r.headers);
  i[fp] || (i[fp] = FE["2024-01-01"].name), r != null && r.jwt && (i.Authorization = `Bearer ${r.jwt}`);
  const o = (s = r == null ? void 0 : r.query) !== null && s !== void 0 ? s : {};
  r != null && r.redirectTo && (o.redirect_to = r.redirectTo);
  const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : "",
      l = await r3(e, t, n + a, {
          headers: i,
          noResolveJson: r == null ? void 0 : r.noResolveJson
      }, {}, r == null ? void 0 : r.body);
  return r != null && r.xform ? r == null ? void 0 : r.xform(l) : {
      data: Object.assign({}, l),
      error: null
  }
}
async function r3(e, t, n, r, s, i) {
  const o = n3(t, r, s, i);
  let a;
  try {
      a = await e(n, Object.assign({}, o))
  } catch (l) {
      throw console.error(l), new pp(ms(l), 0)
  }
  if (a.ok || await yw(a), r != null && r.noResolveJson) return a;
  try {
      return await a.json()
  } catch (l) {
      await yw(l)
  }
}

function en(e) {
  var t;
  let n = null;
  o3(e) && (n = Object.assign({}, e), e.expires_at || (n.expires_at = F4(e.expires_in)));
  const r = (t = e.user) !== null && t !== void 0 ? t : e;
  return {
      data: {
          session: n,
          user: r
      },
      error: null
  }
}

function vw(e) {
  const t = en(e);
  return !t.error && e.weak_password && typeof e.weak_password == "object" && Array.isArray(e.weak_password.reasons) && e.weak_password.reasons.length && e.weak_password.message && typeof e.weak_password.message == "string" && e.weak_password.reasons.reduce((n, r) => n && typeof r == "string", !0) && (t.data.weak_password = e.weak_password), t
}

function _r(e) {
  var t;
  return {
      data: {
          user: (t = e.user) !== null && t !== void 0 ? t : e
      },
      error: null
  }
}

function s3(e) {
  return {
      data: e,
      error: null
  }
}

function i3(e) {
  const {
      action_link: t,
      email_otp: n,
      hashed_token: r,
      redirect_to: s,
      verification_type: i
  } = e, o = No(e, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), a = {
      action_link: t,
      email_otp: n,
      hashed_token: r,
      redirect_to: s,
      verification_type: i
  }, l = Object.assign({}, o);
  return {
      data: {
          properties: a,
          user: l
      },
      error: null
  }
}

function ww(e) {
  return e
}

function o3(e) {
  return e.access_token && e.refresh_token && e.expires_in
}
const lh = ["global", "local", "others"];
class a3 {
  constructor({
      url: t = "",
      headers: n = {},
      fetch: r
  }) {
      this.url = t, this.headers = n, this.fetch = BE(r), this.mfa = {
          listFactors: this._listFactors.bind(this),
          deleteFactor: this._deleteFactor.bind(this)
      }, this.oauth = {
          listClients: this._listOAuthClients.bind(this),
          createClient: this._createOAuthClient.bind(this),
          getClient: this._getOAuthClient.bind(this),
          updateClient: this._updateOAuthClient.bind(this),
          deleteClient: this._deleteOAuthClient.bind(this),
          regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
      }
  }
  async signOut(t, n = lh[0]) {
      if (lh.indexOf(n) < 0) throw new Error(`@supabase/auth-js: Parameter scope must be one of ${lh.join(", ")}`);
      try {
          return await H(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
              headers: this.headers,
              jwt: t,
              noResolveJson: !0
          }), {
              data: null,
              error: null
          }
      } catch (r) {
          if (V(r)) return {
              data: null,
              error: r
          };
          throw r
      }
  }
  async inviteUserByEmail(t, n = {}) {
      try {
          return await H(this.fetch, "POST", `${this.url}/invite`, {
              body: {
                  email: t,
                  data: n.data
              },
              headers: this.headers,
              redirectTo: n.redirectTo,
              xform: _r
          })
      } catch (r) {
          if (V(r)) return {
              data: {
                  user: null
              },
              error: r
          };
          throw r
      }
  }
  async generateLink(t) {
      try {
          const {
              options: n
          } = t, r = No(t, ["options"]), s = Object.assign(Object.assign({}, r), n);
          return "newEmail" in r && (s.new_email = r == null ? void 0 : r.newEmail, delete s.newEmail), await H(this.fetch, "POST", `${this.url}/admin/generate_link`, {
              body: s,
              headers: this.headers,
              xform: i3,
              redirectTo: n == null ? void 0 : n.redirectTo
          })
      } catch (n) {
          if (V(n)) return {
              data: {
                  properties: null,
                  user: null
              },
              error: n
          };
          throw n
      }
  }
  async createUser(t) {
      try {
          return await H(this.fetch, "POST", `${this.url}/admin/users`, {
              body: t,
              headers: this.headers,
              xform: _r
          })
      } catch (n) {
          if (V(n)) return {
              data: {
                  user: null
              },
              error: n
          };
          throw n
      }
  }
  async listUsers(t) {
      var n, r, s, i, o, a, l;
      try {
          const c = {
                  nextPage: null,
                  lastPage: 0,
                  total: 0
              },
              u = await H(this.fetch, "GET", `${this.url}/admin/users`, {
                  headers: this.headers,
                  noResolveJson: !0,
                  query: {
                      page: (r = (n = t == null ? void 0 : t.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "",
                      per_page: (i = (s = t == null ? void 0 : t.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                  },
                  xform: ww
              });
          if (u.error) throw u.error;
          const d = await u.json(),
              h = (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0,
              f = (l = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
          return f.length > 0 && (f.forEach(x => {
              const m = parseInt(x.split(";")[0].split("=")[1].substring(0, 1)),
                  b = JSON.parse(x.split(";")[1].split("=")[1]);
              c[`${b}Page`] = m
          }), c.total = parseInt(h)), {
              data: Object.assign(Object.assign({}, d), c),
              error: null
          }
      } catch (c) {
          if (V(c)) return {
              data: {
                  users: []
              },
              error: c
          };
          throw c
      }
  }
  async getUserById(t) {
      ui(t);
      try {
          return await H(this.fetch, "GET", `${this.url}/admin/users/${t}`, {
              headers: this.headers,
              xform: _r
          })
      } catch (n) {
          if (V(n)) return {
              data: {
                  user: null
              },
              error: n
          };
          throw n
      }
  }
  async updateUserById(t, n) {
      ui(t);
      try {
          return await H(this.fetch, "PUT", `${this.url}/admin/users/${t}`, {
              body: n,
              headers: this.headers,
              xform: _r
          })
      } catch (r) {
          if (V(r)) return {
              data: {
                  user: null
              },
              error: r
          };
          throw r
      }
  }
  async deleteUser(t, n = !1) {
      ui(t);
      try {
          return await H(this.fetch, "DELETE", `${this.url}/admin/users/${t}`, {
              headers: this.headers,
              body: {
                  should_soft_delete: n
              },
              xform: _r
          })
      } catch (r) {
          if (V(r)) return {
              data: {
                  user: null
              },
              error: r
          };
          throw r
      }
  }
  async _listFactors(t) {
      ui(t.userId);
      try {
          const {
              data: n,
              error: r
          } = await H(this.fetch, "GET", `${this.url}/admin/users/${t.userId}/factors`, {
              headers: this.headers,
              xform: s => ({
                  data: {
                      factors: s
                  },
                  error: null
              })
          });
          return {
              data: n,
              error: r
          }
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async _deleteFactor(t) {
      ui(t.userId), ui(t.id);
      try {
          return {
              data: await H(this.fetch, "DELETE", `${this.url}/admin/users/${t.userId}/factors/${t.id}`, {
                  headers: this.headers
              }),
              error: null
          }
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async _listOAuthClients(t) {
      var n, r, s, i, o, a, l;
      try {
          const c = {
                  nextPage: null,
                  lastPage: 0,
                  total: 0
              },
              u = await H(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
                  headers: this.headers,
                  noResolveJson: !0,
                  query: {
                      page: (r = (n = t == null ? void 0 : t.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "",
                      per_page: (i = (s = t == null ? void 0 : t.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                  },
                  xform: ww
              });
          if (u.error) throw u.error;
          const d = await u.json(),
              h = (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0,
              f = (l = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
          return f.length > 0 && (f.forEach(x => {
              const m = parseInt(x.split(";")[0].split("=")[1].substring(0, 1)),
                  b = JSON.parse(x.split(";")[1].split("=")[1]);
              c[`${b}Page`] = m
          }), c.total = parseInt(h)), {
              data: Object.assign(Object.assign({}, d), c),
              error: null
          }
      } catch (c) {
          if (V(c)) return {
              data: {
                  clients: []
              },
              error: c
          };
          throw c
      }
  }
  async _createOAuthClient(t) {
      try {
          return await H(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
              body: t,
              headers: this.headers,
              xform: n => ({
                  data: n,
                  error: null
              })
          })
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async _getOAuthClient(t) {
      try {
          return await H(this.fetch, "GET", `${this.url}/admin/oauth/clients/${t}`, {
              headers: this.headers,
              xform: n => ({
                  data: n,
                  error: null
              })
          })
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async _updateOAuthClient(t, n) {
      try {
          return await H(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${t}`, {
              body: n,
              headers: this.headers,
              xform: r => ({
                  data: r,
                  error: null
              })
          })
      } catch (r) {
          if (V(r)) return {
              data: null,
              error: r
          };
          throw r
      }
  }
  async _deleteOAuthClient(t) {
      try {
          return await H(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${t}`, {
              headers: this.headers,
              noResolveJson: !0
          }), {
              data: null,
              error: null
          }
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
  async _regenerateOAuthClientSecret(t) {
      try {
          return await H(this.fetch, "POST", `${this.url}/admin/oauth/clients/${t}/regenerate_secret`, {
              headers: this.headers,
              xform: n => ({
                  data: n,
                  error: null
              })
          })
      } catch (n) {
          if (V(n)) return {
              data: null,
              error: n
          };
          throw n
      }
  }
}

function xw(e = {}) {
  return {
      getItem: t => e[t] || null,
      setItem: (t, n) => {
          e[t] = n
      },
      removeItem: t => {
          delete e[t]
      }
  }
}
const di = {
  debug: !!(globalThis && VE() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class zE extends Error {
  constructor(t) {
      super(t), this.isAcquireTimeout = !0
  }
}
class l3 extends zE {}
async function c3(e, t, n) {
  di.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", e, t);
  const r = new globalThis.AbortController;
  return t > 0 && setTimeout(() => {
      r.abort(), di.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", e)
  }, t), await Promise.resolve().then(() => globalThis.navigator.locks.request(e, t === 0 ? {
      mode: "exclusive",
      ifAvailable: !0
  } : {
      mode: "exclusive",
      signal: r.signal
  }, async s => {
      if (s) {
          di.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", e, s.name);
          try {
              return await n()
          } finally {
              di.debug && console.log("@supabase/gotrue-js: navigatorLock: released", e, s.name)
          }
      } else {
          if (t === 0) throw di.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", e), new l3(`Acquiring an exclusive Navigator LockManager lock "${e}" immediately failed`);
          if (di.debug) try {
              const i = await globalThis.navigator.locks.query();
              console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(i, null, "  "))
          } catch (i) {
              console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", i)
          }
          return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await n()
      }
  }))
}

function u3() {
  if (typeof globalThis != "object") try {
      Object.defineProperty(Object.prototype, "__magic__", {
          get: function() {
              return this
          },
          configurable: !0
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__
  } catch {
      typeof self < "u" && (self.globalThis = self)
  }
}

function WE(e) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(e)) throw new Error(`@supabase/auth-js: Address "${e}" is invalid.`);
  return e.toLowerCase()
}

function d3(e) {
  return parseInt(e, 16)
}

function h3(e) {
  const t = new TextEncoder().encode(e);
  return "0x" + Array.from(t, r => r.toString(16).padStart(2, "0")).join("")
}

function f3(e) {
  var t;
  const {
      chainId: n,
      domain: r,
      expirationTime: s,
      issuedAt: i = new Date,
      nonce: o,
      notBefore: a,
      requestId: l,
      resources: c,
      scheme: u,
      uri: d,
      version: h
  } = e;
  {
      if (!Number.isInteger(n)) throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${n}`);
      if (!r) throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
      if (o && o.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);
      if (!d) throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
      if (h !== "1") throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${h}`);
      if (!((t = e.statement) === null || t === void 0) && t.includes(`
`)) throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${e.statement}`)
  }
  const f = WE(e.address),
      x = u ? `${u}://${r}` : r,
      m = e.statement ? `${e.statement}
` : "",
      b = `${x} wants you to sign in with your Ethereum account:
${f}

${m}`;
  let v = `URI: ${d}
Version: ${h}
Chain ID: ${n}${o ? `
Nonce: ${o}` : ""}
Issued At: ${i.toISOString()}`;
  if (s && (v += `
Expiration Time: ${s.toISOString()}`), a && (v += `
Not Before: ${a.toISOString()}`), l && (v += `
Request ID: ${l}`), c) {
      let y = `
Resources:`;
      for (const w of c) {
          if (!w || typeof w != "string") throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${w}`);
          y += `
- ${w}`
      }
      v += y
  }
  return `${b}
${v}`
}
class Ie extends Error {
  constructor({
      message: t,
      code: n,
      cause: r,
      name: s
  }) {
      var i;
      super(t, {
          cause: r
      }), this.__isWebAuthnError = !0, this.name = (i = s ?? (r instanceof Error ? r.name : void 0)) !== null && i !== void 0 ? i : "Unknown Error", this.code = n
  }
}
class lu extends Ie {
  constructor(t, n) {
      super({
          code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
          cause: n,
          message: t
      }), this.name = "WebAuthnUnknownError", this.originalError = n
  }
}

function p3({
  error: e,
  options: t
}) {
  var n, r, s;
  const {
      publicKey: i
  } = t;
  if (!i) throw Error("options was missing required publicKey property");
  if (e.name === "AbortError") {
      if (t.signal instanceof AbortSignal) return new Ie({
          message: "Registration ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: e
      })
  } else if (e.name === "ConstraintError") {
      if (((n = i.authenticatorSelection) === null || n === void 0 ? void 0 : n.requireResidentKey) === !0) return new Ie({
          message: "Discoverable credentials were required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
          cause: e
      });
      if (t.mediation === "conditional" && ((r = i.authenticatorSelection) === null || r === void 0 ? void 0 : r.userVerification) === "required") return new Ie({
          message: "User verification was required during automatic registration but it could not be performed",
          code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
          cause: e
      });
      if (((s = i.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required") return new Ie({
          message: "User verification was required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
          cause: e
      })
  } else {
      if (e.name === "InvalidStateError") return new Ie({
          message: "The authenticator was previously registered",
          code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
          cause: e
      });
      if (e.name === "NotAllowedError") return new Ie({
          message: e.message,
          code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
          cause: e
      });
      if (e.name === "NotSupportedError") return i.pubKeyCredParams.filter(a => a.type === "public-key").length === 0 ? new Ie({
          message: 'No entry in pubKeyCredParams was of type "public-key"',
          code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
          cause: e
      }) : new Ie({
          message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
          code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
          cause: e
      });
      if (e.name === "SecurityError") {
          const o = window.location.hostname;
          if (HE(o)) {
              if (i.rp.id !== o) return new Ie({
                  message: `The RP ID "${i.rp.id}" is invalid for this domain`,
                  code: "ERROR_INVALID_RP_ID",
                  cause: e
              })
          } else return new Ie({
              message: `${window.location.hostname} is an invalid domain`,
              code: "ERROR_INVALID_DOMAIN",
              cause: e
          })
      } else if (e.name === "TypeError") {
          if (i.user.id.byteLength < 1 || i.user.id.byteLength > 64) return new Ie({
              message: "User ID was not between 1 and 64 characters",
              code: "ERROR_INVALID_USER_ID_LENGTH",
              cause: e
          })
      } else if (e.name === "UnknownError") return new Ie({
          message: "The authenticator was unable to process the specified options, or could not create a new credential",
          code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
          cause: e
      })
  }
  return new Ie({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: e
  })
}

function m3({
  error: e,
  options: t
}) {
  const {
      publicKey: n
  } = t;
  if (!n) throw Error("options was missing required publicKey property");
  if (e.name === "AbortError") {
      if (t.signal instanceof AbortSignal) return new Ie({
          message: "Authentication ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: e
      })
  } else {
      if (e.name === "NotAllowedError") return new Ie({
          message: e.message,
          code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
          cause: e
      });
      if (e.name === "SecurityError") {
          const r = window.location.hostname;
          if (HE(r)) {
              if (n.rpId !== r) return new Ie({
                  message: `The RP ID "${n.rpId}" is invalid for this domain`,
                  code: "ERROR_INVALID_RP_ID",
                  cause: e
              })
          } else return new Ie({
              message: `${window.location.hostname} is an invalid domain`,
              code: "ERROR_INVALID_DOMAIN",
              cause: e
          })
      } else if (e.name === "UnknownError") return new Ie({
          message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
          code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
          cause: e
      })
  }
  return new Ie({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: e
  })
}
class g3 {
  createNewAbortSignal() {
      if (this.controller) {
          const n = new Error("Cancelling existing WebAuthn API call for new one");
          n.name = "AbortError", this.controller.abort(n)
      }
      const t = new AbortController;
      return this.controller = t, t.signal
  }
  cancelCeremony() {
      if (this.controller) {
          const t = new Error("Manually cancelling existing WebAuthn API call");
          t.name = "AbortError", this.controller.abort(t), this.controller = void 0
      }
  }
}
const y3 = new g3;

function v3(e) {
  if (!e) throw new Error("Credential creation options are required");
  if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function") return PublicKeyCredential.parseCreationOptionsFromJSON(e);
  const {
      challenge: t,
      user: n,
      excludeCredentials: r
  } = e, s = No(e, ["challenge", "user", "excludeCredentials"]), i = qi(t).buffer, o = Object.assign(Object.assign({}, n), {
      id: qi(n.id).buffer
  }), a = Object.assign(Object.assign({}, s), {
      challenge: i,
      user: o
  });
  if (r && r.length > 0) {
      a.excludeCredentials = new Array(r.length);
      for (let l = 0; l < r.length; l++) {
          const c = r[l];
          a.excludeCredentials[l] = Object.assign(Object.assign({}, c), {
              id: qi(c.id).buffer,
              type: c.type || "public-key",
              transports: c.transports
          })
      }
  }
  return a
}

function w3(e) {
  if (!e) throw new Error("Credential request options are required");
  if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function") return PublicKeyCredential.parseRequestOptionsFromJSON(e);
  const {
      challenge: t,
      allowCredentials: n
  } = e, r = No(e, ["challenge", "allowCredentials"]), s = qi(t).buffer, i = Object.assign(Object.assign({}, r), {
      challenge: s
  });
  if (n && n.length > 0) {
      i.allowCredentials = new Array(n.length);
      for (let o = 0; o < n.length; o++) {
          const a = n[o];
          i.allowCredentials[o] = Object.assign(Object.assign({}, a), {
              id: qi(a.id).buffer,
              type: a.type || "public-key",
              transports: a.transports
          })
      }
  }
  return i
}

function x3(e) {
  var t;
  if ("toJSON" in e && typeof e.toJSON == "function") return e.toJSON();
  const n = e;
  return {
      id: e.id,
      rawId: e.id,
      response: {
          attestationObject: ks(new Uint8Array(e.response.attestationObject)),
          clientDataJSON: ks(new Uint8Array(e.response.clientDataJSON))
      },
      type: "public-key",
      clientExtensionResults: e.getClientExtensionResults(),
      authenticatorAttachment: (t = n.authenticatorAttachment) !== null && t !== void 0 ? t : void 0
  }
}

function b3(e) {
  var t;
  if ("toJSON" in e && typeof e.toJSON == "function") return e.toJSON();
  const n = e,
      r = e.getClientExtensionResults(),
      s = e.response;
  return {
      id: e.id,
      rawId: e.id,
      response: {
          authenticatorData: ks(new Uint8Array(s.authenticatorData)),
          clientDataJSON: ks(new Uint8Array(s.clientDataJSON)),
          signature: ks(new Uint8Array(s.signature)),
          userHandle: s.userHandle ? ks(new Uint8Array(s.userHandle)) : void 0
      },
      type: "public-key",
      clientExtensionResults: r,
      authenticatorAttachment: (t = n.authenticatorAttachment) !== null && t !== void 0 ? t : void 0
  }
}

function HE(e) {
  return e === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)
}

function bw() {
  var e, t;
  return !!(Ke() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.create) == "function" && typeof((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.get) == "function")
}
async function S3(e) {
  try {
      const t = await navigator.credentials.create(e);
      return t ? t instanceof PublicKeyCredential ? {
          data: t,
          error: null
      } : {
          data: null,
          error: new lu("Browser returned unexpected credential type", t)
      } : {
          data: null,
          error: new lu("Empty credential response", t)
      }
  } catch (t) {
      return {
          data: null,
          error: p3({
              error: t,
              options: e
          })
      }
  }
}
async function _3(e) {
  try {
      const t = await navigator.credentials.get(e);
      return t ? t instanceof PublicKeyCredential ? {
          data: t,
          error: null
      } : {
          data: null,
          error: new lu("Browser returned unexpected credential type", t)
      } : {
          data: null,
          error: new lu("Empty credential response", t)
      }
  } catch (t) {
      return {
          data: null,
          error: m3({
              error: t,
              options: e
          })
      }
  }
}
const E3 = {
      hints: ["security-key"],
      authenticatorSelection: {
          authenticatorAttachment: "cross-platform",
          requireResidentKey: !1,
          userVerification: "preferred",
          residentKey: "discouraged"
      },
      attestation: "direct"
  },
  C3 = {
      userVerification: "preferred",
      hints: ["security-key"],
      attestation: "direct"
  };

function cu(...e) {
  const t = s => s !== null && typeof s == "object" && !Array.isArray(s),
      n = s => s instanceof ArrayBuffer || ArrayBuffer.isView(s),
      r = {};
  for (const s of e)
      if (s)
          for (const i in s) {
              const o = s[i];
              if (o !== void 0)
                  if (Array.isArray(o)) r[i] = o;
                  else if (n(o)) r[i] = o;
              else if (t(o)) {
                  const a = r[i];
                  t(a) ? r[i] = cu(a, o) : r[i] = cu(o)
              } else r[i] = o
          }
  return r
}

function T3(e, t) {
  return cu(E3, e, t || {})
}

function k3(e, t) {
  return cu(C3, e, t || {})
}
class R3 {
  constructor(t) {
      this.client = t, this.enroll = this._enroll.bind(this), this.challenge = this._challenge.bind(this), this.verify = this._verify.bind(this), this.authenticate = this._authenticate.bind(this), this.register = this._register.bind(this)
  }
  async _enroll(t) {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, t), {
          factorType: "webauthn"
      }))
  }
  async _challenge({
      factorId: t,
      webauthn: n,
      friendlyName: r,
      signal: s
  }, i) {
      try {
          const {
              data: o,
              error: a
          } = await this.client.mfa.challenge({
              factorId: t,
              webauthn: n
          });
          if (!o) return {
              data: null,
              error: a
          };
          const l = s ?? y3.createNewAbortSignal();
          if (o.webauthn.type === "create") {
              const {
                  user: c
              } = o.webauthn.credential_options.publicKey;
              c.name || (c.name = `${c.id}:${r}`), c.displayName || (c.displayName = c.name)
          }
          switch (o.webauthn.type) {
              case "create": {
                  const c = T3(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.create),
                      {
                          data: u,
                          error: d
                      } = await S3({
                          publicKey: c,
                          signal: l
                      });
                  return u ? {
                      data: {
                          factorId: t,
                          challengeId: o.id,
                          webauthn: {
                              type: o.webauthn.type,
                              credential_response: u
                          }
                      },
                      error: null
                  } : {
                      data: null,
                      error: d
                  }
              }
              case "request": {
                  const c = k3(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.request),
                      {
                          data: u,
                          error: d
                      } = await _3(Object.assign(Object.assign({}, o.webauthn.credential_options), {
                          publicKey: c,
                          signal: l
                      }));
                  return u ? {
                      data: {
                          factorId: t,
                          challengeId: o.id,
                          webauthn: {
                              type: o.webauthn.type,
                              credential_response: u
                          }
                      },
                      error: null
                  } : {
                      data: null,
                      error: d
                  }
              }
          }
      } catch (o) {
          return V(o) ? {
              data: null,
              error: o
          } : {
              data: null,
              error: new bs("Unexpected error in challenge", o)
          }
      }
  }
  async _verify({
      challengeId: t,
      factorId: n,
      webauthn: r
  }) {
      return this.client.mfa.verify({
          factorId: n,
          challengeId: t,
          webauthn: r
      })
  }
  async _authenticate({
      factorId: t,
      webauthn: {
          rpId: n = typeof window < "u" ? window.location.hostname : void 0,
          rpOrigins: r = typeof window < "u" ? [window.location.origin] : void 0,
          signal: s
      } = {}
  }, i) {
      if (!n) return {
          data: null,
          error: new Ka("rpId is required for WebAuthn authentication")
      };
      try {
          if (!bw()) return {
              data: null,
              error: new bs("Browser does not support WebAuthn", null)
          };
          const {
              data: o,
              error: a
          } = await this.challenge({
              factorId: t,
              webauthn: {
                  rpId: n,
                  rpOrigins: r
              },
              signal: s
          }, {
              request: i
          });
          if (!o) return {
              data: null,
              error: a
          };
          const {
              webauthn: l
          } = o;
          return this._verify({
              factorId: t,
              challengeId: o.challengeId,
              webauthn: {
                  type: l.type,
                  rpId: n,
                  rpOrigins: r,
                  credential_response: l.credential_response
              }
          })
      } catch (o) {
          return V(o) ? {
              data: null,
              error: o
          } : {
              data: null,
              error: new bs("Unexpected error in authenticate", o)
          }
      }
  }
  async _register({
      friendlyName: t,
      webauthn: {
          rpId: n = typeof window < "u" ? window.location.hostname : void 0,
          rpOrigins: r = typeof window < "u" ? [window.location.origin] : void 0,
          signal: s
      } = {}
  }, i) {
      if (!n) return {
          data: null,
          error: new Ka("rpId is required for WebAuthn registration")
      };
      try {
          if (!bw()) return {
              data: null,
              error: new bs("Browser does not support WebAuthn", null)
          };
          const {
              data: o,
              error: a
          } = await this._enroll({
              friendlyName: t
          });
          if (!o) return await this.client.mfa.listFactors().then(u => {
              var d;
              return (d = u.data) === null || d === void 0 ? void 0 : d.all.find(h => h.factor_type === "webauthn" && h.friendly_name === t && h.status !== "unverified")
          }).then(u => u ? this.client.mfa.unenroll({
              factorId: u == null ? void 0 : u.id
          }) : void 0), {
              data: null,
              error: a
          };
          const {
              data: l,
              error: c
          } = await this._challenge({
              factorId: o.id,
              friendlyName: o.friendly_name,
              webauthn: {
                  rpId: n,
                  rpOrigins: r
              },
              signal: s
          }, {
              create: i
          });
          return l ? this._verify({
              factorId: o.id,
              challengeId: l.challengeId,
              webauthn: {
                  rpId: n,
                  rpOrigins: r,
                  type: l.webauthn.type,
                  credential_response: l.webauthn.credential_response
              }
          }) : {
              data: null,
              error: c
          }
      } catch (o) {
          return V(o) ? {
              data: null,
              error: o
          } : {
              data: null,
              error: new bs("Unexpected error in register", o)
          }
      }
  }
}
u3();
const P3 = {
  url: E4,
  storageKey: C4,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: T4,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
  throwOnError: !1
};
async function Sw(e, t, n) {
  return await n()
}
const hi = {};
class qa {
  get jwks() {
      var t, n;
      return (n = (t = hi[this.storageKey]) === null || t === void 0 ? void 0 : t.jwks) !== null && n !== void 0 ? n : {
          keys: []
      }
  }
  set jwks(t) {
      hi[this.storageKey] = Object.assign(Object.assign({}, hi[this.storageKey]), {
          jwks: t
      })
  }
  get jwks_cached_at() {
      var t, n;
      return (n = (t = hi[this.storageKey]) === null || t === void 0 ? void 0 : t.cachedAt) !== null && n !== void 0 ? n : Number.MIN_SAFE_INTEGER
  }
  set jwks_cached_at(t) {
      hi[this.storageKey] = Object.assign(Object.assign({}, hi[this.storageKey]), {
          cachedAt: t
      })
  }
  constructor(t) {
      var n, r, s;
      this.userStorage = null, this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log;
      const i = Object.assign(Object.assign({}, P3), t);
      if (this.storageKey = i.storageKey, this.instanceID = (n = qa.nextInstanceID[this.storageKey]) !== null && n !== void 0 ? n : 0, qa.nextInstanceID[this.storageKey] = this.instanceID + 1, this.logDebugMessages = !!i.debug, typeof i.debug == "function" && (this.logger = i.debug), this.instanceID > 0 && Ke()) {
          const o = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
          console.warn(o), this.logDebugMessages && console.trace(o)
      }
      if (this.persistSession = i.persistSession, this.autoRefreshToken = i.autoRefreshToken, this.admin = new a3({
              url: i.url,
              headers: i.headers,
              fetch: i.fetch
          }), this.url = i.url, this.headers = i.headers, this.fetch = BE(i.fetch), this.lock = i.lock || Sw, this.detectSessionInUrl = i.detectSessionInUrl, this.flowType = i.flowType, this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader, this.throwOnError = i.throwOnError, i.lock ? this.lock = i.lock : this.persistSession && Ke() && (!((r = globalThis == null ? void 0 : globalThis.navigator) === null || r === void 0) && r.locks) ? this.lock = c3 : this.lock = Sw, this.jwks || (this.jwks = {
              keys: []
          }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER), this.mfa = {
              verify: this._verify.bind(this),
              enroll: this._enroll.bind(this),
              unenroll: this._unenroll.bind(this),
              challenge: this._challenge.bind(this),
              listFactors: this._listFactors.bind(this),
              challengeAndVerify: this._challengeAndVerify.bind(this),
              getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
              webauthn: new R3(this)
          }, this.oauth = {
              getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
              approveAuthorization: this._approveAuthorization.bind(this),
              denyAuthorization: this._denyAuthorization.bind(this),
              listGrants: this._listOAuthGrants.bind(this),
              revokeGrant: this._revokeOAuthGrant.bind(this)
          }, this.persistSession ? (i.storage ? this.storage = i.storage : VE() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = xw(this.memoryStorage)), i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {}, this.storage = xw(this.memoryStorage)), Ke() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
          try {
              this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
          } catch (o) {
              console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
          }(s = this.broadcastChannel) === null || s === void 0 || s.addEventListener("message", async o => {
              this._debug("received broadcast notification from other tab or client", o), await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
          })
      }
      this.initialize()
  }
  isThrowOnErrorEnabled() {
      return this.throwOnError
  }
  _returnResult(t) {
      if (this.throwOnError && t && t.error) throw t.error;
      return t
  }
  _logPrefix() {
      return `GoTrueClient@${this.storageKey}:${this.instanceID} (${$E}) ${new Date().toISOString()}`
  }
  _debug(...t) {
      return this.logDebugMessages && this.logger(this._logPrefix(), ...t), this
  }
  async initialize() {
      return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise)
  }
  async _initialize() {
      var t;
      try {
          let n = {},
              r = "none";
          if (Ke() && (n = V4(window.location.href), this._isImplicitGrantCallback(n) ? r = "implicit" : await this._isPKCECallback(n) && (r = "pkce")), Ke() && this.detectSessionInUrl && r !== "none") {
              const {
                  data: s,
                  error: i
              } = await this._getSessionFromURL(n, r);
              if (i) {
                  if (this._debug("#_initialize()", "error detecting session from URL", i), j4(i)) {
                      const l = (t = i.details) === null || t === void 0 ? void 0 : t.code;
                      if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable") return {
                          error: i
                      }
                  }
                  return await this._removeSession(), {
                      error: i
                  }
              }
              const {
                  session: o,
                  redirectType: a
              } = s;
              return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a), await this._saveSession(o), setTimeout(async () => {
                  a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
              }, 0), {
                  error: null
              }
          }
          return await this._recoverAndRefresh(), {
              error: null
          }
      } catch (n) {
          return V(n) ? this._returnResult({
              error: n
          }) : this._returnResult({
              error: new bs("Unexpected error during initialization", n)
          })
      } finally {
          await this._handleVisibilityChange(), this._debug("#_initialize()", "end")
      }
  }
  async signInAnonymously(t) {
      var n, r, s;
      try {
          const i = await H(this.fetch, "POST", `${this.url}/signup`, {
                  headers: this.headers,
                  body: {
                      data: (r = (n = t == null ? void 0 : t.options) === null || n === void 0 ? void 0 : n.data) !== null && r !== void 0 ? r : {},
                      gotrue_meta_security: {
                          captcha_token: (s = t == null ? void 0 : t.options) === null || s === void 0 ? void 0 : s.captchaToken
                      }
                  },
                  xform: en
              }),
              {
                  data: o,
                  error: a
              } = i;
          if (a || !o) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: a
          });
          const l = o.session,
              c = o.user;
          return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), this._returnResult({
              data: {
                  user: c,
                  session: l
              },
              error: null
          })
      } catch (i) {
          if (V(i)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: i
          });
          throw i
      }
  }
  async signUp(t) {
      var n, r, s;
      try {
          let i;
          if ("email" in t) {
              const {
                  email: u,
                  password: d,
                  options: h
              } = t;
              let f = null,
                  x = null;
              this.flowType === "pkce" && ([f, x] = await ci(this.storage, this.storageKey)), i = await H(this.fetch, "POST", `${this.url}/signup`, {
                  headers: this.headers,
                  redirectTo: h == null ? void 0 : h.emailRedirectTo,
                  body: {
                      email: u,
                      password: d,
                      data: (n = h == null ? void 0 : h.data) !== null && n !== void 0 ? n : {},
                      gotrue_meta_security: {
                          captcha_token: h == null ? void 0 : h.captchaToken
                      },
                      code_challenge: f,
                      code_challenge_method: x
                  },
                  xform: en
              })
          } else if ("phone" in t) {
              const {
                  phone: u,
                  password: d,
                  options: h
              } = t;
              i = await H(this.fetch, "POST", `${this.url}/signup`, {
                  headers: this.headers,
                  body: {
                      phone: u,
                      password: d,
                      data: (r = h == null ? void 0 : h.data) !== null && r !== void 0 ? r : {},
                      channel: (s = h == null ? void 0 : h.channel) !== null && s !== void 0 ? s : "sms",
                      gotrue_meta_security: {
                          captcha_token: h == null ? void 0 : h.captchaToken
                      }
                  },
                  xform: en
              })
          } else throw new ql("You must provide either an email or phone number and a password");
          const {
              data: o,
              error: a
          } = i;
          if (a || !o) return await He(this.storage, `${this.storageKey}-code-verifier`), this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: a
          });
          const l = o.session,
              c = o.user;
          return o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", l)), this._returnResult({
              data: {
                  user: c,
                  session: l
              },
              error: null
          })
      } catch (i) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(i)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: i
          });
          throw i
      }
  }
  async signInWithPassword(t) {
      try {
          let n;
          if ("email" in t) {
              const {
                  email: i,
                  password: o,
                  options: a
              } = t;
              n = await H(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                  headers: this.headers,
                  body: {
                      email: i,
                      password: o,
                      gotrue_meta_security: {
                          captcha_token: a == null ? void 0 : a.captchaToken
                      }
                  },
                  xform: vw
              })
          } else if ("phone" in t) {
              const {
                  phone: i,
                  password: o,
                  options: a
              } = t;
              n = await H(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                  headers: this.headers,
                  body: {
                      phone: i,
                      password: o,
                      gotrue_meta_security: {
                          captcha_token: a == null ? void 0 : a.captchaToken
                      }
                  },
                  xform: vw
              })
          } else throw new ql("You must provide either an email or phone number and a password");
          const {
              data: r,
              error: s
          } = n;
          if (s) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: s
          });
          if (!r || !r.session || !r.user) {
              const i = new li;
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: i
              })
          }
          return r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), this._returnResult({
              data: Object.assign({
                  user: r.user,
                  session: r.session
              }, r.weak_password ? {
                  weakPassword: r.weak_password
              } : null),
              error: s
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: n
          });
          throw n
      }
  }
  async signInWithOAuth(t) {
      var n, r, s, i;
      return await this._handleProviderSignIn(t.provider, {
          redirectTo: (n = t.options) === null || n === void 0 ? void 0 : n.redirectTo,
          scopes: (r = t.options) === null || r === void 0 ? void 0 : r.scopes,
          queryParams: (s = t.options) === null || s === void 0 ? void 0 : s.queryParams,
          skipBrowserRedirect: (i = t.options) === null || i === void 0 ? void 0 : i.skipBrowserRedirect
      })
  }
  async exchangeCodeForSession(t) {
      return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(t))
  }
  async signInWithWeb3(t) {
      const {
          chain: n
      } = t;
      switch (n) {
          case "ethereum":
              return await this.signInWithEthereum(t);
          case "solana":
              return await this.signInWithSolana(t);
          default:
              throw new Error(`@supabase/auth-js: Unsupported chain "${n}"`)
      }
  }
  async signInWithEthereum(t) {
      var n, r, s, i, o, a, l, c, u, d, h;
      let f, x;
      if ("message" in t) f = t.message, x = t.signature;
      else {
          const {
              chain: m,
              wallet: b,
              statement: v,
              options: y
          } = t;
          let w;
          if (Ke())
              if (typeof b == "object") w = b;
              else {
                  const P = window;
                  if ("ethereum" in P && typeof P.ethereum == "object" && "request" in P.ethereum && typeof P.ethereum.request == "function") w = P.ethereum;
                  else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")
              }
          else {
              if (typeof b != "object" || !(y != null && y.url)) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
              w = b
          }
          const S = new URL((n = y == null ? void 0 : y.url) !== null && n !== void 0 ? n : window.location.href),
              _ = await w.request({
                  method: "eth_requestAccounts"
              }).then(P => P).catch(() => {
                  throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
              });
          if (!_ || _.length === 0) throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
          const E = WE(_[0]);
          let T = (r = y == null ? void 0 : y.signInWithEthereum) === null || r === void 0 ? void 0 : r.chainId;
          if (!T) {
              const P = await w.request({
                  method: "eth_chainId"
              });
              T = d3(P)
          }
          const k = {
              domain: S.host,
              address: E,
              statement: v,
              uri: S.href,
              version: "1",
              chainId: T,
              nonce: (s = y == null ? void 0 : y.signInWithEthereum) === null || s === void 0 ? void 0 : s.nonce,
              issuedAt: (o = (i = y == null ? void 0 : y.signInWithEthereum) === null || i === void 0 ? void 0 : i.issuedAt) !== null && o !== void 0 ? o : new Date,
              expirationTime: (a = y == null ? void 0 : y.signInWithEthereum) === null || a === void 0 ? void 0 : a.expirationTime,
              notBefore: (l = y == null ? void 0 : y.signInWithEthereum) === null || l === void 0 ? void 0 : l.notBefore,
              requestId: (c = y == null ? void 0 : y.signInWithEthereum) === null || c === void 0 ? void 0 : c.requestId,
              resources: (u = y == null ? void 0 : y.signInWithEthereum) === null || u === void 0 ? void 0 : u.resources
          };
          f = f3(k), x = await w.request({
              method: "personal_sign",
              params: [h3(f), E]
          })
      }
      try {
          const {
              data: m,
              error: b
          } = await H(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
              headers: this.headers,
              body: Object.assign({
                  chain: "ethereum",
                  message: f,
                  signature: x
              }, !((d = t.options) === null || d === void 0) && d.captchaToken ? {
                  gotrue_meta_security: {
                      captcha_token: (h = t.options) === null || h === void 0 ? void 0 : h.captchaToken
                  }
              } : null),
              xform: en
          });
          if (b) throw b;
          if (!m || !m.session || !m.user) {
              const v = new li;
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: v
              })
          }
          return m.session && (await this._saveSession(m.session), await this._notifyAllSubscribers("SIGNED_IN", m.session)), this._returnResult({
              data: Object.assign({}, m),
              error: b
          })
      } catch (m) {
          if (V(m)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: m
          });
          throw m
      }
  }
  async signInWithSolana(t) {
      var n, r, s, i, o, a, l, c, u, d, h, f;
      let x, m;
      if ("message" in t) x = t.message, m = t.signature;
      else {
          const {
              chain: b,
              wallet: v,
              statement: y,
              options: w
          } = t;
          let S;
          if (Ke())
              if (typeof v == "object") S = v;
              else {
                  const E = window;
                  if ("solana" in E && typeof E.solana == "object" && ("signIn" in E.solana && typeof E.solana.signIn == "function" || "signMessage" in E.solana && typeof E.solana.signMessage == "function")) S = E.solana;
                  else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
              }
          else {
              if (typeof v != "object" || !(w != null && w.url)) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
              S = v
          }
          const _ = new URL((n = w == null ? void 0 : w.url) !== null && n !== void 0 ? n : window.location.href);
          if ("signIn" in S && S.signIn) {
              const E = await S.signIn(Object.assign(Object.assign(Object.assign({
                  issuedAt: new Date().toISOString()
              }, w == null ? void 0 : w.signInWithSolana), {
                  version: "1",
                  domain: _.host,
                  uri: _.href
              }), y ? {
                  statement: y
              } : null));
              let T;
              if (Array.isArray(E) && E[0] && typeof E[0] == "object") T = E[0];
              else if (E && typeof E == "object" && "signedMessage" in E && "signature" in E) T = E;
              else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
              if ("signedMessage" in T && "signature" in T && (typeof T.signedMessage == "string" || T.signedMessage instanceof Uint8Array) && T.signature instanceof Uint8Array) x = typeof T.signedMessage == "string" ? T.signedMessage : new TextDecoder().decode(T.signedMessage), m = T.signature;
              else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
          } else {
              if (!("signMessage" in S) || typeof S.signMessage != "function" || !("publicKey" in S) || typeof S != "object" || !S.publicKey || !("toBase58" in S.publicKey) || typeof S.publicKey.toBase58 != "function") throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
              x = [`${_.host} wants you to sign in with your Solana account:`, S.publicKey.toBase58(), ...y ? ["", y, ""] : [""], "Version: 1", `URI: ${_.href}`, `Issued At: ${(s = (r = w == null ? void 0 : w.signInWithSolana) === null || r === void 0 ? void 0 : r.issuedAt) !== null && s !== void 0 ? s : new Date().toISOString()}`, ...!((i = w == null ? void 0 : w.signInWithSolana) === null || i === void 0) && i.notBefore ? [`Not Before: ${w.signInWithSolana.notBefore}`] : [], ...!((o = w == null ? void 0 : w.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${w.signInWithSolana.expirationTime}`] : [], ...!((a = w == null ? void 0 : w.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${w.signInWithSolana.chainId}`] : [], ...!((l = w == null ? void 0 : w.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${w.signInWithSolana.nonce}`] : [], ...!((c = w == null ? void 0 : w.signInWithSolana) === null || c === void 0) && c.requestId ? [`Request ID: ${w.signInWithSolana.requestId}`] : [], ...!((d = (u = w == null ? void 0 : w.signInWithSolana) === null || u === void 0 ? void 0 : u.resources) === null || d === void 0) && d.length ? ["Resources", ...w.signInWithSolana.resources.map(T => `- ${T}`)] : []].join(`
`);
              const E = await S.signMessage(new TextEncoder().encode(x), "utf8");
              if (!E || !(E instanceof Uint8Array)) throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
              m = E
          }
      }
      try {
          const {
              data: b,
              error: v
          } = await H(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
              headers: this.headers,
              body: Object.assign({
                  chain: "solana",
                  message: x,
                  signature: ks(m)
              }, !((h = t.options) === null || h === void 0) && h.captchaToken ? {
                  gotrue_meta_security: {
                      captcha_token: (f = t.options) === null || f === void 0 ? void 0 : f.captchaToken
                  }
              } : null),
              xform: en
          });
          if (v) throw v;
          if (!b || !b.session || !b.user) {
              const y = new li;
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: y
              })
          }
          return b.session && (await this._saveSession(b.session), await this._notifyAllSubscribers("SIGNED_IN", b.session)), this._returnResult({
              data: Object.assign({}, b),
              error: v
          })
      } catch (b) {
          if (V(b)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: b
          });
          throw b
      }
  }
  async _exchangeCodeForSession(t) {
      const n = await ds(this.storage, `${this.storageKey}-code-verifier`),
          [r, s] = (n ?? "").split("/");
      try {
          if (!r && this.flowType === "pkce") throw new O4;
          const {
              data: i,
              error: o
          } = await H(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
              headers: this.headers,
              body: {
                  auth_code: t,
                  code_verifier: r
              },
              xform: en
          });
          if (await He(this.storage, `${this.storageKey}-code-verifier`), o) throw o;
          if (!i || !i.session || !i.user) {
              const a = new li;
              return this._returnResult({
                  data: {
                      user: null,
                      session: null,
                      redirectType: null
                  },
                  error: a
              })
          }
          return i.session && (await this._saveSession(i.session), await this._notifyAllSubscribers("SIGNED_IN", i.session)), this._returnResult({
              data: Object.assign(Object.assign({}, i), {
                  redirectType: s ?? null
              }),
              error: o
          })
      } catch (i) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(i)) return this._returnResult({
              data: {
                  user: null,
                  session: null,
                  redirectType: null
              },
              error: i
          });
          throw i
      }
  }
  async signInWithIdToken(t) {
      try {
          const {
              options: n,
              provider: r,
              token: s,
              access_token: i,
              nonce: o
          } = t, a = await H(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
              headers: this.headers,
              body: {
                  provider: r,
                  id_token: s,
                  access_token: i,
                  nonce: o,
                  gotrue_meta_security: {
                      captcha_token: n == null ? void 0 : n.captchaToken
                  }
              },
              xform: en
          }), {
              data: l,
              error: c
          } = a;
          if (c) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: c
          });
          if (!l || !l.session || !l.user) {
              const u = new li;
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: u
              })
          }
          return l.session && (await this._saveSession(l.session), await this._notifyAllSubscribers("SIGNED_IN", l.session)), this._returnResult({
              data: l,
              error: c
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: n
          });
          throw n
      }
  }
  async signInWithOtp(t) {
      var n, r, s, i, o;
      try {
          if ("email" in t) {
              const {
                  email: a,
                  options: l
              } = t;
              let c = null,
                  u = null;
              this.flowType === "pkce" && ([c, u] = await ci(this.storage, this.storageKey));
              const {
                  error: d
              } = await H(this.fetch, "POST", `${this.url}/otp`, {
                  headers: this.headers,
                  body: {
                      email: a,
                      data: (n = l == null ? void 0 : l.data) !== null && n !== void 0 ? n : {},
                      create_user: (r = l == null ? void 0 : l.shouldCreateUser) !== null && r !== void 0 ? r : !0,
                      gotrue_meta_security: {
                          captcha_token: l == null ? void 0 : l.captchaToken
                      },
                      code_challenge: c,
                      code_challenge_method: u
                  },
                  redirectTo: l == null ? void 0 : l.emailRedirectTo
              });
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: d
              })
          }
          if ("phone" in t) {
              const {
                  phone: a,
                  options: l
              } = t, {
                  data: c,
                  error: u
              } = await H(this.fetch, "POST", `${this.url}/otp`, {
                  headers: this.headers,
                  body: {
                      phone: a,
                      data: (s = l == null ? void 0 : l.data) !== null && s !== void 0 ? s : {},
                      create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                      gotrue_meta_security: {
                          captcha_token: l == null ? void 0 : l.captchaToken
                      },
                      channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                  }
              });
              return this._returnResult({
                  data: {
                      user: null,
                      session: null,
                      messageId: c == null ? void 0 : c.message_id
                  },
                  error: u
              })
          }
          throw new ql("You must provide either an email or phone number.")
      } catch (a) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(a)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: a
          });
          throw a
      }
  }
  async verifyOtp(t) {
      var n, r;
      try {
          let s, i;
          "options" in t && (s = (n = t.options) === null || n === void 0 ? void 0 : n.redirectTo, i = (r = t.options) === null || r === void 0 ? void 0 : r.captchaToken);
          const {
              data: o,
              error: a
          } = await H(this.fetch, "POST", `${this.url}/verify`, {
              headers: this.headers,
              body: Object.assign(Object.assign({}, t), {
                  gotrue_meta_security: {
                      captcha_token: i
                  }
              }),
              redirectTo: s,
              xform: en
          });
          if (a) throw a;
          if (!o) throw new Error("An error occurred on token verification.");
          const l = o.session,
              c = o.user;
          return l != null && l.access_token && (await this._saveSession(l), await this._notifyAllSubscribers(t.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)), this._returnResult({
              data: {
                  user: c,
                  session: l
              },
              error: null
          })
      } catch (s) {
          if (V(s)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: s
          });
          throw s
      }
  }
  async signInWithSSO(t) {
      var n, r, s, i, o;
      try {
          let a = null,
              l = null;
          this.flowType === "pkce" && ([a, l] = await ci(this.storage, this.storageKey));
          const c = await H(this.fetch, "POST", `${this.url}/sso`, {
              body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in t ? {
                  provider_id: t.providerId
              } : null), "domain" in t ? {
                  domain: t.domain
              } : null), {
                  redirect_to: (r = (n = t.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && r !== void 0 ? r : void 0
              }), !((s = t == null ? void 0 : t.options) === null || s === void 0) && s.captchaToken ? {
                  gotrue_meta_security: {
                      captcha_token: t.options.captchaToken
                  }
              } : null), {
                  skip_http_redirect: !0,
                  code_challenge: a,
                  code_challenge_method: l
              }),
              headers: this.headers,
              xform: s3
          });
          return !((i = c.data) === null || i === void 0) && i.url && Ke() && !(!((o = t.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(c.data.url), this._returnResult(c)
      } catch (a) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(a)) return this._returnResult({
              data: null,
              error: a
          });
          throw a
      }
  }
  async reauthenticate() {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate())
  }
  async _reauthenticate() {
      try {
          return await this._useSession(async t => {
              const {
                  data: {
                      session: n
                  },
                  error: r
              } = t;
              if (r) throw r;
              if (!n) throw new _t;
              const {
                  error: s
              } = await H(this.fetch, "GET", `${this.url}/reauthenticate`, {
                  headers: this.headers,
                  jwt: n.access_token
              });
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: s
              })
          })
      } catch (t) {
          if (V(t)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: t
          });
          throw t
      }
  }
  async resend(t) {
      try {
          const n = `${this.url}/resend`;
          if ("email" in t) {
              const {
                  email: r,
                  type: s,
                  options: i
              } = t, {
                  error: o
              } = await H(this.fetch, "POST", n, {
                  headers: this.headers,
                  body: {
                      email: r,
                      type: s,
                      gotrue_meta_security: {
                          captcha_token: i == null ? void 0 : i.captchaToken
                      }
                  },
                  redirectTo: i == null ? void 0 : i.emailRedirectTo
              });
              return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: o
              })
          } else if ("phone" in t) {
              const {
                  phone: r,
                  type: s,
                  options: i
              } = t, {
                  data: o,
                  error: a
              } = await H(this.fetch, "POST", n, {
                  headers: this.headers,
                  body: {
                      phone: r,
                      type: s,
                      gotrue_meta_security: {
                          captcha_token: i == null ? void 0 : i.captchaToken
                      }
                  }
              });
              return this._returnResult({
                  data: {
                      user: null,
                      session: null,
                      messageId: o == null ? void 0 : o.message_id
                  },
                  error: a
              })
          }
          throw new ql("You must provide either an email or phone number and a type")
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: n
          });
          throw n
      }
  }
  async getSession() {
      return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async n => n))
  }
  async _acquireLock(t, n) {
      this._debug("#_acquireLock", "begin", t);
      try {
          if (this.lockAcquired) {
              const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(),
                  s = (async () => (await r, await n()))();
              return this.pendingInLock.push((async () => {
                  try {
                      await s
                  } catch {}
              })()), s
          }
          return await this.lock(`lock:${this.storageKey}`, t, async () => {
              this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
              try {
                  this.lockAcquired = !0;
                  const r = n();
                  for (this.pendingInLock.push((async () => {
                          try {
                              await r
                          } catch {}
                      })()), await r; this.pendingInLock.length;) {
                      const s = [...this.pendingInLock];
                      await Promise.all(s), this.pendingInLock.splice(0, s.length)
                  }
                  return await r
              } finally {
                  this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1
              }
          })
      } finally {
          this._debug("#_acquireLock", "end")
      }
  }
  async _useSession(t) {
      this._debug("#_useSession", "begin");
      try {
          const n = await this.__loadSession();
          return await t(n)
      } finally {
          this._debug("#_useSession", "end")
      }
  }
  async __loadSession() {
      this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
      try {
          let t = null;
          const n = await ds(this.storage, this.storageKey);
          if (this._debug("#getSession()", "session from storage", n), n !== null && (this._isValidSession(n) ? t = n : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !t) return {
              data: {
                  session: null
              },
              error: null
          };
          const r = t.expires_at ? t.expires_at * 1e3 - Date.now() < sh : !1;
          if (this._debug("#__loadSession()", `session has${r ? "" : " not"} expired`, "expires_at", t.expires_at), !r) {
              if (this.userStorage) {
                  const o = await ds(this.userStorage, this.storageKey + "-user");
                  o != null && o.user ? t.user = o.user : t.user = ah()
              }
              if (this.storage.isServer && t.user && !t.user.__isUserNotAvailableProxy) {
                  const o = {
                      value: this.suppressGetSessionWarning
                  };
                  t.user = e3(t.user, o), o.value && (this.suppressGetSessionWarning = !0)
              }
              return {
                  data: {
                      session: t
                  },
                  error: null
              }
          }
          const {
              data: s,
              error: i
          } = await this._callRefreshToken(t.refresh_token);
          return i ? this._returnResult({
              data: {
                  session: null
              },
              error: i
          }) : this._returnResult({
              data: {
                  session: s
              },
              error: null
          })
      } finally {
          this._debug("#__loadSession()", "end")
      }
  }
  async getUser(t) {
      if (t) return await this._getUser(t);
      await this.initializePromise;
      const n = await this._acquireLock(-1, async () => await this._getUser());
      return n.data.user && (this.suppressGetSessionWarning = !0), n
  }
  async _getUser(t) {
      try {
          return t ? await H(this.fetch, "GET", `${this.url}/user`, {
              headers: this.headers,
              jwt: t,
              xform: _r
          }) : await this._useSession(async n => {
              var r, s, i;
              const {
                  data: o,
                  error: a
              } = n;
              if (a) throw a;
              return !(!((r = o.session) === null || r === void 0) && r.access_token) && !this.hasCustomAuthorizationHeader ? {
                  data: {
                      user: null
                  },
                  error: new _t
              } : await H(this.fetch, "GET", `${this.url}/user`, {
                  headers: this.headers,
                  jwt: (i = (s = o.session) === null || s === void 0 ? void 0 : s.access_token) !== null && i !== void 0 ? i : void 0,
                  xform: _r
              })
          })
      } catch (n) {
          if (V(n)) return N4(n) && (await this._removeSession(), await He(this.storage, `${this.storageKey}-code-verifier`)), this._returnResult({
              data: {
                  user: null
              },
              error: n
          });
          throw n
      }
  }
  async updateUser(t, n = {}) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(t, n))
  }
  async _updateUser(t, n = {}) {
      try {
          return await this._useSession(async r => {
              const {
                  data: s,
                  error: i
              } = r;
              if (i) throw i;
              if (!s.session) throw new _t;
              const o = s.session;
              let a = null,
                  l = null;
              this.flowType === "pkce" && t.email != null && ([a, l] = await ci(this.storage, this.storageKey));
              const {
                  data: c,
                  error: u
              } = await H(this.fetch, "PUT", `${this.url}/user`, {
                  headers: this.headers,
                  redirectTo: n == null ? void 0 : n.emailRedirectTo,
                  body: Object.assign(Object.assign({}, t), {
                      code_challenge: a,
                      code_challenge_method: l
                  }),
                  jwt: o.access_token,
                  xform: _r
              });
              if (u) throw u;
              return o.user = c.user, await this._saveSession(o), await this._notifyAllSubscribers("USER_UPDATED", o), this._returnResult({
                  data: {
                      user: o.user
                  },
                  error: null
              })
          })
      } catch (r) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(r)) return this._returnResult({
              data: {
                  user: null
              },
              error: r
          });
          throw r
      }
  }
  async setSession(t) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(t))
  }
  async _setSession(t) {
      try {
          if (!t.access_token || !t.refresh_token) throw new _t;
          const n = Date.now() / 1e3;
          let r = n,
              s = !0,
              i = null;
          const {
              payload: o
          } = oh(t.access_token);
          if (o.exp && (r = o.exp, s = r <= n), s) {
              const {
                  data: a,
                  error: l
              } = await this._callRefreshToken(t.refresh_token);
              if (l) return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: l
              });
              if (!a) return {
                  data: {
                      user: null,
                      session: null
                  },
                  error: null
              };
              i = a
          } else {
              const {
                  data: a,
                  error: l
              } = await this._getUser(t.access_token);
              if (l) throw l;
              i = {
                  access_token: t.access_token,
                  refresh_token: t.refresh_token,
                  user: a.user,
                  token_type: "bearer",
                  expires_in: r - n,
                  expires_at: r
              }, await this._saveSession(i), await this._notifyAllSubscribers("SIGNED_IN", i)
          }
          return this._returnResult({
              data: {
                  user: i.user,
                  session: i
              },
              error: null
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: {
                  session: null,
                  user: null
              },
              error: n
          });
          throw n
      }
  }
  async refreshSession(t) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(t))
  }
  async _refreshSession(t) {
      try {
          return await this._useSession(async n => {
              var r;
              if (!t) {
                  const {
                      data: o,
                      error: a
                  } = n;
                  if (a) throw a;
                  t = (r = o.session) !== null && r !== void 0 ? r : void 0
              }
              if (!(t != null && t.refresh_token)) throw new _t;
              const {
                  data: s,
                  error: i
              } = await this._callRefreshToken(t.refresh_token);
              return i ? this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: i
              }) : s ? this._returnResult({
                  data: {
                      user: s.user,
                      session: s
                  },
                  error: null
              }) : this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: null
              })
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: {
                  user: null,
                  session: null
              },
              error: n
          });
          throw n
      }
  }
  async _getSessionFromURL(t, n) {
      try {
          if (!Ke()) throw new Gl("No browser detected.");
          if (t.error || t.error_description || t.error_code) throw new Gl(t.error_description || "Error in URL with unspecified error_description", {
              error: t.error || "unspecified_error",
              code: t.error_code || "unspecified_code"
          });
          switch (n) {
              case "implicit":
                  if (this.flowType === "pkce") throw new dw("Not a valid PKCE flow url.");
                  break;
              case "pkce":
                  if (this.flowType === "implicit") throw new Gl("Not a valid implicit grant flow url.");
                  break;
              default:
          }
          if (n === "pkce") {
              if (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !t.code) throw new dw("No code detected.");
              const {
                  data: y,
                  error: w
              } = await this._exchangeCodeForSession(t.code);
              if (w) throw w;
              const S = new URL(window.location.href);
              return S.searchParams.delete("code"), window.history.replaceState(window.history.state, "", S.toString()), {
                  data: {
                      session: y.session,
                      redirectType: null
                  },
                  error: null
              }
          }
          const {
              provider_token: r,
              provider_refresh_token: s,
              access_token: i,
              refresh_token: o,
              expires_in: a,
              expires_at: l,
              token_type: c
          } = t;
          if (!i || !a || !o || !c) throw new Gl("No session defined in URL");
          const u = Math.round(Date.now() / 1e3),
              d = parseInt(a);
          let h = u + d;
          l && (h = parseInt(l));
          const f = h - u;
          f * 1e3 <= yi && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${f}s, should have been closer to ${d}s`);
          const x = h - d;
          u - x >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", x, h, u) : u - x < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", x, h, u);
          const {
              data: m,
              error: b
          } = await this._getUser(i);
          if (b) throw b;
          const v = {
              provider_token: r,
              provider_refresh_token: s,
              access_token: i,
              expires_in: d,
              expires_at: h,
              refresh_token: o,
              token_type: c,
              user: m.user
          };
          return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), this._returnResult({
              data: {
                  session: v,
                  redirectType: t.type
              },
              error: null
          })
      } catch (r) {
          if (V(r)) return this._returnResult({
              data: {
                  session: null,
                  redirectType: null
              },
              error: r
          });
          throw r
      }
  }
  _isImplicitGrantCallback(t) {
      return typeof this.detectSessionInUrl == "function" ? this.detectSessionInUrl(new URL(window.location.href), t) : !!(t.access_token || t.error_description)
  }
  async _isPKCECallback(t) {
      const n = await ds(this.storage, `${this.storageKey}-code-verifier`);
      return !!(t.code && n)
  }
  async signOut(t = {
      scope: "global"
  }) {
      return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(t))
  }
  async _signOut({
      scope: t
  } = {
      scope: "global"
  }) {
      return await this._useSession(async n => {
          var r;
          const {
              data: s,
              error: i
          } = n;
          if (i) return this._returnResult({
              error: i
          });
          const o = (r = s.session) === null || r === void 0 ? void 0 : r.access_token;
          if (o) {
              const {
                  error: a
              } = await this.admin.signOut(o, t);
              if (a && !(A4(a) && (a.status === 404 || a.status === 401 || a.status === 403))) return this._returnResult({
                  error: a
              })
          }
          return t !== "others" && (await this._removeSession(), await He(this.storage, `${this.storageKey}-code-verifier`)), this._returnResult({
              error: null
          })
      })
  }
  onAuthStateChange(t) {
      const n = U4(),
          r = {
              id: n,
              callback: t,
              unsubscribe: () => {
                  this._debug("#unsubscribe()", "state change callback with id removed", n), this.stateChangeEmitters.delete(n)
              }
          };
      return this._debug("#onAuthStateChange()", "registered callback with id", n), this.stateChangeEmitters.set(n, r), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => {
          this._emitInitialSession(n)
      })))(), {
          data: {
              subscription: r
          }
      }
  }
  async _emitInitialSession(t) {
      return await this._useSession(async n => {
          var r, s;
          try {
              const {
                  data: {
                      session: i
                  },
                  error: o
              } = n;
              if (o) throw o;
              await ((r = this.stateChangeEmitters.get(t)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", i)), this._debug("INITIAL_SESSION", "callback id", t, "session", i)
          } catch (i) {
              await ((s = this.stateChangeEmitters.get(t)) === null || s === void 0 ? void 0 : s.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", t, "error", i), console.error(i)
          }
      })
  }
  async resetPasswordForEmail(t, n = {}) {
      let r = null,
          s = null;
      this.flowType === "pkce" && ([r, s] = await ci(this.storage, this.storageKey, !0));
      try {
          return await H(this.fetch, "POST", `${this.url}/recover`, {
              body: {
                  email: t,
                  code_challenge: r,
                  code_challenge_method: s,
                  gotrue_meta_security: {
                      captcha_token: n.captchaToken
                  }
              },
              headers: this.headers,
              redirectTo: n.redirectTo
          })
      } catch (i) {
          if (await He(this.storage, `${this.storageKey}-code-verifier`), V(i)) return this._returnResult({
              data: null,
              error: i
          });
          throw i
      }
  }
  async getUserIdentities() {
      var t;
      try {
          const {
              data: n,
              error: r
          } = await this.getUser();
          if (r) throw r;
          return this._returnResult({
              data: {
                  identities: (t = n.user.identities) !== null && t !== void 0 ? t : []
              },
              error: null
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async linkIdentity(t) {
      return "token" in t ? this.linkIdentityIdToken(t) : this.linkIdentityOAuth(t)
  }
  async linkIdentityOAuth(t) {
      var n;
      try {
          const {
              data: r,
              error: s
          } = await this._useSession(async i => {
              var o, a, l, c, u;
              const {
                  data: d,
                  error: h
              } = i;
              if (h) throw h;
              const f = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, t.provider, {
                  redirectTo: (o = t.options) === null || o === void 0 ? void 0 : o.redirectTo,
                  scopes: (a = t.options) === null || a === void 0 ? void 0 : a.scopes,
                  queryParams: (l = t.options) === null || l === void 0 ? void 0 : l.queryParams,
                  skipBrowserRedirect: !0
              });
              return await H(this.fetch, "GET", f, {
                  headers: this.headers,
                  jwt: (u = (c = d.session) === null || c === void 0 ? void 0 : c.access_token) !== null && u !== void 0 ? u : void 0
              })
          });
          if (s) throw s;
          return Ke() && !(!((n = t.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(r == null ? void 0 : r.url), this._returnResult({
              data: {
                  provider: t.provider,
                  url: r == null ? void 0 : r.url
              },
              error: null
          })
      } catch (r) {
          if (V(r)) return this._returnResult({
              data: {
                  provider: t.provider,
                  url: null
              },
              error: r
          });
          throw r
      }
  }
  async linkIdentityIdToken(t) {
      return await this._useSession(async n => {
          var r;
          try {
              const {
                  error: s,
                  data: {
                      session: i
                  }
              } = n;
              if (s) throw s;
              const {
                  options: o,
                  provider: a,
                  token: l,
                  access_token: c,
                  nonce: u
              } = t, d = await H(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                  headers: this.headers,
                  jwt: (r = i == null ? void 0 : i.access_token) !== null && r !== void 0 ? r : void 0,
                  body: {
                      provider: a,
                      id_token: l,
                      access_token: c,
                      nonce: u,
                      link_identity: !0,
                      gotrue_meta_security: {
                          captcha_token: o == null ? void 0 : o.captchaToken
                      }
                  },
                  xform: en
              }), {
                  data: h,
                  error: f
              } = d;
              return f ? this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: f
              }) : !h || !h.session || !h.user ? this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: new li
              }) : (h.session && (await this._saveSession(h.session), await this._notifyAllSubscribers("USER_UPDATED", h.session)), this._returnResult({
                  data: h,
                  error: f
              }))
          } catch (s) {
              if (await He(this.storage, `${this.storageKey}-code-verifier`), V(s)) return this._returnResult({
                  data: {
                      user: null,
                      session: null
                  },
                  error: s
              });
              throw s
          }
      })
  }
  async unlinkIdentity(t) {
      try {
          return await this._useSession(async n => {
              var r, s;
              const {
                  data: i,
                  error: o
              } = n;
              if (o) throw o;
              return await H(this.fetch, "DELETE", `${this.url}/user/identities/${t.identity_id}`, {
                  headers: this.headers,
                  jwt: (s = (r = i.session) === null || r === void 0 ? void 0 : r.access_token) !== null && s !== void 0 ? s : void 0
              })
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async _refreshAccessToken(t) {
      const n = `#_refreshAccessToken(${t.substring(0, 5)}...)`;
      this._debug(n, "begin");
      try {
          const r = Date.now();
          return await W4(async s => (s > 0 && await z4(200 * Math.pow(2, s - 1)), this._debug(n, "refreshing attempt", s), await H(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
              body: {
                  refresh_token: t
              },
              headers: this.headers,
              xform: en
          })), (s, i) => {
              const o = 200 * Math.pow(2, s);
              return i && ih(i) && Date.now() + o - r < yi
          })
      } catch (r) {
          if (this._debug(n, "error", r), V(r)) return this._returnResult({
              data: {
                  session: null,
                  user: null
              },
              error: r
          });
          throw r
      } finally {
          this._debug(n, "end")
      }
  }
  _isValidSession(t) {
      return typeof t == "object" && t !== null && "access_token" in t && "refresh_token" in t && "expires_at" in t
  }
  async _handleProviderSignIn(t, n) {
      const r = await this._getUrlForProvider(`${this.url}/authorize`, t, {
          redirectTo: n.redirectTo,
          scopes: n.scopes,
          queryParams: n.queryParams
      });
      return this._debug("#_handleProviderSignIn()", "provider", t, "options", n, "url", r), Ke() && !n.skipBrowserRedirect && window.location.assign(r), {
          data: {
              provider: t,
              url: r
          },
          error: null
      }
  }
  async _recoverAndRefresh() {
      var t, n;
      const r = "#_recoverAndRefresh()";
      this._debug(r, "begin");
      try {
          const s = await ds(this.storage, this.storageKey);
          if (s && this.userStorage) {
              let o = await ds(this.userStorage, this.storageKey + "-user");
              !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                  user: s.user
              }, await vi(this.userStorage, this.storageKey + "-user", o)), s.user = (t = o == null ? void 0 : o.user) !== null && t !== void 0 ? t : ah()
          } else if (s && !s.user && !s.user) {
              const o = await ds(this.storage, this.storageKey + "-user");
              o && (o != null && o.user) ? (s.user = o.user, await He(this.storage, this.storageKey + "-user"), await vi(this.storage, this.storageKey, s)) : s.user = ah()
          }
          if (this._debug(r, "session from storage", s), !this._isValidSession(s)) {
              this._debug(r, "session is not valid"), s !== null && await this._removeSession();
              return
          }
          const i = ((n = s.expires_at) !== null && n !== void 0 ? n : 1 / 0) * 1e3 - Date.now() < sh;
          if (this._debug(r, `session has${i ? "" : " not"} expired with margin of ${sh}s`), i) {
              if (this.autoRefreshToken && s.refresh_token) {
                  const {
                      error: o
                  } = await this._callRefreshToken(s.refresh_token);
                  o && (console.error(o), ih(o) || (this._debug(r, "refresh failed with a non-retryable error, removing the session", o), await this._removeSession()))
              }
          } else if (s.user && s.user.__isUserNotAvailableProxy === !0) try {
              const {
                  data: o,
                  error: a
              } = await this._getUser(s.access_token);
              !a && (o != null && o.user) ? (s.user = o.user, await this._saveSession(s), await this._notifyAllSubscribers("SIGNED_IN", s)) : this._debug(r, "could not get user data, skipping SIGNED_IN notification")
          } catch (o) {
              console.error("Error getting user data:", o), this._debug(r, "error getting user data, skipping SIGNED_IN notification", o)
          } else await this._notifyAllSubscribers("SIGNED_IN", s)
      } catch (s) {
          this._debug(r, "error", s), console.error(s);
          return
      } finally {
          this._debug(r, "end")
      }
  }
  async _callRefreshToken(t) {
      var n, r;
      if (!t) throw new _t;
      if (this.refreshingDeferred) return this.refreshingDeferred.promise;
      const s = `#_callRefreshToken(${t.substring(0, 5)}...)`;
      this._debug(s, "begin");
      try {
          this.refreshingDeferred = new Ku;
          const {
              data: i,
              error: o
          } = await this._refreshAccessToken(t);
          if (o) throw o;
          if (!i.session) throw new _t;
          await this._saveSession(i.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
          const a = {
              data: i.session,
              error: null
          };
          return this.refreshingDeferred.resolve(a), a
      } catch (i) {
          if (this._debug(s, "error", i), V(i)) {
              const o = {
                  data: null,
                  error: i
              };
              return ih(i) || await this._removeSession(), (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(o), o
          }
          throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(i), i
      } finally {
          this.refreshingDeferred = null, this._debug(s, "end")
      }
  }
  async _notifyAllSubscribers(t, n, r = !0) {
      const s = `#_notifyAllSubscribers(${t})`;
      this._debug(s, "begin", n, `broadcast = ${r}`);
      try {
          this.broadcastChannel && r && this.broadcastChannel.postMessage({
              event: t,
              session: n
          });
          const i = [],
              o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                  try {
                      await a.callback(t, n)
                  } catch (l) {
                      i.push(l)
                  }
              });
          if (await Promise.all(o), i.length > 0) {
              for (let a = 0; a < i.length; a += 1) console.error(i[a]);
              throw i[0]
          }
      } finally {
          this._debug(s, "end")
      }
  }
  async _saveSession(t) {
      this._debug("#_saveSession()", t), this.suppressGetSessionWarning = !0, await He(this.storage, `${this.storageKey}-code-verifier`);
      const n = Object.assign({}, t),
          r = n.user && n.user.__isUserNotAvailableProxy === !0;
      if (this.userStorage) {
          !r && n.user && await vi(this.userStorage, this.storageKey + "-user", {
              user: n.user
          });
          const s = Object.assign({}, n);
          delete s.user;
          const i = gw(s);
          await vi(this.storage, this.storageKey, i)
      } else {
          const s = gw(n);
          await vi(this.storage, this.storageKey, s)
      }
  }
  async _removeSession() {
      this._debug("#_removeSession()"), this.suppressGetSessionWarning = !1, await He(this.storage, this.storageKey), await He(this.storage, this.storageKey + "-code-verifier"), await He(this.storage, this.storageKey + "-user"), this.userStorage && await He(this.userStorage, this.storageKey + "-user"), await this._notifyAllSubscribers("SIGNED_OUT", null)
  }
  _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const t = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
          t && Ke() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", t)
      } catch (n) {
          console.error("removing visibilitychange callback failed", n)
      }
  }
  async _startAutoRefresh() {
      await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
      const t = setInterval(() => this._autoRefreshTokenTick(), yi);
      this.autoRefreshTicker = t, t && typeof t == "object" && typeof t.unref == "function" ? t.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(t), setTimeout(async () => {
          await this.initializePromise, await this._autoRefreshTokenTick()
      }, 0)
  }
  async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      const t = this.autoRefreshTicker;
      this.autoRefreshTicker = null, t && clearInterval(t)
  }
  async startAutoRefresh() {
      this._removeVisibilityChangedCallback(), await this._startAutoRefresh()
  }
  async stopAutoRefresh() {
      this._removeVisibilityChangedCallback(), await this._stopAutoRefresh()
  }
  async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
          await this._acquireLock(0, async () => {
              try {
                  const t = Date.now();
                  try {
                      return await this._useSession(async n => {
                          const {
                              data: {
                                  session: r
                              }
                          } = n;
                          if (!r || !r.refresh_token || !r.expires_at) {
                              this._debug("#_autoRefreshTokenTick()", "no session");
                              return
                          }
                          const s = Math.floor((r.expires_at * 1e3 - t) / yi);
                          this._debug("#_autoRefreshTokenTick()", `access token expires in ${s} ticks, a tick lasts ${yi}ms, refresh threshold is ${hp} ticks`), s <= hp && await this._callRefreshToken(r.refresh_token)
                      })
                  } catch (n) {
                      console.error("Auto refresh tick failed with error. This is likely a transient error.", n)
                  }
              } finally {
                  this._debug("#_autoRefreshTokenTick()", "end")
              }
          })
      } catch (t) {
          if (t.isAcquireTimeout || t instanceof zE) this._debug("auto refresh token tick lock not available");
          else throw t
      }
  }
  async _handleVisibilityChange() {
      if (this._debug("#_handleVisibilityChange()"), !Ke() || !(window != null && window.addEventListener)) return this.autoRefreshToken && this.startAutoRefresh(), !1;
      try {
          this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0)
      } catch (t) {
          console.error("_handleVisibilityChange", t)
      }
  }
  async _onVisibilityChanged(t) {
      const n = `#_onVisibilityChanged(${t})`;
      this._debug(n, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), t || (await this.initializePromise, await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
              this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
              return
          }
          await this._recoverAndRefresh()
      }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
  }
  async _getUrlForProvider(t, n, r) {
      const s = [`provider=${encodeURIComponent(n)}`];
      if (r != null && r.redirectTo && s.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`), r != null && r.scopes && s.push(`scopes=${encodeURIComponent(r.scopes)}`), this.flowType === "pkce") {
          const [i, o] = await ci(this.storage, this.storageKey), a = new URLSearchParams({
              code_challenge: `${encodeURIComponent(i)}`,
              code_challenge_method: `${encodeURIComponent(o)}`
          });
          s.push(a.toString())
      }
      if (r != null && r.queryParams) {
          const i = new URLSearchParams(r.queryParams);
          s.push(i.toString())
      }
      return r != null && r.skipBrowserRedirect && s.push(`skip_http_redirect=${r.skipBrowserRedirect}`), `${t}?${s.join("&")}`
  }
  async _unenroll(t) {
      try {
          return await this._useSession(async n => {
              var r;
              const {
                  data: s,
                  error: i
              } = n;
              return i ? this._returnResult({
                  data: null,
                  error: i
              }) : await H(this.fetch, "DELETE", `${this.url}/factors/${t.factorId}`, {
                  headers: this.headers,
                  jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token
              })
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async _enroll(t) {
      try {
          return await this._useSession(async n => {
              var r, s;
              const {
                  data: i,
                  error: o
              } = n;
              if (o) return this._returnResult({
                  data: null,
                  error: o
              });
              const a = Object.assign({
                      friendly_name: t.friendlyName,
                      factor_type: t.factorType
                  }, t.factorType === "phone" ? {
                      phone: t.phone
                  } : t.factorType === "totp" ? {
                      issuer: t.issuer
                  } : {}),
                  {
                      data: l,
                      error: c
                  } = await H(this.fetch, "POST", `${this.url}/factors`, {
                      body: a,
                      headers: this.headers,
                      jwt: (r = i == null ? void 0 : i.session) === null || r === void 0 ? void 0 : r.access_token
                  });
              return c ? this._returnResult({
                  data: null,
                  error: c
              }) : (t.factorType === "totp" && l.type === "totp" && (!((s = l == null ? void 0 : l.totp) === null || s === void 0) && s.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`), this._returnResult({
                  data: l,
                  error: null
              }))
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async _verify(t) {
      return this._acquireLock(-1, async () => {
          try {
              return await this._useSession(async n => {
                  var r;
                  const {
                      data: s,
                      error: i
                  } = n;
                  if (i) return this._returnResult({
                      data: null,
                      error: i
                  });
                  const o = Object.assign({
                          challenge_id: t.challengeId
                      }, "webauthn" in t ? {
                          webauthn: Object.assign(Object.assign({}, t.webauthn), {
                              credential_response: t.webauthn.type === "create" ? x3(t.webauthn.credential_response) : b3(t.webauthn.credential_response)
                          })
                      } : {
                          code: t.code
                      }),
                      {
                          data: a,
                          error: l
                      } = await H(this.fetch, "POST", `${this.url}/factors/${t.factorId}/verify`, {
                          body: o,
                          headers: this.headers,
                          jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token
                      });
                  return l ? this._returnResult({
                      data: null,
                      error: l
                  }) : (await this._saveSession(Object.assign({
                      expires_at: Math.round(Date.now() / 1e3) + a.expires_in
                  }, a)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a), this._returnResult({
                      data: a,
                      error: l
                  }))
              })
          } catch (n) {
              if (V(n)) return this._returnResult({
                  data: null,
                  error: n
              });
              throw n
          }
      })
  }
  async _challenge(t) {
      return this._acquireLock(-1, async () => {
          try {
              return await this._useSession(async n => {
                  var r;
                  const {
                      data: s,
                      error: i
                  } = n;
                  if (i) return this._returnResult({
                      data: null,
                      error: i
                  });
                  const o = await H(this.fetch, "POST", `${this.url}/factors/${t.factorId}/challenge`, {
                      body: t,
                      headers: this.headers,
                      jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token
                  });
                  if (o.error) return o;
                  const {
                      data: a
                  } = o;
                  if (a.type !== "webauthn") return {
                      data: a,
                      error: null
                  };
                  switch (a.webauthn.type) {
                      case "create":
                          return {
                              data: Object.assign(Object.assign({}, a), {
                                  webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                      credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                          publicKey: v3(a.webauthn.credential_options.publicKey)
                                      })
                                  })
                              }), error: null
                          };
                      case "request":
                          return {
                              data: Object.assign(Object.assign({}, a), {
                                  webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                      credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                          publicKey: w3(a.webauthn.credential_options.publicKey)
                                      })
                                  })
                              }), error: null
                          }
                  }
              })
          } catch (n) {
              if (V(n)) return this._returnResult({
                  data: null,
                  error: n
              });
              throw n
          }
      })
  }
  async _challengeAndVerify(t) {
      const {
          data: n,
          error: r
      } = await this._challenge({
          factorId: t.factorId
      });
      return r ? this._returnResult({
          data: null,
          error: r
      }) : await this._verify({
          factorId: t.factorId,
          challengeId: n.id,
          code: t.code
      })
  }
  async _listFactors() {
      var t;
      const {
          data: {
              user: n
          },
          error: r
      } = await this.getUser();
      if (r) return {
          data: null,
          error: r
      };
      const s = {
          all: [],
          phone: [],
          totp: [],
          webauthn: []
      };
      for (const i of (t = n == null ? void 0 : n.factors) !== null && t !== void 0 ? t : []) s.all.push(i), i.status === "verified" && s[i.factor_type].push(i);
      return {
          data: s,
          error: null
      }
  }
  async _getAuthenticatorAssuranceLevel() {
      var t, n;
      const {
          data: {
              session: r
          },
          error: s
      } = await this.getSession();
      if (s) return this._returnResult({
          data: null,
          error: s
      });
      if (!r) return {
          data: {
              currentLevel: null,
              nextLevel: null,
              currentAuthenticationMethods: []
          },
          error: null
      };
      const {
          payload: i
      } = oh(r.access_token);
      let o = null;
      i.aal && (o = i.aal);
      let a = o;
      ((n = (t = r.user.factors) === null || t === void 0 ? void 0 : t.filter(u => u.status === "verified")) !== null && n !== void 0 ? n : []).length > 0 && (a = "aal2");
      const c = i.amr || [];
      return {
          data: {
              currentLevel: o,
              nextLevel: a,
              currentAuthenticationMethods: c
          },
          error: null
      }
  }
  async _getAuthorizationDetails(t) {
      try {
          return await this._useSession(async n => {
              const {
                  data: {
                      session: r
                  },
                  error: s
              } = n;
              return s ? this._returnResult({
                  data: null,
                  error: s
              }) : r ? await H(this.fetch, "GET", `${this.url}/oauth/authorizations/${t}`, {
                  headers: this.headers,
                  jwt: r.access_token,
                  xform: i => ({
                      data: i,
                      error: null
                  })
              }) : this._returnResult({
                  data: null,
                  error: new _t
              })
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async _approveAuthorization(t, n) {
      try {
          return await this._useSession(async r => {
              const {
                  data: {
                      session: s
                  },
                  error: i
              } = r;
              if (i) return this._returnResult({
                  data: null,
                  error: i
              });
              if (!s) return this._returnResult({
                  data: null,
                  error: new _t
              });
              const o = await H(this.fetch, "POST", `${this.url}/oauth/authorizations/${t}/consent`, {
                  headers: this.headers,
                  jwt: s.access_token,
                  body: {
                      action: "approve"
                  },
                  xform: a => ({
                      data: a,
                      error: null
                  })
              });
              return o.data && o.data.redirect_url && Ke() && !(n != null && n.skipBrowserRedirect) && window.location.assign(o.data.redirect_url), o
          })
      } catch (r) {
          if (V(r)) return this._returnResult({
              data: null,
              error: r
          });
          throw r
      }
  }
  async _denyAuthorization(t, n) {
      try {
          return await this._useSession(async r => {
              const {
                  data: {
                      session: s
                  },
                  error: i
              } = r;
              if (i) return this._returnResult({
                  data: null,
                  error: i
              });
              if (!s) return this._returnResult({
                  data: null,
                  error: new _t
              });
              const o = await H(this.fetch, "POST", `${this.url}/oauth/authorizations/${t}/consent`, {
                  headers: this.headers,
                  jwt: s.access_token,
                  body: {
                      action: "deny"
                  },
                  xform: a => ({
                      data: a,
                      error: null
                  })
              });
              return o.data && o.data.redirect_url && Ke() && !(n != null && n.skipBrowserRedirect) && window.location.assign(o.data.redirect_url), o
          })
      } catch (r) {
          if (V(r)) return this._returnResult({
              data: null,
              error: r
          });
          throw r
      }
  }
  async _listOAuthGrants() {
      try {
          return await this._useSession(async t => {
              const {
                  data: {
                      session: n
                  },
                  error: r
              } = t;
              return r ? this._returnResult({
                  data: null,
                  error: r
              }) : n ? await H(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
                  headers: this.headers,
                  jwt: n.access_token,
                  xform: s => ({
                      data: s,
                      error: null
                  })
              }) : this._returnResult({
                  data: null,
                  error: new _t
              })
          })
      } catch (t) {
          if (V(t)) return this._returnResult({
              data: null,
              error: t
          });
          throw t
      }
  }
  async _revokeOAuthGrant(t) {
      try {
          return await this._useSession(async n => {
              const {
                  data: {
                      session: r
                  },
                  error: s
              } = n;
              return s ? this._returnResult({
                  data: null,
                  error: s
              }) : r ? (await H(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
                  headers: this.headers,
                  jwt: r.access_token,
                  query: {
                      client_id: t.clientId
                  },
                  noResolveJson: !0
              }), {
                  data: {},
                  error: null
              }) : this._returnResult({
                  data: null,
                  error: new _t
              })
          })
      } catch (n) {
          if (V(n)) return this._returnResult({
              data: null,
              error: n
          });
          throw n
      }
  }
  async fetchJwk(t, n = {
      keys: []
  }) {
      let r = n.keys.find(a => a.kid === t);
      if (r) return r;
      const s = Date.now();
      if (r = this.jwks.keys.find(a => a.kid === t), r && this.jwks_cached_at + R4 > s) return r;
      const {
          data: i,
          error: o
      } = await H(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
          headers: this.headers
      });
      if (o) throw o;
      return !i.keys || i.keys.length === 0 || (this.jwks = i, this.jwks_cached_at = s, r = i.keys.find(a => a.kid === t), !r) ? null : r
  }
  async getClaims(t, n = {}) {
      try {
          let r = t;
          if (!r) {
              const {
                  data: f,
                  error: x
              } = await this.getSession();
              if (x || !f.session) return this._returnResult({
                  data: null,
                  error: x
              });
              r = f.session.access_token
          }
          const {
              header: s,
              payload: i,
              signature: o,
              raw: {
                  header: a,
                  payload: l
              }
          } = oh(r);
          n != null && n.allowExpired || J4(i.exp);
          const c = !s.alg || s.alg.startsWith("HS") || !s.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(s.kid, n != null && n.keys ? {
              keys: n.keys
          } : n == null ? void 0 : n.jwks);
          if (!c) {
              const {
                  error: f
              } = await this.getUser(r);
              if (f) throw f;
              return {
                  data: {
                      claims: i,
                      header: s,
                      signature: o
                  },
                  error: null
              }
          }
          const u = X4(s.alg),
              d = await crypto.subtle.importKey("jwk", c, u, !0, ["verify"]);
          if (!await crypto.subtle.verify(u, d, o, $4(`${a}.${l}`))) throw new mp("Invalid JWT signature");
          return {
              data: {
                  claims: i,
                  header: s,
                  signature: o
              },
              error: null
          }
      } catch (r) {
          if (V(r)) return this._returnResult({
              data: null,
              error: r
          });
          throw r
      }
  }
}
qa.nextInstanceID = {};
const A3 = qa,
  N3 = "2.89.0";
let Xo = "";
typeof Deno < "u" ? Xo = "deno" : typeof document < "u" ? Xo = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Xo = "react-native" : Xo = "node";
const j3 = {
      "X-Client-Info": `supabase-js-${Xo}/${N3}`
  },
  O3 = {
      headers: j3
  },
  I3 = {
      schema: "public"
  },
  D3 = {
      autoRefreshToken: !0,
      persistSession: !0,
      detectSessionInUrl: !0,
      flowType: "implicit"
  },
  M3 = {};

function Ga(e) {
  "@babel/helpers - typeof";
  return Ga = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }, Ga(e)
}

function L3(e, t) {
  if (Ga(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
      var r = n.call(e, t || "default");
      if (Ga(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}

function $3(e) {
  var t = L3(e, "string");
  return Ga(t) == "symbol" ? t : t + ""
}

function F3(e, t, n) {
  return (t = $3(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
  }) : e[t] = n, e
}

function _w(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(s) {
          return Object.getOwnPropertyDescriptor(e, s).enumerable
      })), n.push.apply(n, r)
  }
  return n
}

function Pe(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? _w(Object(n), !0).forEach(function(r) {
          F3(e, r, n[r])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _w(Object(n)).forEach(function(r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
      })
  }
  return e
}
const U3 = e => e ? (...t) => e(...t) : (...t) => fetch(...t),
  V3 = () => Headers,
  B3 = (e, t, n) => {
      const r = U3(n),
          s = V3();
      return async (i, o) => {
          var a;
          const l = (a = await t()) !== null && a !== void 0 ? a : e;
          let c = new s(o == null ? void 0 : o.headers);
          return c.has("apikey") || c.set("apikey", e), c.has("Authorization") || c.set("Authorization", `Bearer ${l}`), r(i, Pe(Pe({}, o), {}, {
              headers: c
          }))
      }
  };

function z3(e) {
  return e.endsWith("/") ? e : e + "/"
}

function W3(e, t) {
  var n, r;
  const {
      db: s,
      auth: i,
      realtime: o,
      global: a
  } = e, {
      db: l,
      auth: c,
      realtime: u,
      global: d
  } = t, h = {
      db: Pe(Pe({}, l), s),
      auth: Pe(Pe({}, c), i),
      realtime: Pe(Pe({}, u), o),
      storage: {},
      global: Pe(Pe(Pe({}, d), a), {}, {
          headers: Pe(Pe({}, (n = d == null ? void 0 : d.headers) !== null && n !== void 0 ? n : {}), (r = a == null ? void 0 : a.headers) !== null && r !== void 0 ? r : {})
      }),
      accessToken: async () => ""
  };
  return e.accessToken ? h.accessToken = e.accessToken : delete h.accessToken, h
}

function H3(e) {
  const t = e == null ? void 0 : e.trim();
  if (!t) throw new Error("supabaseUrl is required.");
  if (!t.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  try {
      return new URL(z3(t))
  } catch {
      throw Error("Invalid supabaseUrl: Provided URL is malformed.")
  }
}
var K3 = class extends A3 {
      constructor(e) {
          super(e)
      }
  },
  q3 = class {
      constructor(e, t, n) {
          var r, s;
          this.supabaseUrl = e, this.supabaseKey = t;
          const i = H3(e);
          if (!t) throw new Error("supabaseKey is required.");
          this.realtimeUrl = new URL("realtime/v1", i), this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"), this.authUrl = new URL("auth/v1", i), this.storageUrl = new URL("storage/v1", i), this.functionsUrl = new URL("functions/v1", i);
          const o = `sb-${i.hostname.split(".")[0]}-auth-token`,
              a = {
                  db: I3,
                  realtime: M3,
                  auth: Pe(Pe({}, D3), {}, {
                      storageKey: o
                  }),
                  global: O3
              },
              l = W3(n ?? {}, a);
          if (this.storageKey = (r = l.auth.storageKey) !== null && r !== void 0 ? r : "", this.headers = (s = l.global.headers) !== null && s !== void 0 ? s : {}, l.accessToken) this.accessToken = l.accessToken, this.auth = new Proxy({}, {
              get: (u, d) => {
                  throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(d)} is not possible`)
              }
          });
          else {
              var c;
              this.auth = this._initSupabaseAuthClient((c = l.auth) !== null && c !== void 0 ? c : {}, this.headers, l.global.fetch)
          }
          this.fetch = B3(t, this._getAccessToken.bind(this), l.global.fetch), this.realtime = this._initRealtimeClient(Pe({
              headers: this.headers,
              accessToken: this._getAccessToken.bind(this)
          }, l.realtime)), this.accessToken && this.accessToken().then(u => this.realtime.setAuth(u)).catch(u => console.warn("Failed to set initial Realtime auth token:", u)), this.rest = new TF(new URL("rest/v1", i).href, {
              headers: this.headers,
              schema: l.db.schema,
              fetch: this.fetch
          }), this.storage = new _4(this.storageUrl.href, this.headers, this.fetch, n == null ? void 0 : n.storage), l.accessToken || this._listenForAuthEvents()
      }
      get functions() {
          return new bF(this.functionsUrl.href, {
              headers: this.headers,
              customFetch: this.fetch
          })
      }
      from(e) {
          return this.rest.from(e)
      }
      schema(e) {
          return this.rest.schema(e)
      }
      rpc(e, t = {}, n = {
          head: !1,
          get: !1,
          count: void 0
      }) {
          return this.rest.rpc(e, t, n)
      }
      channel(e, t = {
          config: {}
      }) {
          return this.realtime.channel(e, t)
      }
      getChannels() {
          return this.realtime.getChannels()
      }
      removeChannel(e) {
          return this.realtime.removeChannel(e)
      }
      removeAllChannels() {
          return this.realtime.removeAllChannels()
      }
      async _getAccessToken() {
          var e = this,
              t, n;
          if (e.accessToken) return await e.accessToken();
          const {
              data: r
          } = await e.auth.getSession();
          return (t = (n = r.session) === null || n === void 0 ? void 0 : n.access_token) !== null && t !== void 0 ? t : e.supabaseKey
      }
      _initSupabaseAuthClient({
          autoRefreshToken: e,
          persistSession: t,
          detectSessionInUrl: n,
          storage: r,
          userStorage: s,
          storageKey: i,
          flowType: o,
          lock: a,
          debug: l,
          throwOnError: c
      }, u, d) {
          const h = {
              Authorization: `Bearer ${this.supabaseKey}`,
              apikey: `${this.supabaseKey}`
          };
          return new K3({
              url: this.authUrl.href,
              headers: Pe(Pe({}, h), u),
              storageKey: i,
              autoRefreshToken: e,
              persistSession: t,
              detectSessionInUrl: n,
              storage: r,
              userStorage: s,
              flowType: o,
              lock: a,
              debug: l,
              throwOnError: c,
              fetch: d,
              hasCustomAuthorizationHeader: Object.keys(this.headers).some(f => f.toLowerCase() === "authorization")
          })
      }
      _initRealtimeClient(e) {
          return new zF(this.realtimeUrl.href, Pe(Pe({}, e), {}, {
              params: Pe(Pe({}, {
                  apikey: this.supabaseKey
              }), e == null ? void 0 : e.params)
          }))
      }
      _listenForAuthEvents() {
          return this.auth.onAuthStateChange((e, t) => {
              this._handleTokenChanged(e, "CLIENT", t == null ? void 0 : t.access_token)
          })
      }
      _handleTokenChanged(e, t, n) {
          (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== n ? (this.changedAccessToken = n, this.realtime.setAuth(n)) : e === "SIGNED_OUT" && (this.realtime.setAuth(), t == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0)
      }
  };
const G3 = (e, t, n) => new q3(e, t, n);

function Q3() {
  if (typeof window < "u" || typeof process > "u") return !1;
  const e = process.version;
  if (e == null) return !1;
  const t = e.match(/^v(\d+)\./);
  return t ? parseInt(t[1], 10) <= 18 : !1
}
Q3() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const Y3 = "https://ptneezuhaxlczkppnirj.supabase.co",
  J3 = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB0bmVlenVoYXhsY3prcHBuaXJqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcxMTExNzYsImV4cCI6MjA4MjY4NzE3Nn0.JX1jXvQQUNnaSbnm4G6T8f98bgKshy-YNyqlsBDFt3Q",
  yt = G3(Y3, J3, {
      auth: {
          storage: localStorage,
          persistSession: !0,
          autoRefreshToken: !0
      }
  });

function X3() {
  return Fu({
      queryKey: ["accommodations"],
      queryFn: async () => {
          const {
              data: e,
              error: t
          } = await yt.from("accommodations").select("*").order("sort_order", {
              ascending: !0
          });
          if (t) throw t;
          return e
      }
  })
}

function Z3() {
  const {
      data: e,
      isLoading: t
  } = X3();
  return t ? p.jsx("section", {
      className: "section-padding bg-ivory",
      children: p.jsx("div", {
          className: "max-w-5xl mx-auto text-center",
          children: p.jsx("p", {
              className: "text-muted-foreground font-body",
              children: "Cargando alojamientos..."
          })
      })
  }) : !e || e.length === 0 ? null : p.jsx("section", {
      className: "section-padding bg-ivory",
      children: p.jsxs("div", {
          className: "max-w-5xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-16",
              children: [p.jsx(PA, {
                  className: "w-8 h-8 mx-auto mb-4 text-primary"
              }), p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-2",
                  children: "Alojamiento"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body tracking-wide",
                  children: "Recomendaciones para tu estancia"
              })]
          }), p.jsx("div", {
              className: "grid md:grid-cols-2 gap-6",
              children: e.map((n, r) => p.jsxs(Y.div, {
                  initial: {
                      opacity: 0,
                      y: 30
                  },
                  whileInView: {
                      opacity: 1,
                      y: 0
                  },
                  viewport: {
                      once: !0
                  },
                  transition: {
                      duration: .6,
                      delay: r * .1
                  },
                  className: "card-elegant",
                  children: [p.jsx("h3", {
                      className: "font-display text-xl text-foreground mb-2",
                      children: n.name
                  }), n.description && p.jsx("p", {
                      className: "text-muted-foreground font-body text-sm mb-4",
                      children: n.description
                  }), p.jsxs("div", {
                      className: "flex flex-wrap gap-3 mb-4",
                      children: [n.price_range && p.jsx("span", {
                          className: "text-xs px-3 py-1 bg-secondary text-foreground rounded-full font-body",
                          children: n.price_range
                      }), n.distance && p.jsxs("span", {
                          className: "text-xs px-3 py-1 bg-secondary text-foreground rounded-full flex items-center gap-1 font-body",
                          children: [p.jsx(Hc, {
                              className: "w-3 h-3"
                          }), n.distance]
                      })]
                  }), n.link && p.jsx(Nn, {
                      variant: "outline",
                      size: "sm",
                      className: "gap-2 border-primary/40 text-foreground hover:bg-primary hover:text-primary-foreground",
                      asChild: !0,
                      children: p.jsxs("a", {
                          href: n.link,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          children: [p.jsx($A, {
                              className: "w-4 h-4"
                          }), "Ver detalles"]
                      })
                  })]
              }, n.id))
          })]
      })
  })
}
var qu = "Collapsible",
  [e5, KE] = Kt(qu),
  [t5, _g] = e5(qu),
  qE = g.forwardRef((e, t) => {
      const {
          __scopeCollapsible: n,
          open: r,
          defaultOpen: s,
          disabled: i,
          onOpenChange: o,
          ...a
      } = e, [l, c] = ss({
          prop: r,
          defaultProp: s ?? !1,
          onChange: o,
          caller: qu
      });
      return p.jsx(t5, {
          scope: n,
          disabled: i,
          contentId: Wi(),
          open: l,
          onOpenToggle: g.useCallback(() => c(u => !u), [c]),
          children: p.jsx(ae.div, {
              "data-state": Cg(l),
              "data-disabled": i ? "" : void 0,
              ...a,
              ref: t
          })
      })
  });
qE.displayName = qu;
var GE = "CollapsibleTrigger",
  QE = g.forwardRef((e, t) => {
      const {
          __scopeCollapsible: n,
          ...r
      } = e, s = _g(GE, n);
      return p.jsx(ae.button, {
          type: "button",
          "aria-controls": s.contentId,
          "aria-expanded": s.open || !1,
          "data-state": Cg(s.open),
          "data-disabled": s.disabled ? "" : void 0,
          disabled: s.disabled,
          ...r,
          ref: t,
          onClick: ne(e.onClick, s.onOpenToggle)
      })
  });
QE.displayName = GE;
var Eg = "CollapsibleContent",
  YE = g.forwardRef((e, t) => {
      const {
          forceMount: n,
          ...r
      } = e, s = _g(Eg, e.__scopeCollapsible);
      return p.jsx(tr, {
          present: n || s.open,
          children: ({
              present: i
          }) => p.jsx(n5, {
              ...r,
              ref: t,
              present: i
          })
      })
  });
YE.displayName = Eg;
var n5 = g.forwardRef((e, t) => {
  const {
      __scopeCollapsible: n,
      present: r,
      children: s,
      ...i
  } = e, o = _g(Eg, n), [a, l] = g.useState(r), c = g.useRef(null), u = we(t, c), d = g.useRef(0), h = d.current, f = g.useRef(0), x = f.current, m = o.open || a, b = g.useRef(m), v = g.useRef(void 0);
  return g.useEffect(() => {
      const y = requestAnimationFrame(() => b.current = !1);
      return () => cancelAnimationFrame(y)
  }, []), jn(() => {
      const y = c.current;
      if (y) {
          v.current = v.current || {
              transitionDuration: y.style.transitionDuration,
              animationName: y.style.animationName
          }, y.style.transitionDuration = "0s", y.style.animationName = "none";
          const w = y.getBoundingClientRect();
          d.current = w.height, f.current = w.width, b.current || (y.style.transitionDuration = v.current.transitionDuration, y.style.animationName = v.current.animationName), l(r)
      }
  }, [o.open, r]), p.jsx(ae.div, {
      "data-state": Cg(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !m,
      ...i,
      ref: u,
      style: {
          "--radix-collapsible-content-height": h ? `${h}px` : void 0,
          "--radix-collapsible-content-width": x ? `${x}px` : void 0,
          ...e.style
      },
      children: m && s
  })
});

function Cg(e) {
  return e ? "open" : "closed"
}
var r5 = qE,
  s5 = QE,
  i5 = YE,
  o5 = g.createContext(void 0);

function Tg(e) {
  const t = g.useContext(o5);
  return e || t || "ltr"
}
var gn = "Accordion",
  a5 = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"],
  [kg, l5, c5] = gm(gn),
  [Gu, tB] = Kt(gn, [c5, KE]),
  Rg = KE(),
  JE = j.forwardRef((e, t) => {
      const {
          type: n,
          ...r
      } = e, s = r, i = r;
      return p.jsx(kg.Provider, {
          scope: e.__scopeAccordion,
          children: n === "multiple" ? p.jsx(f5, {
              ...i,
              ref: t
          }) : p.jsx(h5, {
              ...s,
              ref: t
          })
      })
  });
JE.displayName = gn;
var [XE, u5] = Gu(gn), [ZE, d5] = Gu(gn, {
  collapsible: !1
}), h5 = j.forwardRef((e, t) => {
  const {
      value: n,
      defaultValue: r,
      onValueChange: s = () => {},
      collapsible: i = !1,
      ...o
  } = e, [a, l] = ss({
      prop: n,
      defaultProp: r ?? "",
      onChange: s,
      caller: gn
  });
  return p.jsx(XE, {
      scope: e.__scopeAccordion,
      value: j.useMemo(() => a ? [a] : [], [a]),
      onItemOpen: l,
      onItemClose: j.useCallback(() => i && l(""), [i, l]),
      children: p.jsx(ZE, {
          scope: e.__scopeAccordion,
          collapsible: i,
          children: p.jsx(eC, {
              ...o,
              ref: t
          })
      })
  })
}), f5 = j.forwardRef((e, t) => {
  const {
      value: n,
      defaultValue: r,
      onValueChange: s = () => {},
      ...i
  } = e, [o, a] = ss({
      prop: n,
      defaultProp: r ?? [],
      onChange: s,
      caller: gn
  }), l = j.useCallback(u => a((d = []) => [...d, u]), [a]), c = j.useCallback(u => a((d = []) => d.filter(h => h !== u)), [a]);
  return p.jsx(XE, {
      scope: e.__scopeAccordion,
      value: o,
      onItemOpen: l,
      onItemClose: c,
      children: p.jsx(ZE, {
          scope: e.__scopeAccordion,
          collapsible: !0,
          children: p.jsx(eC, {
              ...i,
              ref: t
          })
      })
  })
}), [p5, Qu] = Gu(gn), eC = j.forwardRef((e, t) => {
  const {
      __scopeAccordion: n,
      disabled: r,
      dir: s,
      orientation: i = "vertical",
      ...o
  } = e, a = j.useRef(null), l = we(a, t), c = l5(n), d = Tg(s) === "ltr", h = ne(e.onKeyDown, f => {
      var k;
      if (!a5.includes(f.key)) return;
      const x = f.target,
          m = c().filter(P => {
              var A;
              return !((A = P.ref.current) != null && A.disabled)
          }),
          b = m.findIndex(P => P.ref.current === x),
          v = m.length;
      if (b === -1) return;
      f.preventDefault();
      let y = b;
      const w = 0,
          S = v - 1,
          _ = () => {
              y = b + 1, y > S && (y = w)
          },
          E = () => {
              y = b - 1, y < w && (y = S)
          };
      switch (f.key) {
          case "Home":
              y = w;
              break;
          case "End":
              y = S;
              break;
          case "ArrowRight":
              i === "horizontal" && (d ? _() : E());
              break;
          case "ArrowDown":
              i === "vertical" && _();
              break;
          case "ArrowLeft":
              i === "horizontal" && (d ? E() : _());
              break;
          case "ArrowUp":
              i === "vertical" && E();
              break
      }
      const T = y % v;
      (k = m[T].ref.current) == null || k.focus()
  });
  return p.jsx(p5, {
      scope: n,
      disabled: r,
      direction: s,
      orientation: i,
      children: p.jsx(kg.Slot, {
          scope: n,
          children: p.jsx(ae.div, {
              ...o,
              "data-orientation": i,
              ref: l,
              onKeyDown: r ? void 0 : h
          })
      })
  })
}), uu = "AccordionItem", [m5, Pg] = Gu(uu), tC = j.forwardRef((e, t) => {
  const {
      __scopeAccordion: n,
      value: r,
      ...s
  } = e, i = Qu(uu, n), o = u5(uu, n), a = Rg(n), l = Wi(), c = r && o.value.includes(r) || !1, u = i.disabled || e.disabled;
  return p.jsx(m5, {
      scope: n,
      open: c,
      disabled: u,
      triggerId: l,
      children: p.jsx(r5, {
          "data-orientation": i.orientation,
          "data-state": aC(c),
          ...a,
          ...s,
          ref: t,
          disabled: u,
          open: c,
          onOpenChange: d => {
              d ? o.onItemOpen(r) : o.onItemClose(r)
          }
      })
  })
});
tC.displayName = uu;
var nC = "AccordionHeader",
  rC = j.forwardRef((e, t) => {
      const {
          __scopeAccordion: n,
          ...r
      } = e, s = Qu(gn, n), i = Pg(nC, n);
      return p.jsx(ae.h3, {
          "data-orientation": s.orientation,
          "data-state": aC(i.open),
          "data-disabled": i.disabled ? "" : void 0,
          ...r,
          ref: t
      })
  });
rC.displayName = nC;
var gp = "AccordionTrigger",
  sC = j.forwardRef((e, t) => {
      const {
          __scopeAccordion: n,
          ...r
      } = e, s = Qu(gn, n), i = Pg(gp, n), o = d5(gp, n), a = Rg(n);
      return p.jsx(kg.ItemSlot, {
          scope: n,
          children: p.jsx(s5, {
              "aria-disabled": i.open && !o.collapsible || void 0,
              "data-orientation": s.orientation,
              id: i.triggerId,
              ...a,
              ...r,
              ref: t
          })
      })
  });
sC.displayName = gp;
var iC = "AccordionContent",
  oC = j.forwardRef((e, t) => {
      const {
          __scopeAccordion: n,
          ...r
      } = e, s = Qu(gn, n), i = Pg(iC, n), o = Rg(n);
      return p.jsx(i5, {
          role: "region",
          "aria-labelledby": i.triggerId,
          "data-orientation": s.orientation,
          ...o,
          ...r,
          ref: t,
          style: {
              "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
              "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
              ...e.style
          }
      })
  });
oC.displayName = iC;

function aC(e) {
  return e ? "open" : "closed"
}
var g5 = JE,
  y5 = tC,
  v5 = rC,
  lC = sC,
  cC = oC;
const w5 = g5,
  uC = g.forwardRef(({
      className: e,
      ...t
  }, n) => p.jsx(y5, {
      ref: n,
      className: ee("border-b", e),
      ...t
  }));
uC.displayName = "AccordionItem";
const dC = g.forwardRef(({
  className: e,
  children: t,
  ...n
}, r) => p.jsx(v5, {
  className: "flex",
  children: p.jsxs(lC, {
      ref: r,
      className: ee("flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", e),
      ...n,
      children: [t, p.jsx(bm, {
          className: "h-4 w-4 shrink-0 transition-transform duration-200"
      })]
  })
}));
dC.displayName = lC.displayName;
const hC = g.forwardRef(({
  className: e,
  children: t,
  ...n
}, r) => p.jsx(cC, {
  ref: r,
  className: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
  ...n,
  children: p.jsx("div", {
      className: ee("pb-4 pt-0", e),
      children: t
  })
}));
hC.displayName = cC.displayName;

function x5() {
  return Fu({
      queryKey: ["faqs"],
      queryFn: async () => {
          const {
              data: e,
              error: t
          } = await yt.from("faqs").select("*").order("sort_order", {
              ascending: !0
          });
          if (t) throw t;
          return e
      }
  })
}

function b5() {
  const {
      data: e,
      isLoading: t
  } = x5();
  return t || !e || e.length === 0 ? null : p.jsx("section", {
      className: "section-padding bg-ivory",
      children: p.jsxs("div", {
          className: "max-w-3xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-12",
              children: [p.jsx(IA, {
                  className: "w-8 h-8 mx-auto mb-4 text-primary"
              }), p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground",
                  children: "Preguntas frecuentes"
              })]
          }), p.jsx(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .2
              },
              children: p.jsx(w5, {
                  type: "single",
                  collapsible: !0,
                  className: "space-y-4",
                  children: e.map(n => p.jsxs(uC, {
                      value: n.id,
                      className: "bg-card/90 backdrop-blur-sm border border-border px-6 rounded-sm",
                      children: [p.jsx(dC, {
                          className: "text-left font-display text-lg text-foreground hover:no-underline",
                          children: n.question
                      }), p.jsx(hC, {
                          className: "text-muted-foreground font-body",
                          children: n.answer
                      })]
                  }, n.id))
              })
          })]
      })
  })
}
const S5 = "/assets/confetti-CrGrT4ka.gif";

function _5({
  enabled: e,
  iban: t = "https://mesaderegalos.liverpool.com.mx/milistaderegalos/51705969"
}) {
  const [n, r] = g.useState(!1), [s, i] = g.useState(!1), [o, a] = g.useState(!1), l = () => {
      n || (a(!0), setTimeout(() => a(!1), 2e3)), r(!n)
  };
  return e === !1 ? null : p.jsxs("section", {
      className: "section-padding bg-ivory relative",
      children: [p.jsx(Qf, {
          children: o && p.jsx(Y.div, {
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: 1
              },
              exit: {
                  opacity: 0
              },
              className: "absolute inset-x-0 top-4 pointer-events-none z-50 flex justify-center",
              children: p.jsx("img", {
                  src: S5,
                  alt: "Confeti celebracin",
                  className: "w-[400px] h-[400px] object-contain"
              })
          })
      }), p.jsxs("div", {
          className: "max-w-2xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-12",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-6",
                  children: "Regalos"
              }), p.jsxs("p", {
                  className: "text-muted-foreground font-body leading-relaxed max-w-lg mx-auto",
              })]
          }), p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .2
              },
              className: "card-elegant overflow-hidden !p-0",
              children: [p.jsxs("button", {
                  onClick: l,
                  className: "w-full px-6 py-5 flex items-center justify-between text-left hover:bg-secondary/30 transition-colors",
                  children: [p.jsx("span", {
                      className: "font-display text-lg text-foreground",
                      children: "Mesa de Regalos"
                  }), p.jsx(Y.div, {
                      animate: {
                          rotate: n ? 180 : 0
                      },
                      transition: {
                          duration: .3
                      },
                      children: p.jsx(bm, {
                          className: "w-5 h-5 text-muted-foreground"
                      })
                  })]
              }), p.jsx(Qf, {
                  children: n && p.jsx(Y.div, {
                      initial: {
                          height: 0,
                          opacity: 0
                      },
                      animate: {
                          height: "auto",
                          opacity: 1
                      },
                      exit: {
                          height: 0,
                          opacity: 0
                      },
                      transition: {
                          duration: .3,
                          ease: "easeInOut"
                      },
                      className: "overflow-hidden",
                      children: p.jsxs("div", {
                          className: "px-6 pb-6 pt-2 border-t border-border",
                          children: [p.jsxs("p", {
                              className: "text-muted-foreground font-body text-sm leading-relaxed mb-6",
                              children: ["Su presencia es nuestro mejor regalo, pero si deseas contribuir a nuestro futuro, agradecemos un aporte para nuestro hogar"]
                          }), p.jsx("div", {
                              className: "text-center",
                              children: s ? p.jsxs(Y.div, {
                                  initial: {
                                      opacity: 0,
                                      y: 5
                                  },
                                  animate: {
                                      opacity: 1,
                                      y: 0
                                  },
                                  transition: {
                                      duration: .3
                                  },
                                  className: "space-y-2",
                                  children: [p.jsx("p", {
                                      className: "text-xs text-muted-foreground font-body uppercase tracking-wider",
                                      children: "Link a Mesa Liverpool"
                                  }), p.jsx("a", {
                                      href: t,
                                      target: "_blank",
                                      rel: "noopener noreferrer",
                                      className: "font-mono text-sm text-foreground/80 tracking-wide select-all hover:text-foreground underline underline-offset-2 transition-colors",
                                      children: t
                                  })]
                              }) : p.jsx("button", {
                                  onClick: () => i(!0),
                                  className: "text-sm text-muted-foreground hover:text-foreground underline underline-offset-4 decoration-border hover:decoration-foreground/60 transition-colors font-body",
                                  children: "Mostrar Mesa Liverpool"
                              })
                          })]
                      })
                  })
              })]
          })]
      })]
  })
}
function DressCode() {
  const colors = [
      "#B8869B",
      "#D4A5B8",
      "#C8A8D9",
      "#F5C2A3",
      "#F4A460",
      "#FF7F50",
      "#87CEEB",
      "#9CAF88"
  ];
  return p.jsx("section", {
      className: "section-padding bg-ivory",
      children: p.jsxs("div", {
          className: "max-w-4xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-8",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-4",
                  children: "Dress Code"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body text-lg mb-6",
                  children: "Formal de etiqueta"
              }), p.jsx("a", {
                  href: "https://mx.pinterest.com/pyga14/dress-code/?invite_code=4d21cb7b929440dc96eac49755bac8dc&sender=621426585991646533",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: "inline-block px-6 py-3 bg-primary text-primary-foreground rounded-lg font-body font-medium hover:bg-primary/90 transition-colors shadow-soft hover:shadow-elegant",
                  children: "Insprate con estas ideas!"
              })]
          }), p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .2
              },
              className: "grid md:grid-cols-2 gap-8 mb-8",
              children: [p.jsxs("div", {
                  className: "text-center",
                  children: [p.jsx(Y.div, {
                      initial: {
                          opacity: 0,
                          y: 20
                      },
                      whileInView: {
                          opacity: 1,
                          y: 0
                      },
                      viewport: {
                          once: !0
                      },
                      transition: {
                          duration: .6,
                          delay: .3
                      },
                      className: "mb-6",
                      children: p.jsxs("div", {
                          className: "text-center",
                          children: [p.jsx("p", {
                              className: "font-body text-muted-foreground mb-4",
                              children: "COLORES DE PREFERENCIA"
                          }), p.jsx("div", {
                              className: "grid grid-cols-4 gap-4 max-w-md mx-auto",
                              children: colors.map((e, t) => p.jsx("div", {
                                  key: t,
                                  className: "aspect-square rounded-full shadow-soft",
                                  style: {
                                      backgroundColor: e
                                  }
                              }, t))
                          })]
                      })
                  }), p.jsx("p", {
                      className: "font-body text-foreground font-medium mb-4",
                      children: "MUJERES"
                  }), p.jsx("img", {
                      src: "/assets/vestimenta/dress-negro.svg",
                      alt: "Vestido formal para mujeres",
                      className: "w-full max-w-[200px] mx-auto object-contain"
                  })]
              }), p.jsxs("div", {
                  className: "text-center",
                  children: [p.jsx("p", {
                      className: "font-body text-foreground font-medium mb-4",
                      children: "HOMBRES"
                  }), p.jsx("img", {
                      src: "/assets/vestimenta/suit-gris.svg",
                      alt: "Traje formal para hombres",
                      className: "w-full max-w-[200px] mx-auto object-contain"
                  })]
              })]
          })]
      })
  })
}
function Gallery() {
  const [selectedImage, setSelectedImage] = g.useState(null);
  const images = [
      "/assets/imagenes/20251004-IMG_4457_Original.JPG",
      "/assets/imagenes/20251004-IMG_4550_Original.JPG",
      "/assets/imagenes/20251004-IMG_4561_Original.JPG",
      "/assets/imagenes/20251004-IMG_4601_Original.JPG",
      "/assets/imagenes/20251004-IMG_4605_Original.JPG",
      "/assets/imagenes/IMG_1186_Original.JPG",
      "/assets/imagenes/IMG_1187_Original.JPG",
      "/assets/imagenes/IMG_1192_Original.JPG",
      "/assets/imagenes/IMG_1197_Original.JPG",
      "/assets/imagenes/IMG_1203_Original.JPG"
  ];
  g.useEffect(() => {
      const handleEscape = e => {
          e.key === "Escape" && setSelectedImage(null)
      };
      selectedImage && document.addEventListener("keydown", handleEscape);
      return () => {
          document.removeEventListener("keydown", handleEscape)
      }
  }, [selectedImage]);
  return p.jsxs("section", {
      className: "section-padding bg-ivory",
      children: [p.jsxs("div", {
          className: "max-w-7xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-12",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-6",
                  children: "Galera"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body leading-relaxed max-w-lg mx-auto",
                  children: "Momentos especiales que queremos compartir contigo"
              })]
          }), p.jsx(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .2
              },
              className: "grid grid-cols-2 md:grid-cols-3 gap-4",
              children: images.map((e, t) => p.jsx(Y.div, {
                  initial: {
                      opacity: 0,
                      scale: .95
                  },
                  whileInView: {
                      opacity: 1,
                      scale: 1
                  },
                  viewport: {
                      once: !0
                  },
                  transition: {
                      duration: .4,
                      delay: t * .1
                  },
                  className: "overflow-hidden rounded-lg shadow-soft hover:shadow-elegant transition-all duration-300 group cursor-pointer",
                  onClick: () => setSelectedImage(e),
                  children: p.jsx("img", {
                      src: e,
                      alt: `Imagen ${t + 1} de la galera`,
                      className: "w-full h-full object-cover aspect-square group-hover:scale-110 transition-transform duration-300"
                  })
              }, t))
          })]
      }), selectedImage && p.jsx(Qf, {
          children: p.jsx(Y.div, {
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: 1
              },
              exit: {
                  opacity: 0
              },
              className: "fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm",
              onClick: () => setSelectedImage(null),
              children: p.jsxs("div", {
                  className: "relative max-w-7xl max-h-[90vh] w-full h-full flex items-center justify-center",
                  onClick: n => n.stopPropagation(),
                  children: [p.jsx("button", {
                      onClick: () => setSelectedImage(null),
                      className: "absolute top-4 right-4 z-10 w-10 h-10 flex items-center justify-center rounded-full bg-white/10 hover:bg-white/20 text-white transition-colors",
                      "aria-label": "Cerrar",
                      children: p.jsx("svg", {
                          className: "w-6 h-6",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24",
                          children: p.jsx("path", {
                              strokeLinecap: "round",
                              strokeLinejoin: "round",
                              strokeWidth: 2,
                              d: "M6 18L18 6M6 6l12 12"
                          })
                      })
                  }), p.jsx(Y.div, {
                      initial: {
                          scale: .9,
                          opacity: 0
                      },
                      animate: {
                          scale: 1,
                          opacity: 1
                      },
                      exit: {
                          scale: .9,
                          opacity: 0
                      },
                      transition: {
                          duration: .3
                      },
                      className: "max-w-full max-h-full",
                      children: p.jsx("img", {
                          src: selectedImage,
                          alt: "Imagen ampliada",
                          className: "max-w-full max-h-full object-contain rounded-lg shadow-xl"
                      })
                  })]
              })
          })
      })]
  })
}
const Er = g.forwardRef(({
  className: e,
  type: t,
  ...n
}, r) => p.jsx("input", {
  type: t,
  className: ee("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e),
  ref: r,
  ...n
}));
Er.displayName = "Input";
const fC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("textarea", {
  className: ee("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", e),
  ref: n,
  ...t
}));
fC.displayName = "Textarea";
var E5 = "Label",
  pC = g.forwardRef((e, t) => p.jsx(ae.label, {
      ...e,
      ref: t,
      onMouseDown: n => {
          var s;
          n.target.closest("button, input, select, textarea") || ((s = e.onMouseDown) == null || s.call(e, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault())
      }
  }));
pC.displayName = E5;
var mC = pC;
const C5 = ju("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"),
  ht = g.forwardRef(({
      className: e,
      ...t
  }, n) => p.jsx(mC, {
      ref: n,
      className: ee(C5(), e),
      ...t
  }));
ht.displayName = mC.displayName;
var ch = "rovingFocusGroup.onEntryFocus",
  T5 = {
      bubbles: !1,
      cancelable: !0
  },
  pl = "RovingFocusGroup",
  [yp, gC, k5] = gm(pl),
  [R5, yC] = Kt(pl, [k5]),
  [P5, A5] = R5(pl),
  vC = g.forwardRef((e, t) => p.jsx(yp.Provider, {
      scope: e.__scopeRovingFocusGroup,
      children: p.jsx(yp.Slot, {
          scope: e.__scopeRovingFocusGroup,
          children: p.jsx(N5, {
              ...e,
              ref: t
          })
      })
  }));
vC.displayName = pl;
var N5 = g.forwardRef((e, t) => {
      const {
          __scopeRovingFocusGroup: n,
          orientation: r,
          loop: s = !1,
          dir: i,
          currentTabStopId: o,
          defaultCurrentTabStopId: a,
          onCurrentTabStopIdChange: l,
          onEntryFocus: c,
          preventScrollOnEntryFocus: u = !1,
          ...d
      } = e, h = g.useRef(null), f = we(t, h), x = Tg(i), [m, b] = ss({
          prop: o,
          defaultProp: a ?? null,
          onChange: l,
          caller: pl
      }), [v, y] = g.useState(!1), w = fn(c), S = gC(n), _ = g.useRef(!1), [E, T] = g.useState(0);
      return g.useEffect(() => {
          const k = h.current;
          if (k) return k.addEventListener(ch, w), () => k.removeEventListener(ch, w)
      }, [w]), p.jsx(P5, {
          scope: n,
          orientation: r,
          dir: x,
          loop: s,
          currentTabStopId: m,
          onItemFocus: g.useCallback(k => b(k), [b]),
          onItemShiftTab: g.useCallback(() => y(!0), []),
          onFocusableItemAdd: g.useCallback(() => T(k => k + 1), []),
          onFocusableItemRemove: g.useCallback(() => T(k => k - 1), []),
          children: p.jsx(ae.div, {
              tabIndex: v || E === 0 ? -1 : 0,
              "data-orientation": r,
              ...d,
              ref: f,
              style: {
                  outline: "none",
                  ...e.style
              },
              onMouseDown: ne(e.onMouseDown, () => {
                  _.current = !0
              }),
              onFocus: ne(e.onFocus, k => {
                  const P = !_.current;
                  if (k.target === k.currentTarget && P && !v) {
                      const A = new CustomEvent(ch, T5);
                      if (k.currentTarget.dispatchEvent(A), !A.defaultPrevented) {
                          const $ = S().filter(B => B.focusable),
                              I = $.find(B => B.active),
                              G = $.find(B => B.id === m),
                              X = [I, G, ...$].filter(Boolean).map(B => B.ref.current);
                          bC(X, u)
                      }
                  }
                  _.current = !1
              }),
              onBlur: ne(e.onBlur, () => y(!1))
          })
      })
  }),
  wC = "RovingFocusGroupItem",
  xC = g.forwardRef((e, t) => {
      const {
          __scopeRovingFocusGroup: n,
          focusable: r = !0,
          active: s = !1,
          tabStopId: i,
          children: o,
          ...a
      } = e, l = Wi(), c = i || l, u = A5(wC, n), d = u.currentTabStopId === c, h = gC(n), {
          onFocusableItemAdd: f,
          onFocusableItemRemove: x,
          currentTabStopId: m
      } = u;
      return g.useEffect(() => {
          if (r) return f(), () => x()
      }, [r, f, x]), p.jsx(yp.ItemSlot, {
          scope: n,
          id: c,
          focusable: r,
          active: s,
          children: p.jsx(ae.span, {
              tabIndex: d ? 0 : -1,
              "data-orientation": u.orientation,
              ...a,
              ref: t,
              onMouseDown: ne(e.onMouseDown, b => {
                  r ? u.onItemFocus(c) : b.preventDefault()
              }),
              onFocus: ne(e.onFocus, () => u.onItemFocus(c)),
              onKeyDown: ne(e.onKeyDown, b => {
                  if (b.key === "Tab" && b.shiftKey) {
                      u.onItemShiftTab();
                      return
                  }
                  if (b.target !== b.currentTarget) return;
                  const v = I5(b, u.orientation, u.dir);
                  if (v !== void 0) {
                      if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                      b.preventDefault();
                      let w = h().filter(S => S.focusable).map(S => S.ref.current);
                      if (v === "last") w.reverse();
                      else if (v === "prev" || v === "next") {
                          v === "prev" && w.reverse();
                          const S = w.indexOf(b.currentTarget);
                          w = u.loop ? D5(w, S + 1) : w.slice(S + 1)
                      }
                      setTimeout(() => bC(w))
                  }
              }),
              children: typeof o == "function" ? o({
                  isCurrentTabStop: d,
                  hasTabStop: m != null
              }) : o
          })
      })
  });
xC.displayName = wC;
var j5 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};

function O5(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e
}

function I5(e, t, n) {
  const r = O5(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))) return j5[r]
}

function bC(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
      if (r === n || (r.focus({
              preventScroll: t
          }), document.activeElement !== n)) return
}

function D5(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
var M5 = vC,
  L5 = xC;

function SC(e) {
  const t = g.useRef({
      value: e,
      previous: e
  });
  return g.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e])
}
var Ag = "Radio",
  [$5, _C] = Kt(Ag),
  [F5, U5] = $5(Ag),
  EC = g.forwardRef((e, t) => {
      const {
          __scopeRadio: n,
          name: r,
          checked: s = !1,
          required: i,
          disabled: o,
          value: a = "on",
          onCheck: l,
          form: c,
          ...u
      } = e, [d, h] = g.useState(null), f = we(t, b => h(b)), x = g.useRef(!1), m = d ? c || !!d.closest("form") : !0;
      return p.jsxs(F5, {
          scope: n,
          checked: s,
          disabled: o,
          children: [p.jsx(ae.button, {
              type: "button",
              role: "radio",
              "aria-checked": s,
              "data-state": RC(s),
              "data-disabled": o ? "" : void 0,
              disabled: o,
              value: a,
              ...u,
              ref: f,
              onClick: ne(e.onClick, b => {
                  s || l == null || l(), m && (x.current = b.isPropagationStopped(), x.current || b.stopPropagation())
              })
          }), m && p.jsx(kC, {
              control: d,
              bubbles: !x.current,
              name: r,
              value: a,
              checked: s,
              required: i,
              disabled: o,
              form: c,
              style: {
                  transform: "translateX(-100%)"
              }
          })]
      })
  });
EC.displayName = Ag;
var CC = "RadioIndicator",
  TC = g.forwardRef((e, t) => {
      const {
          __scopeRadio: n,
          forceMount: r,
          ...s
      } = e, i = U5(CC, n);
      return p.jsx(tr, {
          present: r || i.checked,
          children: p.jsx(ae.span, {
              "data-state": RC(i.checked),
              "data-disabled": i.disabled ? "" : void 0,
              ...s,
              ref: t
          })
      })
  });
TC.displayName = CC;
var V5 = "RadioBubbleInput",
  kC = g.forwardRef(({
      __scopeRadio: e,
      control: t,
      checked: n,
      bubbles: r = !0,
      ...s
  }, i) => {
      const o = g.useRef(null),
          a = we(o, i),
          l = SC(n),
          c = Am(t);
      return g.useEffect(() => {
          const u = o.current;
          if (!u) return;
          const d = window.HTMLInputElement.prototype,
              f = Object.getOwnPropertyDescriptor(d, "checked").set;
          if (l !== n && f) {
              const x = new Event("click", {
                  bubbles: r
              });
              f.call(u, n), u.dispatchEvent(x)
          }
      }, [l, n, r]), p.jsx(ae.input, {
          type: "radio",
          "aria-hidden": !0,
          defaultChecked: n,
          ...s,
          tabIndex: -1,
          ref: a,
          style: {
              ...s.style,
              ...c,
              position: "absolute",
              pointerEvents: "none",
              opacity: 0,
              margin: 0
          }
      })
  });
kC.displayName = V5;

function RC(e) {
  return e ? "checked" : "unchecked"
}
var B5 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"],
  Yu = "RadioGroup",
  [z5, nB] = Kt(Yu, [yC, _C]),
  PC = yC(),
  AC = _C(),
  [W5, H5] = z5(Yu),
  NC = g.forwardRef((e, t) => {
      const {
          __scopeRadioGroup: n,
          name: r,
          defaultValue: s,
          value: i,
          required: o = !1,
          disabled: a = !1,
          orientation: l,
          dir: c,
          loop: u = !0,
          onValueChange: d,
          ...h
      } = e, f = PC(n), x = Tg(c), [m, b] = ss({
          prop: i,
          defaultProp: s ?? null,
          onChange: d,
          caller: Yu
      });
      return p.jsx(W5, {
          scope: n,
          name: r,
          required: o,
          disabled: a,
          value: m,
          onValueChange: b,
          children: p.jsx(M5, {
              asChild: !0,
              ...f,
              orientation: l,
              dir: x,
              loop: u,
              children: p.jsx(ae.div, {
                  role: "radiogroup",
                  "aria-required": o,
                  "aria-orientation": l,
                  "data-disabled": a ? "" : void 0,
                  dir: x,
                  ...h,
                  ref: t
              })
          })
      })
  });
NC.displayName = Yu;
var jC = "RadioGroupItem",
  OC = g.forwardRef((e, t) => {
      const {
          __scopeRadioGroup: n,
          disabled: r,
          ...s
      } = e, i = H5(jC, n), o = i.disabled || r, a = PC(n), l = AC(n), c = g.useRef(null), u = we(t, c), d = i.value === s.value, h = g.useRef(!1);
      return g.useEffect(() => {
          const f = m => {
                  B5.includes(m.key) && (h.current = !0)
              },
              x = () => h.current = !1;
          return document.addEventListener("keydown", f), document.addEventListener("keyup", x), () => {
              document.removeEventListener("keydown", f), document.removeEventListener("keyup", x)
          }
      }, []), p.jsx(L5, {
          asChild: !0,
          ...a,
          focusable: !o,
          active: d,
          children: p.jsx(EC, {
              disabled: o,
              required: i.required,
              checked: d,
              ...l,
              ...s,
              name: i.name,
              ref: u,
              onCheck: () => i.onValueChange(s.value),
              onKeyDown: ne(f => {
                  f.key === "Enter" && f.preventDefault()
              }),
              onFocus: ne(s.onFocus, () => {
                  var f;
                  h.current && ((f = c.current) == null || f.click())
              })
          })
      })
  });
OC.displayName = jC;
var K5 = "RadioGroupIndicator",
  IC = g.forwardRef((e, t) => {
      const {
          __scopeRadioGroup: n,
          ...r
      } = e, s = AC(n);
      return p.jsx(TC, {
          ...s,
          ...r,
          ref: t
      })
  });
IC.displayName = K5;
var DC = NC,
  MC = OC,
  q5 = IC;
const LC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(DC, {
  className: ee("grid gap-2", e),
  ...t,
  ref: n
}));
LC.displayName = DC.displayName;
const vp = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(MC, {
  ref: n,
  className: ee("aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", e),
  ...t,
  children: p.jsx(q5, {
      className: "flex items-center justify-center",
      children: p.jsx(MA, {
          className: "h-2.5 w-2.5 fill-current text-current"
      })
  })
}));
vp.displayName = MC.displayName;
var Ju = "Checkbox",
  [G5, rB] = Kt(Ju),
  [Q5, Ng] = G5(Ju);

function Y5(e) {
  const {
      __scopeCheckbox: t,
      checked: n,
      children: r,
      defaultChecked: s,
      disabled: i,
      form: o,
      name: a,
      onCheckedChange: l,
      required: c,
      value: u = "on",
      internal_do_not_use_render: d
  } = e, [h, f] = ss({
      prop: n,
      defaultProp: s ?? !1,
      onChange: l,
      caller: Ju
  }), [x, m] = g.useState(null), [b, v] = g.useState(null), y = g.useRef(!1), w = x ? !!o || !!x.closest("form") : !0, S = {
      checked: h,
      disabled: i,
      setChecked: f,
      control: x,
      setControl: m,
      name: a,
      form: o,
      value: u,
      hasConsumerStoppedPropagationRef: y,
      required: c,
      defaultChecked: Gr(s) ? !1 : s,
      isFormControl: w,
      bubbleInput: b,
      setBubbleInput: v
  };
  return p.jsx(Q5, {
      scope: t,
      ...S,
      children: J5(d) ? d(S) : r
  })
}
var $C = "CheckboxTrigger",
  FC = g.forwardRef(({
      __scopeCheckbox: e,
      onKeyDown: t,
      onClick: n,
      ...r
  }, s) => {
      const {
          control: i,
          value: o,
          disabled: a,
          checked: l,
          required: c,
          setControl: u,
          setChecked: d,
          hasConsumerStoppedPropagationRef: h,
          isFormControl: f,
          bubbleInput: x
      } = Ng($C, e), m = we(s, u), b = g.useRef(l);
      return g.useEffect(() => {
          const v = i == null ? void 0 : i.form;
          if (v) {
              const y = () => d(b.current);
              return v.addEventListener("reset", y), () => v.removeEventListener("reset", y)
          }
      }, [i, d]), p.jsx(ae.button, {
          type: "button",
          role: "checkbox",
          "aria-checked": Gr(l) ? "mixed" : l,
          "aria-required": c,
          "data-state": WC(l),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: o,
          ...r,
          ref: m,
          onKeyDown: ne(t, v => {
              v.key === "Enter" && v.preventDefault()
          }),
          onClick: ne(n, v => {
              d(y => Gr(y) ? !0 : !y), x && f && (h.current = v.isPropagationStopped(), h.current || v.stopPropagation())
          })
      })
  });
FC.displayName = $C;
var jg = g.forwardRef((e, t) => {
  const {
      __scopeCheckbox: n,
      name: r,
      checked: s,
      defaultChecked: i,
      required: o,
      disabled: a,
      value: l,
      onCheckedChange: c,
      form: u,
      ...d
  } = e;
  return p.jsx(Y5, {
      __scopeCheckbox: n,
      checked: s,
      defaultChecked: i,
      disabled: a,
      required: o,
      onCheckedChange: c,
      name: r,
      form: u,
      value: l,
      internal_do_not_use_render: ({
          isFormControl: h
      }) => p.jsxs(p.Fragment, {
          children: [p.jsx(FC, {
              ...d,
              ref: t,
              __scopeCheckbox: n
          }), h && p.jsx(zC, {
              __scopeCheckbox: n
          })]
      })
  })
});
jg.displayName = Ju;
var UC = "CheckboxIndicator",
  VC = g.forwardRef((e, t) => {
      const {
          __scopeCheckbox: n,
          forceMount: r,
          ...s
      } = e, i = Ng(UC, n);
      return p.jsx(tr, {
          present: r || Gr(i.checked) || i.checked === !0,
          children: p.jsx(ae.span, {
              "data-state": WC(i.checked),
              "data-disabled": i.disabled ? "" : void 0,
              ...s,
              ref: t,
              style: {
                  pointerEvents: "none",
                  ...e.style
              }
          })
      })
  });
VC.displayName = UC;
var BC = "CheckboxBubbleInput",
  zC = g.forwardRef(({
      __scopeCheckbox: e,
      ...t
  }, n) => {
      const {
          control: r,
          hasConsumerStoppedPropagationRef: s,
          checked: i,
          defaultChecked: o,
          required: a,
          disabled: l,
          name: c,
          value: u,
          form: d,
          bubbleInput: h,
          setBubbleInput: f
      } = Ng(BC, e), x = we(n, f), m = SC(i), b = Am(r);
      g.useEffect(() => {
          const y = h;
          if (!y) return;
          const w = window.HTMLInputElement.prototype,
              _ = Object.getOwnPropertyDescriptor(w, "checked").set,
              E = !s.current;
          if (m !== i && _) {
              const T = new Event("click", {
                  bubbles: E
              });
              y.indeterminate = Gr(i), _.call(y, Gr(i) ? !1 : i), y.dispatchEvent(T)
          }
      }, [h, m, i, s]);
      const v = g.useRef(Gr(i) ? !1 : i);
      return p.jsx(ae.input, {
          type: "checkbox",
          "aria-hidden": !0,
          defaultChecked: o ?? v.current,
          required: a,
          disabled: l,
          name: c,
          value: u,
          form: d,
          ...t,
          tabIndex: -1,
          ref: x,
          style: {
              ...t.style,
              ...b,
              position: "absolute",
              pointerEvents: "none",
              opacity: 0,
              margin: 0,
              transform: "translateX(-100%)"
          }
      })
  });
zC.displayName = BC;

function J5(e) {
  return typeof e == "function"
}

function Gr(e) {
  return e === "indeterminate"
}

function WC(e) {
  return Gr(e) ? "indeterminate" : e ? "checked" : "unchecked"
}
const HC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(jg, {
  ref: n,
  className: ee("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", e),
  ...t,
  children: p.jsx(VC, {
      className: ee("flex items-center justify-center text-current"),
      children: p.jsx(jA, {
          className: "h-4 w-4"
      })
  })
}));
HC.displayName = jg.displayName;

function X5() {
  return Fu({
      queryKey: ["guests"],
      queryFn: async () => {
          const {
              data: e,
              error: t
          } = await yt.from("guests").select("*").order("created_at", {
              ascending: !1
          });
          if (t) throw t;
          return e
      }
  })
}

function Z5() {
  const e = $u();
  return LS({
      mutationFn: async t => {
          const {
              data: n
          } = await yt.from("guests").select("id").ilike("full_name", t.full_name).maybeSingle();
          if (n) {
              const {
                  data: r,
                  error: s
              } = await yt.from("guests").update({
                  attendance: t.attendance,
                  guest_count: t.guest_count,
                  dietary_requirements: t.dietary_requirements || null,
                  message: t.message || null,
                  email: t.email || null,
                  responded_at: new Date().toISOString()
              }).eq("id", n.id).select().single();
              if (s) throw s;
              return {
                  data: r,
                  isUpdate: !0
              }
          } else {
              const {
                  data: r,
                  error: s
              } = await yt.from("guests").insert({
                  full_name: t.full_name,
                  attendance: t.attendance,
                  guest_count: t.guest_count,
                  dietary_requirements: t.dietary_requirements || null,
                  message: t.message || null,
                  email: t.email || null,
                  responded_at: new Date().toISOString()
              }).select().single();
              if (s) throw s;
              return {
                  data: r,
                  isUpdate: !1
              }
          }
      },
      onSuccess: () => {
          e.invalidateQueries({
              queryKey: ["guests"]
          })
      }
  })
}

function eU() {
  const e = $u();
  return LS({
      mutationFn: async t => {
          const {
              error: n
          } = await yt.from("guests").delete().eq("id", t);
          if (n) throw n
      },
      onSuccess: () => {
          e.invalidateQueries({
              queryKey: ["guests"]
          })
      }
  })
}
const tU = "/assets/rsvp-confirmation-DYbKwzwP.webm";

function nU({
  attendance: e
}) {
  const [t, n] = g.useState(!1), [r, s] = g.useState(!1), i = g.useRef(null);
  g.useEffect(() => {
      if (e === "no") {
          n(!0);
          return
      }
      const a = i.current;
      if (!a) return;
      const l = () => {
              a.duration - a.currentTime <= 1.5 && !r && s(!0)
          },
          c = () => {
              n(!0)
          };
      return a.addEventListener("timeupdate", l), a.addEventListener("ended", c), () => {
          a.removeEventListener("timeupdate", l), a.removeEventListener("ended", c)
      }
  }, [e, r]);
  const o = () => {
      const a = "Boda Fernanda & Gregorio",
          l = "20260328",
          d = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(a)}&dates=${l}/${l}&location=${encodeURIComponent("Culiacn, Sinaloa")}&details=${encodeURIComponent("Celebracin de la boda de Fernanda y Gregorio")}`;
      window.open(d, "_blank")
  };
  return e === "no" ? p.jsx("section", {
      id: "rsvp",
      className: "section-padding bg-ivory",
      children: p.jsxs(Y.div, {
          initial: {
              opacity: 0,
              scale: .95
          },
          animate: {
              opacity: 1,
              scale: 1
          },
          className: "max-w-lg mx-auto text-center",
          children: [p.jsx("h2", {
              className: "font-script text-5xl md:text-6xl text-foreground mb-6",
              children: "Gracias"
          }), p.jsx("p", {
              className: "text-muted-foreground font-body text-lg leading-relaxed",
              children: "Sentimos mucho que no puedas acompaarnos. Te tendremos muy presente en este da tan especial."
          }), p.jsx("p", {
              className: "text-muted-foreground font-script text-3xl mt-8",
              children: " Fernanda & Gregorio"
          })]
      })
  }) : p.jsx("section", {
      id: "rsvp",
      className: "min-h-screen bg-ivory flex items-center justify-center relative overflow-hidden",
      children: p.jsx(Qf, {
          mode: "wait",
          children: t ? p.jsxs(Y.div, {
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: 1
              },
              transition: {
                  duration: 1,
                  delay: .3
              },
              className: "w-full min-h-screen flex flex-col items-center justify-center px-6 py-20",
              children: [p.jsx(Y.h2, {
                  initial: {
                      opacity: 0,
                      y: 20
                  },
                  animate: {
                      opacity: 1,
                      y: 0
                  },
                  transition: {
                      duration: .8,
                      delay: .5
                  },
                  className: "font-script text-5xl md:text-6xl lg:text-7xl text-foreground mb-8 text-center",
                  children: "Gracias por confirmar tu asistencia"
              }), p.jsxs(Y.div, {
                  initial: {
                      opacity: 0,
                      y: 20
                  },
                  animate: {
                      opacity: 1,
                      y: 0
                  },
                  transition: {
                      duration: .8,
                      delay: .8
                  },
                  className: "space-y-6 max-w-2xl text-center",
                  children: [p.jsx("p", {
                      className: "text-foreground/90 font-body text-lg md:text-xl leading-relaxed",
                      children: "Nos hace muchsima ilusin saber que nos acompaars en este da tan especial."
                  }), p.jsx("p", {
                      className: "text-foreground/90 font-body text-lg md:text-xl leading-relaxed",
                      children: "Gracias por formar parte de nuestra historia."
                  }), p.jsx("p", {
                      className: "text-muted-foreground font-body text-base md:text-lg",
                      children: "Te esperamos el 28 de marzo en Culiacn, Sinaloa."
                  })]
              }), p.jsx(Y.p, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: 1
                  },
                  transition: {
                      duration: .8,
                      delay: 1.2
                  },
                  className: "text-muted-foreground font-script text-3xl md:text-4xl mt-10",
                  children: " Fernanda & Gregorio"
              }), p.jsxs(Y.div, {
                  initial: {
                      opacity: 0,
                      y: 20
                  },
                  animate: {
                      opacity: 1,
                      y: 0
                  },
                  transition: {
                      duration: .8,
                      delay: 1.5
                  },
                  className: "mt-12 flex flex-col items-center gap-6",
                  children: [p.jsxs(Nn, {
                      onClick: o,
                      variant: "outline",
                      className: "gap-2 border-primary/30 text-foreground hover:bg-primary hover:text-primary-foreground transition-colors",
                      children: [p.jsx(AA, {
                          className: "w-5 h-5"
                      }), "Aadir al calendario"]
                  }), p.jsxs(Nn, {
                      onClick: () => {
                          window.open("https://docs.google.com/forms/d/e/1FAIpQLSedoURRmCDKR5K3rz0iTJLELHm4aHntcFf_UeT_lle1-CdfRg/viewform", "_blank", "noopener,noreferrer")
                      },
                      variant: "default",
                      className: "gap-2 bg-primary hover:bg-primary/90 text-primary-foreground transition-colors",
                      children: [p.jsx(KA, {
                          className: "w-5 h-5"
                      }), "Confirmar asistencia"]
                  }), p.jsx("p", {
                      className: "text-muted-foreground font-body text-sm max-w-md text-center leading-relaxed",
                      children: "Si por cualquier motivo no puedes asistir, te agradeceramos mucho que nos avisaras con antelacin. Puedes contactarnos por WhatsApp."
                  })]
              })]
          }, "message") : p.jsxs(Y.div, {
              initial: {
                  opacity: 1
              },
              animate: {
                  opacity: 1
              },
              exit: {
                  opacity: 0
              },
              className: "fixed inset-0 z-50 flex items-center justify-center bg-ivory",
              children: [p.jsx("video", {
                  ref: i,
                  src: tU,
                  autoPlay: !0,
                  muted: !0,
                  playsInline: !0,
                  className: "w-full h-full object-cover"
              }), p.jsx(Y.div, {
                  initial: {
                      opacity: 0
                  },
                  animate: {
                      opacity: r ? 1 : 0
                  },
                  transition: {
                      duration: 1.5,
                      ease: "easeInOut"
                  },
                  className: "absolute inset-0 bg-ivory pointer-events-none",
                  onAnimationComplete: () => {
                      r && setTimeout(() => n(!0), 300)
                  }
              })]
          }, "video")
      })
  })
}
const Ew = [{
  id: "gluten",
  label: "Sin gluten / Celaco"
}, {
  id: "lactose",
  label: "Sin lactosa"
}, {
  id: "vegetarian",
  label: "Vegetariano"
}, {
  id: "vegan",
  label: "Vegano"
}, {
  id: "nuts",
  label: "Alergia a frutos secos"
}, {
  id: "seafood",
  label: "Alergia a mariscos"
}];

function rU() {
  const [e, t] = g.useState(!1), [u, d] = g.useState({
      attendance: "yes"
  }), {
      toast: f
  } = Ru();
  const w = S => {
      S.preventDefault();
      if (u.attendance === "yes") {
          t(!0)
      } else {
          t(!0)
      }
  };
  return e ? p.jsx(nU, {
      attendance: u.attendance
  }) : p.jsx("section", {
      id: "rsvp",
      className: "section-padding bg-ivory",
      children: p.jsxs("div", {
          className: "max-w-xl mx-auto",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6
              },
              className: "text-center mb-12",
              children: [p.jsx("h2", {
                  className: "font-script text-5xl md:text-6xl text-foreground mb-2",
                  children: "Confirma tu asistencia"
              }), p.jsx("p", {
                  className: "text-muted-foreground font-body tracking-wide",
                  children: "Esperamos contar contigo"
              })]
          }), p.jsxs(Y.form, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              whileInView: {
                  opacity: 1,
                  y: 0
              },
              viewport: {
                  once: !0
              },
              transition: {
                  duration: .6,
                  delay: .2
              },
              onSubmit: w,
              className: "bg-card/90 backdrop-blur-sm border border-border rounded-sm p-8 space-y-6 shadow-soft",
              children: [p.jsxs("div", {
                  children: [p.jsx(ht, {
                      className: "text-foreground font-medium",
                      children: "Asistirs? *"
                  }), p.jsxs(LC, {
                      value: u.attendance,
                      onValueChange: S => d({
                          ...u,
                          attendance: S
                      }),
                      className: "flex gap-6 mt-3",
                      children: [p.jsxs("div", {
                          className: "flex items-center space-x-2",
                          children: [p.jsx(vp, {
                              value: "yes",
                              id: "yes",
                              className: "border-primary text-primary"
                          }), p.jsx(ht, {
                              htmlFor: "yes",
                              className: "cursor-pointer text-foreground",
                              children: "S, asistir"
                          })]
                      }), p.jsxs("div", {
                          className: "flex items-center space-x-2",
                          children: [p.jsx(vp, {
                              value: "no",
                              id: "no",
                              className: "border-primary text-primary"
                          }), p.jsx(ht, {
                              htmlFor: "no",
                              className: "cursor-pointer text-foreground",
                              children: "No podr asistir"
                          })]
                      })]
                  })]
              }), p.jsx(Nn, {
                  type: "submit",
                  className: "w-full gap-2 bg-primary hover:bg-primary/90 text-primary-foreground font-medium",
                  children: "Continuar"
              })]
          })]
      })
  })
}

function sU({
  name1: e,
  name2: t,
  date: n
}) {
  const r = new Date(n).toLocaleDateString("es-ES", {
      day: "numeric",
      month: "long",
      year: "numeric"
  });
  return p.jsx("footer", {
      className: "py-16 bg-primary text-center",
      children: p.jsxs(Y.div, {
          initial: {
              opacity: 0
          },
          whileInView: {
              opacity: 1
          },
          viewport: {
              once: !0
          },
          transition: {
              duration: .8
          },
          children: [p.jsx(L1, {
              className: "w-8 h-8 mx-auto text-primary-foreground/70"
          }), p.jsxs("p", {
              className: "font-script text-5xl text-primary-foreground mt-4 mb-2",
              children: [e, " & ", t]
          }), p.jsx("p", {
              className: "text-sm text-primary-foreground/80 font-body tracking-wide",
              children: r
          }), p.jsx("p", {
              className: "text-xs text-primary-foreground/60 mt-8 font-body",
              children: "Con todo nuestro amor"
          })]
      })
  })
}

function Cw() {
  return p.jsxs(Y.div, {
      initial: {
          opacity: 0
      },
      whileInView: {
          opacity: 1
      },
      viewport: {
          once: !0
      },
      transition: {
          duration: .8
      },
      className: "flex items-center justify-center py-6 bg-ivory",
      children: [p.jsx("span", {
          className: "h-px bg-primary/30 w-16 md:w-24"
      }), p.jsx("span", {
          className: "mx-4 text-primary/50 text-lg font-script",
          children: ""
      }), p.jsx("span", {
          className: "h-px bg-primary/30 w-16 md:w-24"
      })]
  })
}
const iU = "/assets/intro-elena-david-pQcNxl1G.mp4",
  oU = "/assets/intro-poster-elena-david-DMgkemLz.jpg",
  aU = ({
      onEnter: e,
      onInteraction: t
  }) => {
      const [n, r] = g.useState("idle"), s = g.useRef(null), i = () => {
          n === "idle" && (r("playing"), s.current && s.current.play(), t == null || t())
      }, o = () => {
          if (!s.current) return;
          const l = s.current;
          l.duration - l.currentTime <= .8 && n === "playing" && (r("fading"), setTimeout(() => {
              e()
          }, 800))
      }, a = l => {
          l.stopPropagation(), r("fading"), setTimeout(() => {
              e()
          }, 400), t == null || t()
      };
      return p.jsxs("div", {
          className: "fixed inset-0 z-50 cursor-pointer",
          onClick: i,
          children: [p.jsx("video", {
              ref: s,
              src: iU,
              poster: oU,
              className: "w-full h-full object-cover",
              onTimeUpdate: o,
              playsInline: !0,
              muted: !0,
              preload: "auto"
          }), p.jsx(Y.div, {
              className: "absolute inset-0 bg-white pointer-events-none",
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: n === "fading" ? 1 : 0
              },
              transition: {
                  duration: .8,
                  ease: "easeInOut"
              }
          }), p.jsx(Y.button, {
              onClick: a,
              initial: {
                  opacity: 0
              },
              animate: {
                  opacity: .5
              },
              whileHover: {
                  opacity: .8
              },
              transition: {
                  duration: .3,
                  delay: 1.5
              },
              className: "absolute bottom-8 right-8 text-xs font-body tracking-widest uppercase text-neutral-500 hover:text-neutral-700 transition-colors duration-300",
              children: "Saltar"
          })]
      })
  };

function lU() {
  return Fu({
      queryKey: ["wedding-settings"],
      queryFn: async () => {
          const {
              data: e,
              error: t
          } = await yt.from("wedding_settings").select("*").maybeSingle();
          if (t) throw t;
          return e
      }
  })
}
const cU = "/assets/elena_y_david-BF61jgoc.mp3",
  Zt = "/assets/floral-border-J4FzR5M8.png",
  uU = () => {
      const {
          data: e,
          isLoading: t
      } = lU(), [n, r] = g.useState(!0), [s, i] = g.useState(!1), o = g.useRef(null);
      g.useEffect(() => {
          o.current && (o.current.volume = 0, o.current.play().then(() => {
              let u = 0;
              const d = setInterval(() => {
                  u += .017, u >= .5 ? (o.current.volume = .5, clearInterval(d)) : o.current.volume = u
              }, 100)
          }).catch(() => {}))
      }, []);
      const a = () => {
              o.current && o.current.paused && o.current.play().catch(() => {})
          },
          l = () => {
              o.current && (o.current.muted = !o.current.muted, i(!s))
          };
      if (t) return p.jsx("div", {
          className: "min-h-screen flex items-center justify-center bg-background",
          children: p.jsx("div", {
              className: "animate-pulse text-muted-foreground",
              children: "Cargando..."
          })
      });
      const c = e || {
          couple_name_1: "Fernanda",
          couple_name_2: "Gregorio",
          wedding_date: "2026-03-29",
          hero_subtitle: "Nuestra prxima aventura juntos",
          banquet_location: "Jardines del ro",
          banquet_address: "Culiacn Rosales",
          banquet_maps_url: "https://maps.app.goo.gl/pKbmFeZjzzrjkHVj9"
      };
      return p.jsxs(p.Fragment, {
          children: [p.jsx("audio", {
              ref: o,
              src: cU,
              preload: "auto",
              loop: !0
          }), p.jsx("button", {
              onClick: l,
              className: "fixed bottom-6 right-6 z-50 p-3 rounded-full bg-primary/90 text-primary-foreground shadow-lg hover:bg-primary transition-all duration-300 backdrop-blur-sm",
              "aria-label": s ? "Activar sonido" : "Silenciar",
              children: s ? p.jsx(XA, {
                  size: 20
              }) : p.jsx(JA, {
                  size: 20
              })
          }), n ? p.jsx(aU, {
              onEnter: () => r(!1),
              onInteraction: a
          }) : p.jsxs("main", {
              className: "bg-background relative overflow-hidden",
              children: [p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute right-0 top-[2%] h-[280px] md:h-[450px] w-auto object-contain object-right opacity-70 pointer-events-none z-10"
              }), p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute right-0 top-[18%] h-[350px] md:h-[550px] w-auto object-contain object-right opacity-70 pointer-events-none z-10"
              }), p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute right-0 top-[90%] h-[350px] md:h-[550px] w-auto object-contain object-right opacity-40 pointer-events-none z-0"
              }), p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute left-0 top-[8%] h-[320px] md:h-[480px] w-auto object-contain object-left opacity-70 pointer-events-none z-10 scale-x-[-1]"
              }), p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute left-0 top-[28%] h-[270px] md:h-[420px] w-auto object-contain object-left opacity-70 pointer-events-none z-10 scale-x-[-1]"
              }), p.jsx("img", {
                  src: Zt,
                  alt: "",
                  className: "absolute left-0 top-[45%] h-[340px] md:h-[520px] w-auto object-contain object-left opacity-50 pointer-events-none z-10 scale-x-[-1]"
              }), p.jsx(hF, {
                  name1: c.couple_name_1,
                  name2: c.couple_name_2,
                  date: c.wedding_date,
                  subtitle: c.hero_subtitle
              }), p.jsx(fF, {
                  targetDate: c.wedding_date
              }), p.jsx(mF, {
                  location: c.banquet_location,
                  address: c.banquet_address,
                  mapsUrl: c.banquet_maps_url,
                  startTime: "17:00",
                  endTime: "23:30",
                  weddingDate: c.wedding_date
              }), p.jsx(Cw, {}), p.jsx(gF, {}), p.jsx(Cw, {}), p.jsx(Z3, {}), p.jsx(b5, {}), p.jsx(DressCode, {}), p.jsx(_5, {
                  enabled: !0,
                  iban: "https://mesaderegalos.liverpool.com.mx/milistaderegalos/51705969"
              }), p.jsx(Cw, {}), p.jsx(Gallery, {}), p.jsx(rU, {}), p.jsx(sU, {
                  name1: c.couple_name_1,
                  name2: c.couple_name_2,
                  date: c.wedding_date
              })]
          })]
      })
  };

function dU() {
  const [e, t] = g.useState(null), [n, r] = g.useState(null), [s, i] = g.useState(!0), [o, a] = g.useState(!1);
  g.useEffect(() => {
      const {
          data: {
              subscription: h
          }
      } = yt.auth.onAuthStateChange((f, x) => {
          r(x), t((x == null ? void 0 : x.user) ?? null), i(!1), x != null && x.user ? setTimeout(() => {
              l(x.user.id)
          }, 0) : a(!1)
      });
      return yt.auth.getSession().then(({
          data: {
              session: f
          }
      }) => {
          r(f), t((f == null ? void 0 : f.user) ?? null), i(!1), f != null && f.user && l(f.user.id)
      }), () => h.unsubscribe()
  }, []);
  const l = async h => {
      const {
          data: f,
          error: x
      } = await yt.from("user_roles").select("role").eq("user_id", h).eq("role", "admin").maybeSingle();
      a(!!(!x && f))
  };
  return {
      user: e,
      session: n,
      loading: s,
      isAdmin: o,
      signIn: async (h, f) => {
          const {
              error: x
          } = await yt.auth.signInWithPassword({
              email: h,
              password: f
          });
          return {
              error: x
          }
      },
      signUp: async (h, f) => {
          const x = `${window.location.origin}/`,
              {
                  error: m
              } = await yt.auth.signUp({
                  email: h,
                  password: f,
                  options: {
                      emailRedirectTo: x
                  }
              });
          return {
              error: m
          }
      },
      signOut: async () => {
          const {
              error: h
          } = await yt.auth.signOut();
          return {
              error: h
          }
      }
  }
}

function hU() {
  const [e, t] = g.useState(!0), [n, r] = g.useState(""), [s, i] = g.useState(""), [o, a] = g.useState(!1), [l, c] = g.useState(!1), {
      signIn: u,
      signUp: d
  } = dU(), {
      toast: h
  } = Ru(), f = KS(), x = async m => {
      m.preventDefault(), c(!0);
      try {
          const {
              error: b
          } = e ? await u(n, s) : await d(n, s);
          b ? h({
              title: "Error",
              description: b.message,
              variant: "destructive"
          }) : e ? f("/admin/dashboard") : (h({
              title: "Cuenta creada",
              description: "Ya puedes iniciar sesin."
          }), t(!0))
      } catch {
          h({
              title: "Error",
              description: "Algo sali mal. Intntalo de nuevo.",
              variant: "destructive"
          })
      } finally {
          c(!1)
      }
  };
  return p.jsx("div", {
      className: "min-h-screen flex items-center justify-center bg-background p-6",
      children: p.jsxs(Y.div, {
          initial: {
              opacity: 0,
              y: 20
          },
          animate: {
              opacity: 1,
              y: 0
          },
          className: "w-full max-w-md",
          children: [p.jsxs("div", {
              className: "text-center mb-8",
              children: [p.jsx("h1", {
                  className: "font-display text-3xl mb-2",
                  children: "Panel de administracin"
              }), p.jsx("p", {
                  className: "text-muted-foreground",
                  children: "Gestiona tu invitacin de boda"
              })]
          }), p.jsxs("form", {
              onSubmit: x,
              className: "space-y-6 card-elegant",
              children: [p.jsxs("div", {
                  children: [p.jsx(ht, {
                      htmlFor: "email",
                      children: "Email"
                  }), p.jsxs("div", {
                      className: "relative mt-2",
                      children: [p.jsx(WA, {
                          className: "absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground"
                      }), p.jsx(Er, {
                          id: "email",
                          type: "email",
                          required: !0,
                          value: n,
                          onChange: m => r(m.target.value),
                          className: "pl-10",
                          placeholder: "admin@ejemplo.com"
                      })]
                  })]
              }), p.jsxs("div", {
                  children: [p.jsx(ht, {
                      htmlFor: "password",
                      children: "Contrasea"
                  }), p.jsxs("div", {
                      className: "relative mt-2",
                      children: [p.jsx(zA, {
                          className: "absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground"
                      }), p.jsx(Er, {
                          id: "password",
                          type: o ? "text" : "password",
                          required: !0,
                          value: s,
                          onChange: m => i(m.target.value),
                          className: "pl-10 pr-10",
                          placeholder: "",
                          minLength: 6
                      }), p.jsx("button", {
                          type: "button",
                          onClick: () => a(!o),
                          className: "absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground",
                          children: o ? p.jsx(FA, {
                              className: "w-4 h-4"
                          }) : p.jsx(UA, {
                              className: "w-4 h-4"
                          })
                      })]
                  })]
              }), p.jsx(Nn, {
                  type: "submit",
                  className: "w-full",
                  disabled: l,
                  children: l ? "Cargando..." : e ? "Iniciar sesin" : "Crear cuenta"
              }), p.jsxs("p", {
                  className: "text-center text-sm text-muted-foreground",
                  children: [e ? "No tienes cuenta?" : "Ya tienes cuenta?", " ", p.jsx("button", {
                      type: "button",
                      onClick: () => t(!e),
                      className: "text-primary hover:underline",
                      children: e ? "Regstrate" : "Inicia sesin"
                  })]
              })]
          })]
      })
  })
}
const gs = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("div", {
  ref: n,
  className: ee("rounded-lg border bg-card text-card-foreground shadow-sm", e),
  ...t
}));
gs.displayName = "Card";
const ys = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("div", {
  ref: n,
  className: ee("flex flex-col space-y-1.5 p-6", e),
  ...t
}));
ys.displayName = "CardHeader";
const vs = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("h3", {
  ref: n,
  className: ee("text-2xl font-semibold leading-none tracking-tight", e),
  ...t
}));
vs.displayName = "CardTitle";
const fU = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("p", {
  ref: n,
  className: ee("text-sm text-muted-foreground", e),
  ...t
}));
fU.displayName = "CardDescription";
const ws = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("div", {
  ref: n,
  className: ee("p-6 pt-0", e),
  ...t
}));
ws.displayName = "CardContent";
const pU = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("div", {
  ref: n,
  className: ee("flex items-center p-6 pt-0", e),
  ...t
}));
pU.displayName = "CardFooter";
const KC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("div", {
  className: "relative w-full overflow-auto",
  children: p.jsx("table", {
      ref: n,
      className: ee("w-full caption-bottom text-sm", e),
      ...t
  })
}));
KC.displayName = "Table";
const qC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("thead", {
  ref: n,
  className: ee("[&_tr]:border-b", e),
  ...t
}));
qC.displayName = "TableHeader";
const GC = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("tbody", {
  ref: n,
  className: ee("[&_tr:last-child]:border-0", e),
  ...t
}));
GC.displayName = "TableBody";
const mU = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("tfoot", {
  ref: n,
  className: ee("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", e),
  ...t
}));
mU.displayName = "TableFooter";
const wp = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("tr", {
  ref: n,
  className: ee("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", e),
  ...t
}));
wp.displayName = "TableRow";
const mr = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("th", {
  ref: n,
  className: ee("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", e),
  ...t
}));
mr.displayName = "TableHead";
const gr = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("td", {
  ref: n,
  className: ee("p-4 align-middle [&:has([role=checkbox])]:pr-0", e),
  ...t
}));
gr.displayName = "TableCell";
const gU = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx("caption", {
  ref: n,
  className: ee("mt-4 text-sm text-muted-foreground", e),
  ...t
}));
gU.displayName = "TableCaption";
const yU = ju("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", {
  variants: {
      variant: {
          default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
          secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
          destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
          outline: "text-foreground"
      }
  },
  defaultVariants: {
      variant: "default"
  }
});

function vU({
  className: e,
  variant: t,
  ...n
}) {
  return p.jsx("div", {
      className: ee(yU({
          variant: t
      }), e),
      ...n
  })
}
var uh = "focusScope.autoFocusOnMount",
  dh = "focusScope.autoFocusOnUnmount",
  Tw = {
      bubbles: !1,
      cancelable: !0
  },
  wU = "FocusScope",
  QC = g.forwardRef((e, t) => {
      const {
          loop: n = !1,
          trapped: r = !1,
          onMountAutoFocus: s,
          onUnmountAutoFocus: i,
          ...o
      } = e, [a, l] = g.useState(null), c = fn(s), u = fn(i), d = g.useRef(null), h = we(t, m => l(m)), f = g.useRef({
          paused: !1,
          pause() {
              this.paused = !0
          },
          resume() {
              this.paused = !1
          }
      }).current;
      g.useEffect(() => {
          if (r) {
              let m = function(w) {
                      if (f.paused || !a) return;
                      const S = w.target;
                      a.contains(S) ? d.current = S : yr(d.current, {
                          select: !0
                      })
                  },
                  b = function(w) {
                      if (f.paused || !a) return;
                      const S = w.relatedTarget;
                      S !== null && (a.contains(S) || yr(d.current, {
                          select: !0
                      }))
                  },
                  v = function(w) {
                      if (document.activeElement === document.body)
                          for (const _ of w) _.removedNodes.length > 0 && yr(a)
                  };
              document.addEventListener("focusin", m), document.addEventListener("focusout", b);
              const y = new MutationObserver(v);
              return a && y.observe(a, {
                  childList: !0,
                  subtree: !0
              }), () => {
                  document.removeEventListener("focusin", m), document.removeEventListener("focusout", b), y.disconnect()
              }
          }
      }, [r, a, f.paused]), g.useEffect(() => {
          if (a) {
              Rw.add(f);
              const m = document.activeElement;
              if (!a.contains(m)) {
                  const v = new CustomEvent(uh, Tw);
                  a.addEventListener(uh, c), a.dispatchEvent(v), v.defaultPrevented || (xU(CU(YC(a)), {
                      select: !0
                  }), document.activeElement === m && yr(a))
              }
              return () => {
                  a.removeEventListener(uh, c), setTimeout(() => {
                      const v = new CustomEvent(dh, Tw);
                      a.addEventListener(dh, u), a.dispatchEvent(v), v.defaultPrevented || yr(m ?? document.body, {
                          select: !0
                      }), a.removeEventListener(dh, u), Rw.remove(f)
                  }, 0)
              }
          }
      }, [a, c, u, f]);
      const x = g.useCallback(m => {
          if (!n && !r || f.paused) return;
          const b = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
              v = document.activeElement;
          if (b && v) {
              const y = m.currentTarget,
                  [w, S] = bU(y);
              w && S ? !m.shiftKey && v === S ? (m.preventDefault(), n && yr(w, {
                  select: !0
              })) : m.shiftKey && v === w && (m.preventDefault(), n && yr(S, {
                  select: !0
              })) : v === y && m.preventDefault()
          }
      }, [n, r, f.paused]);
      return p.jsx(ae.div, {
          tabIndex: -1,
          ...o,
          ref: h,
          onKeyDown: x
      })
  });
QC.displayName = wU;

function xU(e, {
  select: t = !1
} = {}) {
  const n = document.activeElement;
  for (const r of e)
      if (yr(r, {
              select: t
          }), document.activeElement !== n) return
}

function bU(e) {
  const t = YC(e),
      n = kw(t, e),
      r = kw(t.reverse(), e);
  return [n, r]
}

function YC(e) {
  const t = [],
      n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
          acceptNode: r => {
              const s = r.tagName === "INPUT" && r.type === "hidden";
              return r.disabled || r.hidden || s ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
          }
      });
  for (; n.nextNode();) t.push(n.currentNode);
  return t
}

function kw(e, t) {
  for (const n of e)
      if (!SU(n, {
              upTo: t
          })) return n
}

function SU(e, {
  upTo: t
}) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e;) {
      if (t !== void 0 && e === t) return !1;
      if (getComputedStyle(e).display === "none") return !0;
      e = e.parentElement
  }
  return !1
}

function _U(e) {
  return e instanceof HTMLInputElement && "select" in e
}

function yr(e, {
  select: t = !1
} = {}) {
  if (e && e.focus) {
      const n = document.activeElement;
      e.focus({
          preventScroll: !0
      }), e !== n && _U(e) && t && e.select()
  }
}
var Rw = EU();

function EU() {
  let e = [];
  return {
      add(t) {
          const n = e[0];
          t !== n && (n == null || n.pause()), e = Pw(e, t), e.unshift(t)
      },
      remove(t) {
          var n;
          e = Pw(e, t), (n = e[0]) == null || n.resume()
      }
  }
}

function Pw(e, t) {
  const n = [...e],
      r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n
}

function CU(e) {
  return e.filter(t => t.tagName !== "A")
}
var hh = 0;

function TU() {
  g.useEffect(() => {
      const e = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", e[0] ?? Aw()), document.body.insertAdjacentElement("beforeend", e[1] ?? Aw()), hh++, () => {
          hh === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()), hh--
      }
  }, [])
}

function Aw() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e
}
var wc = "right-scroll-bar-position",
  xc = "width-before-scroll-bar",
  kU = "with-scroll-bars-hidden",
  RU = "--removed-body-scroll-bar-size";

function fh(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e
}

function PU(e, t) {
  var n = g.useState(function() {
      return {
          value: e,
          callback: t,
          facade: {
              get current() {
                  return n.value
              },
              set current(r) {
                  var s = n.value;
                  s !== r && (n.value = r, n.callback(r, s))
              }
          }
      }
  })[0];
  return n.callback = t, n.facade
}
var AU = typeof window < "u" ? g.useLayoutEffect : g.useEffect,
  Nw = new WeakMap;

function NU(e, t) {
  var n = PU(null, function(r) {
      return e.forEach(function(s) {
          return fh(s, r)
      })
  });
  return AU(function() {
      var r = Nw.get(n);
      if (r) {
          var s = new Set(r),
              i = new Set(e),
              o = n.current;
          s.forEach(function(a) {
              i.has(a) || fh(a, null)
          }), i.forEach(function(a) {
              s.has(a) || fh(a, o)
          })
      }
      Nw.set(n, e)
  }, [e]), n
}

function jU(e) {
  return e
}

function OU(e, t) {
  t === void 0 && (t = jU);
  var n = [],
      r = !1,
      s = {
          read: function() {
              if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
              return n.length ? n[n.length - 1] : e
          },
          useMedium: function(i) {
              var o = t(i, r);
              return n.push(o),
                  function() {
                      n = n.filter(function(a) {
                          return a !== o
                      })
                  }
          },
          assignSyncMedium: function(i) {
              for (r = !0; n.length;) {
                  var o = n;
                  n = [], o.forEach(i)
              }
              n = {
                  push: function(a) {
                      return i(a)
                  },
                  filter: function() {
                      return n
                  }
              }
          },
          assignMedium: function(i) {
              r = !0;
              var o = [];
              if (n.length) {
                  var a = n;
                  n = [], a.forEach(i), o = n
              }
              var l = function() {
                      var u = o;
                      o = [], u.forEach(i)
                  },
                  c = function() {
                      return Promise.resolve().then(l)
                  };
              c(), n = {
                  push: function(u) {
                      o.push(u), c()
                  },
                  filter: function(u) {
                      return o = o.filter(u), n
                  }
              }
          }
      };
  return s
}

function IU(e) {
  e === void 0 && (e = {});
  var t = OU(null);
  return t.options = En({
      async: !0,
      ssr: !1
  }, e), t
}
var JC = function(e) {
  var t = e.sideCar,
      n = No(e, ["sideCar"]);
  if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r) throw new Error("Sidecar medium not found");
  return g.createElement(r, En({}, n))
};
JC.isSideCarExport = !0;

function DU(e, t) {
  return e.useMedium(t), JC
}
var XC = IU(),
  ph = function() {},
  Xu = g.forwardRef(function(e, t) {
      var n = g.useRef(null),
          r = g.useState({
              onScrollCapture: ph,
              onWheelCapture: ph,
              onTouchMoveCapture: ph
          }),
          s = r[0],
          i = r[1],
          o = e.forwardProps,
          a = e.children,
          l = e.className,
          c = e.removeScrollBar,
          u = e.enabled,
          d = e.shards,
          h = e.sideCar,
          f = e.noRelative,
          x = e.noIsolation,
          m = e.inert,
          b = e.allowPinchZoom,
          v = e.as,
          y = v === void 0 ? "div" : v,
          w = e.gapMode,
          S = No(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]),
          _ = h,
          E = NU([n, t]),
          T = En(En({}, S), s);
      return g.createElement(g.Fragment, null, u && g.createElement(_, {
          sideCar: XC,
          removeScrollBar: c,
          shards: d,
          noRelative: f,
          noIsolation: x,
          inert: m,
          setCallbacks: i,
          allowPinchZoom: !!b,
          lockRef: n,
          gapMode: w
      }), o ? g.cloneElement(g.Children.only(a), En(En({}, T), {
          ref: E
      })) : g.createElement(y, En({}, T, {
          className: l,
          ref: E
      }), a))
  });
Xu.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Xu.classNames = {
  fullWidth: xc,
  zeroRight: wc
};
var MU = function() {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
};

function LU() {
  if (!document) return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = MU();
  return t && e.setAttribute("nonce", t), e
}

function $U(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t))
}

function FU(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e)
}
var UU = function() {
      var e = 0,
          t = null;
      return {
          add: function(n) {
              e == 0 && (t = LU()) && ($U(t, n), FU(t)), e++
          },
          remove: function() {
              e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null)
          }
      }
  },
  VU = function() {
      var e = UU();
      return function(t, n) {
          g.useEffect(function() {
              return e.add(t),
                  function() {
                      e.remove()
                  }
          }, [t && n])
      }
  },
  ZC = function() {
      var e = VU(),
          t = function(n) {
              var r = n.styles,
                  s = n.dynamic;
              return e(r, s), null
          };
      return t
  },
  BU = {
      left: 0,
      top: 0,
      right: 0,
      gap: 0
  },
  mh = function(e) {
      return parseInt(e || "", 10) || 0
  },
  zU = function(e) {
      var t = window.getComputedStyle(document.body),
          n = t[e === "padding" ? "paddingLeft" : "marginLeft"],
          r = t[e === "padding" ? "paddingTop" : "marginTop"],
          s = t[e === "padding" ? "paddingRight" : "marginRight"];
      return [mh(n), mh(r), mh(s)]
  },
  WU = function(e) {
      if (e === void 0 && (e = "margin"), typeof window > "u") return BU;
      var t = zU(e),
          n = document.documentElement.clientWidth,
          r = window.innerWidth;
      return {
          left: t[0],
          top: t[1],
          right: t[2],
          gap: Math.max(0, r - n + t[2] - t[0])
      }
  },
  HU = ZC(),
  Gi = "data-scroll-locked",
  KU = function(e, t, n, r) {
      var s = e.left,
          i = e.top,
          o = e.right,
          a = e.gap;
      return n === void 0 && (n = "margin"), `
.`.concat(kU, ` {
 overflow: hidden `).concat(r, `;
 padding-right: `).concat(a, "px ").concat(r, `;
}
body[`).concat(Gi, `] {
  overflow: hidden `).concat(r, `;
  overscroll-behavior: contain;
  `).concat([t && "position: relative ".concat(r, ";"), n === "margin" && `
  padding-left: `.concat(s, `px;
  padding-top: `).concat(i, `px;
  padding-right: `).concat(o, `px;
  margin-left:0;
  margin-top:0;
  margin-right: `).concat(a, "px ").concat(r, `;
  `), n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")].filter(Boolean).join(""), `
}

.`).concat(wc, ` {
  right: `).concat(a, "px ").concat(r, `;
}

.`).concat(xc, ` {
  margin-right: `).concat(a, "px ").concat(r, `;
}

.`).concat(wc, " .").concat(wc, ` {
  right: 0 `).concat(r, `;
}

.`).concat(xc, " .").concat(xc, ` {
  margin-right: 0 `).concat(r, `;
}

body[`).concat(Gi, `] {
  `).concat(RU, ": ").concat(a, `px;
}
`)
  },
  jw = function() {
      var e = parseInt(document.body.getAttribute(Gi) || "0", 10);
      return isFinite(e) ? e : 0
  },
  qU = function() {
      g.useEffect(function() {
          return document.body.setAttribute(Gi, (jw() + 1).toString()),
              function() {
                  var e = jw() - 1;
                  e <= 0 ? document.body.removeAttribute(Gi) : document.body.setAttribute(Gi, e.toString())
              }
      }, [])
  },
  GU = function(e) {
      var t = e.noRelative,
          n = e.noImportant,
          r = e.gapMode,
          s = r === void 0 ? "margin" : r;
      qU();
      var i = g.useMemo(function() {
          return WU(s)
      }, [s]);
      return g.createElement(HU, {
          styles: KU(i, !t, s, n ? "" : "!important")
      })
  },
  xp = !1;
if (typeof window < "u") try {
  var Ql = Object.defineProperty({}, "passive", {
      get: function() {
          return xp = !0, !0
      }
  });
  window.addEventListener("test", Ql, Ql), window.removeEventListener("test", Ql, Ql)
} catch {
  xp = !1
}
var fi = xp ? {
      passive: !1
  } : !1,
  QU = function(e) {
      return e.tagName === "TEXTAREA"
  },
  eT = function(e, t) {
      if (!(e instanceof Element)) return !1;
      var n = window.getComputedStyle(e);
      return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !QU(e) && n[t] === "visible")
  },
  YU = function(e) {
      return eT(e, "overflowY")
  },
  JU = function(e) {
      return eT(e, "overflowX")
  },
  Ow = function(e, t) {
      var n = t.ownerDocument,
          r = t;
      do {
          typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
          var s = tT(e, r);
          if (s) {
              var i = nT(e, r),
                  o = i[1],
                  a = i[2];
              if (o > a) return !0
          }
          r = r.parentNode
      } while (r && r !== n.body);
      return !1
  },
  XU = function(e) {
      var t = e.scrollTop,
          n = e.scrollHeight,
          r = e.clientHeight;
      return [t, n, r]
  },
  ZU = function(e) {
      var t = e.scrollLeft,
          n = e.scrollWidth,
          r = e.clientWidth;
      return [t, n, r]
  },
  tT = function(e, t) {
      return e === "v" ? YU(t) : JU(t)
  },
  nT = function(e, t) {
      return e === "v" ? XU(t) : ZU(t)
  },
  eV = function(e, t) {
      return e === "h" && t === "rtl" ? -1 : 1
  },
  tV = function(e, t, n, r, s) {
      var i = eV(e, window.getComputedStyle(t).direction),
          o = i * r,
          a = n.target,
          l = t.contains(a),
          c = !1,
          u = o > 0,
          d = 0,
          h = 0;
      do {
          if (!a) break;
          var f = nT(e, a),
              x = f[0],
              m = f[1],
              b = f[2],
              v = m - b - i * x;
          (x || v) && tT(e, a) && (d += v, h += x);
          var y = a.parentNode;
          a = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y
      } while (!l && a !== document.body || l && (t.contains(a) || t === a));
      return (u && (Math.abs(d) < 1 || !s) || !u && (Math.abs(h) < 1 || !s)) && (c = !0), c
  },
  Yl = function(e) {
      return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
  },
  Iw = function(e) {
      return [e.deltaX, e.deltaY]
  },
  Dw = function(e) {
      return e && "current" in e ? e.current : e
  },
  nV = function(e, t) {
      return e[0] === t[0] && e[1] === t[1]
  },
  rV = function(e) {
      return `
.block-interactivity-`.concat(e, ` {pointer-events: none;}
.allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
  },
  sV = 0,
  pi = [];

function iV(e) {
  var t = g.useRef([]),
      n = g.useRef([0, 0]),
      r = g.useRef(),
      s = g.useState(sV++)[0],
      i = g.useState(ZC)[0],
      o = g.useRef(e);
  g.useEffect(function() {
      o.current = e
  }, [e]), g.useEffect(function() {
      if (e.inert) {
          document.body.classList.add("block-interactivity-".concat(s));
          var m = vF([e.lockRef.current], (e.shards || []).map(Dw), !0).filter(Boolean);
          return m.forEach(function(b) {
                  return b.classList.add("allow-interactivity-".concat(s))
              }),
              function() {
                  document.body.classList.remove("block-interactivity-".concat(s)), m.forEach(function(b) {
                      return b.classList.remove("allow-interactivity-".concat(s))
                  })
              }
      }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = g.useCallback(function(m, b) {
          if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey) return !o.current.allowPinchZoom;
          var v = Yl(m),
              y = n.current,
              w = "deltaX" in m ? m.deltaX : y[0] - v[0],
              S = "deltaY" in m ? m.deltaY : y[1] - v[1],
              _, E = m.target,
              T = Math.abs(w) > Math.abs(S) ? "h" : "v";
          if ("touches" in m && T === "h" && E.type === "range") return !1;
          var k = Ow(T, E);
          if (!k) return !0;
          if (k ? _ = T : (_ = T === "v" ? "h" : "v", k = Ow(T, E)), !k) return !1;
          if (!r.current && "changedTouches" in m && (w || S) && (r.current = _), !_) return !0;
          var P = r.current || _;
          return tV(P, b, m, P === "h" ? w : S, !0)
      }, []),
      l = g.useCallback(function(m) {
          var b = m;
          if (!(!pi.length || pi[pi.length - 1] !== i)) {
              var v = "deltaY" in b ? Iw(b) : Yl(b),
                  y = t.current.filter(function(_) {
                      return _.name === b.type && (_.target === b.target || b.target === _.shadowParent) && nV(_.delta, v)
                  })[0];
              if (y && y.should) {
                  b.cancelable && b.preventDefault();
                  return
              }
              if (!y) {
                  var w = (o.current.shards || []).map(Dw).filter(Boolean).filter(function(_) {
                          return _.contains(b.target)
                      }),
                      S = w.length > 0 ? a(b, w[0]) : !o.current.noIsolation;
                  S && b.cancelable && b.preventDefault()
              }
          }
      }, []),
      c = g.useCallback(function(m, b, v, y) {
          var w = {
              name: m,
              delta: b,
              target: v,
              should: y,
              shadowParent: oV(v)
          };
          t.current.push(w), setTimeout(function() {
              t.current = t.current.filter(function(S) {
                  return S !== w
              })
          }, 1)
      }, []),
      u = g.useCallback(function(m) {
          n.current = Yl(m), r.current = void 0
      }, []),
      d = g.useCallback(function(m) {
          c(m.type, Iw(m), m.target, a(m, e.lockRef.current))
      }, []),
      h = g.useCallback(function(m) {
          c(m.type, Yl(m), m.target, a(m, e.lockRef.current))
      }, []);
  g.useEffect(function() {
      return pi.push(i), e.setCallbacks({
              onScrollCapture: d,
              onWheelCapture: d,
              onTouchMoveCapture: h
          }), document.addEventListener("wheel", l, fi), document.addEventListener("touchmove", l, fi), document.addEventListener("touchstart", u, fi),
          function() {
              pi = pi.filter(function(m) {
                  return m !== i
              }), document.removeEventListener("wheel", l, fi), document.removeEventListener("touchmove", l, fi), document.removeEventListener("touchstart", u, fi)
          }
  }, []);
  var f = e.removeScrollBar,
      x = e.inert;
  return g.createElement(g.Fragment, null, x ? g.createElement(i, {
      styles: rV(s)
  }) : null, f ? g.createElement(GU, {
      noRelative: e.noRelative,
      gapMode: e.gapMode
  }) : null)
}

function oV(e) {
  for (var t = null; e !== null;) e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t
}
const aV = DU(XC, iV);
var rT = g.forwardRef(function(e, t) {
  return g.createElement(Xu, En({}, e, {
      ref: t,
      sideCar: aV
  }))
});
rT.classNames = Xu.classNames;
var lV = function(e) {
      if (typeof document > "u") return null;
      var t = Array.isArray(e) ? e[0] : e;
      return t.ownerDocument.body
  },
  mi = new WeakMap,
  Jl = new WeakMap,
  Xl = {},
  gh = 0,
  sT = function(e) {
      return e && (e.host || sT(e.parentNode))
  },
  cV = function(e, t) {
      return t.map(function(n) {
          if (e.contains(n)) return n;
          var r = sT(n);
          return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null)
      }).filter(function(n) {
          return !!n
      })
  },
  uV = function(e, t, n, r) {
      var s = cV(t, Array.isArray(e) ? e : [e]);
      Xl[n] || (Xl[n] = new WeakMap);
      var i = Xl[n],
          o = [],
          a = new Set,
          l = new Set(s),
          c = function(d) {
              !d || a.has(d) || (a.add(d), c(d.parentNode))
          };
      s.forEach(c);
      var u = function(d) {
          !d || l.has(d) || Array.prototype.forEach.call(d.children, function(h) {
              if (a.has(h)) u(h);
              else try {
                  var f = h.getAttribute(r),
                      x = f !== null && f !== "false",
                      m = (mi.get(h) || 0) + 1,
                      b = (i.get(h) || 0) + 1;
                  mi.set(h, m), i.set(h, b), o.push(h), m === 1 && x && Jl.set(h, !0), b === 1 && h.setAttribute(n, "true"), x || h.setAttribute(r, "true")
              } catch (v) {
                  console.error("aria-hidden: cannot operate on ", h, v)
              }
          })
      };
      return u(t), a.clear(), gh++,
          function() {
              o.forEach(function(d) {
                  var h = mi.get(d) - 1,
                      f = i.get(d) - 1;
                  mi.set(d, h), i.set(d, f), h || (Jl.has(d) || d.removeAttribute(r), Jl.delete(d)), f || d.removeAttribute(n)
              }), gh--, gh || (mi = new WeakMap, mi = new WeakMap, Jl = new WeakMap, Xl = {})
          }
  },
  dV = function(e, t, n) {
      n === void 0 && (n = "data-aria-hidden");
      var r = Array.from(Array.isArray(e) ? e : [e]),
          s = lV(e);
      return s ? (r.push.apply(r, Array.from(s.querySelectorAll("[aria-live]"))), uV(r, s, n, "aria-hidden")) : function() {
          return null
      }
  },
  Zu = "Dialog",
  [iT, oT] = Kt(Zu),
  [hV, yn] = iT(Zu),
  aT = e => {
      const {
          __scopeDialog: t,
          children: n,
          open: r,
          defaultOpen: s,
          onOpenChange: i,
          modal: o = !0
      } = e, a = g.useRef(null), l = g.useRef(null), [c, u] = ss({
          prop: r,
          defaultProp: s ?? !1,
          onChange: i,
          caller: Zu
      });
      return p.jsx(hV, {
          scope: t,
          triggerRef: a,
          contentRef: l,
          contentId: Wi(),
          titleId: Wi(),
          descriptionId: Wi(),
          open: c,
          onOpenChange: u,
          onOpenToggle: g.useCallback(() => u(d => !d), [u]),
          modal: o,
          children: n
      })
  };
aT.displayName = Zu;
var lT = "DialogTrigger",
  cT = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          ...r
      } = e, s = yn(lT, n), i = we(t, s.triggerRef);
      return p.jsx(ae.button, {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": s.open,
          "aria-controls": s.contentId,
          "data-state": Dg(s.open),
          ...r,
          ref: i,
          onClick: ne(e.onClick, s.onOpenToggle)
      })
  });
cT.displayName = lT;
var Og = "DialogPortal",
  [fV, uT] = iT(Og, {
      forceMount: void 0
  }),
  dT = e => {
      const {
          __scopeDialog: t,
          forceMount: n,
          children: r,
          container: s
      } = e, i = yn(Og, t);
      return p.jsx(fV, {
          scope: t,
          forceMount: n,
          children: g.Children.map(r, o => p.jsx(tr, {
              present: n || i.open,
              children: p.jsx(ym, {
                  asChild: !0,
                  container: s,
                  children: o
              })
          }))
      })
  };
dT.displayName = Og;
var du = "DialogOverlay",
  hT = g.forwardRef((e, t) => {
      const n = uT(du, e.__scopeDialog),
          {
              forceMount: r = n.forceMount,
              ...s
          } = e,
          i = yn(du, e.__scopeDialog);
      return i.modal ? p.jsx(tr, {
          present: r || i.open,
          children: p.jsx(mV, {
              ...s,
              ref: t
          })
      }) : null
  });
hT.displayName = du;
var pV = ja("DialogOverlay.RemoveScroll"),
  mV = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          ...r
      } = e, s = yn(du, n);
      return p.jsx(rT, {
          as: pV,
          allowPinchZoom: !0,
          shards: [s.contentRef],
          children: p.jsx(ae.div, {
              "data-state": Dg(s.open),
              ...r,
              ref: t,
              style: {
                  pointerEvents: "auto",
                  ...r.style
              }
          })
      })
  }),
  Qs = "DialogContent",
  fT = g.forwardRef((e, t) => {
      const n = uT(Qs, e.__scopeDialog),
          {
              forceMount: r = n.forceMount,
              ...s
          } = e,
          i = yn(Qs, e.__scopeDialog);
      return p.jsx(tr, {
          present: r || i.open,
          children: i.modal ? p.jsx(gV, {
              ...s,
              ref: t
          }) : p.jsx(yV, {
              ...s,
              ref: t
          })
      })
  });
fT.displayName = Qs;
var gV = g.forwardRef((e, t) => {
      const n = yn(Qs, e.__scopeDialog),
          r = g.useRef(null),
          s = we(t, n.contentRef, r);
      return g.useEffect(() => {
          const i = r.current;
          if (i) return dV(i)
      }, []), p.jsx(pT, {
          ...e,
          ref: s,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: ne(e.onCloseAutoFocus, i => {
              var o;
              i.preventDefault(), (o = n.triggerRef.current) == null || o.focus()
          }),
          onPointerDownOutside: ne(e.onPointerDownOutside, i => {
              const o = i.detail.originalEvent,
                  a = o.button === 0 && o.ctrlKey === !0;
              (o.button === 2 || a) && i.preventDefault()
          }),
          onFocusOutside: ne(e.onFocusOutside, i => i.preventDefault())
      })
  }),
  yV = g.forwardRef((e, t) => {
      const n = yn(Qs, e.__scopeDialog),
          r = g.useRef(!1),
          s = g.useRef(!1);
      return p.jsx(pT, {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: i => {
              var o, a;
              (o = e.onCloseAutoFocus) == null || o.call(e, i), i.defaultPrevented || (r.current || (a = n.triggerRef.current) == null || a.focus(), i.preventDefault()), r.current = !1, s.current = !1
          },
          onInteractOutside: i => {
              var l, c;
              (l = e.onInteractOutside) == null || l.call(e, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (s.current = !0));
              const o = i.target;
              ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault()
          }
      })
  }),
  pT = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          trapFocus: r,
          onOpenAutoFocus: s,
          onCloseAutoFocus: i,
          ...o
      } = e, a = yn(Qs, n), l = g.useRef(null), c = we(t, l);
      return TU(), p.jsxs(p.Fragment, {
          children: [p.jsx(QC, {
              asChild: !0,
              loop: !0,
              trapped: r,
              onMountAutoFocus: s,
              onUnmountAutoFocus: i,
              children: p.jsx(Pu, {
                  role: "dialog",
                  id: a.contentId,
                  "aria-describedby": a.descriptionId,
                  "aria-labelledby": a.titleId,
                  "data-state": Dg(a.open),
                  ...o,
                  ref: c,
                  onDismiss: () => a.onOpenChange(!1)
              })
          }), p.jsxs(p.Fragment, {
              children: [p.jsx(wV, {
                  titleId: a.titleId
              }), p.jsx(bV, {
                  contentRef: l,
                  descriptionId: a.descriptionId
              })]
          })]
      })
  }),
  Ig = "DialogTitle",
  mT = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          ...r
      } = e, s = yn(Ig, n);
      return p.jsx(ae.h2, {
          id: s.titleId,
          ...r,
          ref: t
      })
  });
mT.displayName = Ig;
var gT = "DialogDescription",
  yT = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          ...r
      } = e, s = yn(gT, n);
      return p.jsx(ae.p, {
          id: s.descriptionId,
          ...r,
          ref: t
      })
  });
yT.displayName = gT;
var vT = "DialogClose",
  wT = g.forwardRef((e, t) => {
      const {
          __scopeDialog: n,
          ...r
      } = e, s = yn(vT, n);
      return p.jsx(ae.button, {
          type: "button",
          ...r,
          ref: t,
          onClick: ne(e.onClick, () => s.onOpenChange(!1))
      })
  });
wT.displayName = vT;

function Dg(e) {
  return e ? "open" : "closed"
}
var xT = "DialogTitleWarning",
  [vV, bT] = DP(xT, {
      contentName: Qs,
      titleName: Ig,
      docsSlug: "dialog"
  }),
  wV = ({
      titleId: e
  }) => {
      const t = bT(xT),
          n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
      return g.useEffect(() => {
          e && (document.getElementById(e) || console.error(n))
      }, [n, e]), null
  },
  xV = "DialogDescriptionWarning",
  bV = ({
      contentRef: e,
      descriptionId: t
  }) => {
      const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${bT(xV).contentName}}.`;
      return g.useEffect(() => {
          var i;
          const s = (i = e.current) == null ? void 0 : i.getAttribute("aria-describedby");
          t && s && (document.getElementById(t) || console.warn(r))
      }, [r, e, t]), null
  },
  SV = aT,
  _V = cT,
  EV = dT,
  CV = hT,
  TV = fT,
  kV = mT,
  RV = yT,
  ST = wT,
  _T = "AlertDialog",
  [PV, sB] = Kt(_T, [oT]),
  rr = oT(),
  ET = e => {
      const {
          __scopeAlertDialog: t,
          ...n
      } = e, r = rr(t);
      return p.jsx(SV, {
          ...r,
          ...n,
          modal: !0
      })
  };
ET.displayName = _T;
var AV = "AlertDialogTrigger",
  NV = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, s = rr(n);
      return p.jsx(_V, {
          ...s,
          ...r,
          ref: t
      })
  });
NV.displayName = AV;
var jV = "AlertDialogPortal",
  CT = e => {
      const {
          __scopeAlertDialog: t,
          ...n
      } = e, r = rr(t);
      return p.jsx(EV, {
          ...r,
          ...n
      })
  };
CT.displayName = jV;
var OV = "AlertDialogOverlay",
  TT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, s = rr(n);
      return p.jsx(CV, {
          ...s,
          ...r,
          ref: t
      })
  });
TT.displayName = OV;
var Qi = "AlertDialogContent",
  [IV, DV] = PV(Qi),
  MV = c1("AlertDialogContent"),
  kT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          children: r,
          ...s
      } = e, i = rr(n), o = g.useRef(null), a = we(t, o), l = g.useRef(null);
      return p.jsx(vV, {
          contentName: Qi,
          titleName: RT,
          docsSlug: "alert-dialog",
          children: p.jsx(IV, {
              scope: n,
              cancelRef: l,
              children: p.jsxs(TV, {
                  role: "alertdialog",
                  ...i,
                  ...s,
                  ref: a,
                  onOpenAutoFocus: ne(s.onOpenAutoFocus, c => {
                      var u;
                      c.preventDefault(), (u = l.current) == null || u.focus({
                          preventScroll: !0
                      })
                  }),
                  onPointerDownOutside: c => c.preventDefault(),
                  onInteractOutside: c => c.preventDefault(),
                  children: [p.jsx(MV, {
                      children: r
                  }), p.jsx($V, {
                      contentRef: o
                  })]
              })
          })
      })
  });
kT.displayName = Qi;
var RT = "AlertDialogTitle",
  PT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, s = rr(n);
      return p.jsx(kV, {
          ...s,
          ...r,
          ref: t
      })
  });
PT.displayName = RT;
var AT = "AlertDialogDescription",
  NT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, s = rr(n);
      return p.jsx(RV, {
          ...s,
          ...r,
          ref: t
      })
  });
NT.displayName = AT;
var LV = "AlertDialogAction",
  jT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, s = rr(n);
      return p.jsx(ST, {
          ...s,
          ...r,
          ref: t
      })
  });
jT.displayName = LV;
var OT = "AlertDialogCancel",
  IT = g.forwardRef((e, t) => {
      const {
          __scopeAlertDialog: n,
          ...r
      } = e, {
          cancelRef: s
      } = DV(OT, n), i = rr(n), o = we(t, s);
      return p.jsx(ST, {
          ...i,
          ...r,
          ref: o
      })
  });
IT.displayName = OT;
var $V = ({
      contentRef: e
  }) => {
      const t = `\`${Qi}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${Qi}\` by passing a \`${AT}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${Qi}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
      return g.useEffect(() => {
          var r;
          document.getElementById((r = e.current) == null ? void 0 : r.getAttribute("aria-describedby")) || console.warn(t)
      }, [t, e]), null
  },
  FV = ET,
  UV = CT,
  DT = TT,
  MT = kT,
  LT = jT,
  $T = IT,
  FT = PT,
  UT = NT;
const VV = FV,
  BV = UV,
  VT = g.forwardRef(({
      className: e,
      ...t
  }, n) => p.jsx(DT, {
      className: ee("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", e),
      ...t,
      ref: n
  }));
VT.displayName = DT.displayName;
const BT = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsxs(BV, {
  children: [p.jsx(VT, {}), p.jsx(MT, {
      ref: n,
      className: ee("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", e),
      ...t
  })]
}));
BT.displayName = MT.displayName;
const zT = ({
  className: e,
  ...t
}) => p.jsx("div", {
  className: ee("flex flex-col space-y-2 text-center sm:text-left", e),
  ...t
});
zT.displayName = "AlertDialogHeader";
const WT = ({
  className: e,
  ...t
}) => p.jsx("div", {
  className: ee("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", e),
  ...t
});
WT.displayName = "AlertDialogFooter";
const HT = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(FT, {
  ref: n,
  className: ee("text-lg font-semibold", e),
  ...t
}));
HT.displayName = FT.displayName;
const KT = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(UT, {
  ref: n,
  className: ee("text-sm text-muted-foreground", e),
  ...t
}));
KT.displayName = UT.displayName;
const qT = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx(LT, {
  ref: n,
  className: ee(yg(), e),
  ...t
}));
qT.displayName = LT.displayName;
const GT = g.forwardRef(({
  className: e,
  ...t
}, n) => p.jsx($T, {
  ref: n,
  className: ee(yg({
      variant: "outline"
  }), "mt-2 sm:mt-0", e),
  ...t
}));
GT.displayName = $T.displayName;

function zV() {
  const {
      data: e,
      isLoading: t
  } = X5(), n = eU(), {
      toast: r
  } = Ru(), [s, i] = g.useState(null);
  if (t) return p.jsx("div", {
      className: "min-h-screen flex items-center justify-center bg-background",
      children: p.jsx("div", {
          className: "animate-pulse text-muted-foreground",
          children: "Cargando..."
      })
  });
  const o = {
          total: (e == null ? void 0 : e.length) || 0,
          confirmed: (e == null ? void 0 : e.filter(c => c.attendance === "yes").length) || 0,
          declined: (e == null ? void 0 : e.filter(c => c.attendance === "no").length) || 0,
          pending: (e == null ? void 0 : e.filter(c => c.attendance === "pending" || c.attendance === null).length) || 0,
          totalGuests: (e == null ? void 0 : e.filter(c => c.attendance === "yes").reduce((c, u) => c + (u.guest_count || 1), 0)) || 0
      },
      a = async () => {
          if (s) try {
              await n.mutateAsync(s.id), r({
                  title: "Invitado eliminado",
                  description: `${s.full_name} ha sido eliminado de la lista.`
              }), i(null)
          } catch {
              r({
                  title: "Error",
                  description: "No se pudo eliminar el invitado. Intntalo de nuevo.",
                  variant: "destructive"
              })
          }
      }, l = () => {
          if (!e) return;
          const c = ["Nombre", "Email", "Telfono", "Asistencia", "Invitados", "Alergias", "Mensaje", "Fecha respuesta"],
              u = e.map(m => [m.full_name, m.email || "", m.phone || "", m.attendance || "pending", (m.guest_count || 1).toString(), m.dietary_requirements || "", m.message || "", m.responded_at || ""]),
              d = [c, ...u].map(m => m.map(b => `"${b}"`).join(",")).join(`
`),
              h = new Blob([d], {
                  type: "text/csv"
              }),
              f = URL.createObjectURL(h),
              x = document.createElement("a");
          x.href = f, x.download = "invitados-boda.csv", x.click()
      };
  return p.jsxs("div", {
      className: "min-h-screen bg-background",
      children: [p.jsx("header", {
          className: "border-b border-border bg-card",
          children: p.jsxs("div", {
              className: "max-w-7xl mx-auto px-6 py-4 flex items-center justify-between",
              children: [p.jsx("h1", {
                  className: "font-display text-2xl",
                  children: "Panel de Administracin"
              }), p.jsx(j2, {
                  to: "/",
                  children: p.jsxs(Nn, {
                      variant: "outline",
                      size: "sm",
                      className: "gap-2",
                      children: [p.jsx(BA, {
                          className: "w-4 h-4"
                      }), "Ver invitacin"]
                  })
              })]
          })
      }), p.jsxs("main", {
          className: "max-w-7xl mx-auto px-6 py-8",
          children: [p.jsxs(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              animate: {
                  opacity: 1,
                  y: 0
              },
              className: "grid grid-cols-2 md:grid-cols-5 gap-4 mb-8",
              children: [p.jsxs(gs, {
                  children: [p.jsx(ys, {
                      className: "pb-2",
                      children: p.jsx(vs, {
                          className: "text-sm font-normal text-muted-foreground",
                          children: "Total invitados"
                      })
                  }), p.jsx(ws, {
                      children: p.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [p.jsx(iv, {
                              className: "w-5 h-5 text-primary"
                          }), p.jsx("span", {
                              className: "admin-stat",
                              children: o.total
                          })]
                      })
                  })]
              }), p.jsxs(gs, {
                  children: [p.jsx(ys, {
                      className: "pb-2",
                      children: p.jsx(vs, {
                          className: "text-sm font-normal text-muted-foreground",
                          children: "Confirmados"
                      })
                  }), p.jsx(ws, {
                      children: p.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [p.jsx(OA, {
                              className: "w-5 h-5 text-green-600"
                          }), p.jsx("span", {
                              className: "admin-stat text-green-600",
                              children: o.confirmed
                          })]
                      })
                  })]
              }), p.jsxs(gs, {
                  children: [p.jsx(ys, {
                      className: "pb-2",
                      children: p.jsx(vs, {
                          className: "text-sm font-normal text-muted-foreground",
                          children: "No asisten"
                      })
                  }), p.jsx(ws, {
                      children: p.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [p.jsx(DA, {
                              className: "w-5 h-5 text-red-500"
                          }), p.jsx("span", {
                              className: "admin-stat text-red-500",
                              children: o.declined
                          })]
                      })
                  })]
              }), p.jsxs(gs, {
                  children: [p.jsx(ys, {
                      className: "pb-2",
                      children: p.jsx(vs, {
                          className: "text-sm font-normal text-muted-foreground",
                          children: "Pendientes"
                      })
                  }), p.jsx(ws, {
                      children: p.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [p.jsx(M1, {
                              className: "w-5 h-5 text-yellow-600"
                          }), p.jsx("span", {
                              className: "admin-stat text-yellow-600",
                              children: o.pending
                          })]
                      })
                  })]
              }), p.jsxs(gs, {
                  children: [p.jsx(ys, {
                      className: "pb-2",
                      children: p.jsx(vs, {
                          className: "text-sm font-normal text-muted-foreground",
                          children: "Total personas"
                      })
                  }), p.jsx(ws, {
                      children: p.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [p.jsx(iv, {
                              className: "w-5 h-5 text-primary"
                          }), p.jsx("span", {
                              className: "admin-stat",
                              children: o.totalGuests
                          })]
                      })
                  })]
              })]
          }), p.jsx(Y.div, {
              initial: {
                  opacity: 0,
                  y: 20
              },
              animate: {
                  opacity: 1,
                  y: 0
              },
              transition: {
                  delay: .2
              },
              children: p.jsxs(gs, {
                  children: [p.jsxs(ys, {
                      className: "flex flex-row items-center justify-between",
                      children: [p.jsx(vs, {
                          children: "Lista de invitados"
                      }), p.jsxs(Nn, {
                          variant: "outline",
                          size: "sm",
                          onClick: l,
                          className: "gap-2",
                          children: [p.jsx(LA, {
                              className: "w-4 h-4"
                          }), "Exportar CSV"]
                      })]
                  }), p.jsx(ws, {
                      children: e && e.length > 0 ? p.jsx("div", {
                          className: "overflow-x-auto",
                          children: p.jsxs(KC, {
                              children: [p.jsx(qC, {
                                  children: p.jsxs(wp, {
                                      children: [p.jsx(mr, {
                                          children: "Nombre"
                                      }), p.jsx(mr, {
                                          children: "Estado"
                                      }), p.jsx(mr, {
                                          children: "Invitados"
                                      }), p.jsx(mr, {
                                          children: "Alergias"
                                      }), p.jsx(mr, {
                                          children: "Mensaje"
                                      }), p.jsx(mr, {
                                          children: "Fecha"
                                      }), p.jsx(mr, {
                                          className: "w-16"
                                      })]
                                  })
                              }), p.jsx(GC, {
                                  children: e.map(c => p.jsxs(wp, {
                                      children: [p.jsxs(gr, {
                                          className: "font-medium",
                                          children: [c.full_name, c.email && p.jsx("span", {
                                              className: "block text-xs text-muted-foreground",
                                              children: c.email
                                          })]
                                      }), p.jsx(gr, {
                                          children: p.jsx(vU, {
                                              variant: c.attendance === "yes" ? "default" : c.attendance === "no" ? "destructive" : "secondary",
                                              children: c.attendance === "yes" ? "Confirmado" : c.attendance === "no" ? "No asiste" : "Pendiente"
                                          })
                                      }), p.jsx(gr, {
                                          children: c.guest_count || 1
                                      }), p.jsx(gr, {
                                          className: "max-w-32 truncate",
                                          children: c.dietary_requirements || "-"
                                      }), p.jsx(gr, {
                                          className: "max-w-48 truncate",
                                          children: c.message || "-"
                                      }), p.jsx(gr, {
                                          className: "text-sm text-muted-foreground",
                                          children: c.responded_at ? new Date(c.responded_at).toLocaleDateString("es-ES") : "-"
                                      }), p.jsx(gr, {
                                          children: p.jsx(Nn, {
                                              variant: "ghost",
                                              size: "icon",
                                              className: "h-8 w-8 text-muted-foreground hover:text-destructive",
                                              onClick: () => i(c),
                                              children: p.jsx(GA, {
                                                  className: "w-4 h-4"
                                              })
                                          })
                                      })]
                                  }, c.id))
                              })]
                          })
                      }) : p.jsx("p", {
                          className: "text-center py-8 text-muted-foreground",
                          children: "An no hay confirmaciones de asistencia"
                      })
                  })]
              })
          })]
      }), p.jsx(VV, {
          open: !!s,
          onOpenChange: c => !c && i(null),
          children: p.jsxs(BT, {
              children: [p.jsxs(zT, {
                  children: [p.jsx(HT, {
                      children: "Eliminar invitado?"
                  }), p.jsxs(KT, {
                      children: ["Ests seguro de que quieres eliminar a ", p.jsx("strong", {
                          children: s == null ? void 0 : s.full_name
                      }), " de la lista de invitados? Esta accin no se puede deshacer."]
                  })]
              }), p.jsxs(WT, {
                  children: [p.jsx(GT, {
                      children: "Cancelar"
                  }), p.jsx(qT, {
                      onClick: a,
                      className: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                      children: "Eliminar"
                  })]
              })]
          })
      })]
  })
}
const WV = () => {
      const e = ll();
      return g.useEffect(() => {
          console.error("404 Error: User attempted to access non-existent route:", e.pathname)
      }, [e.pathname]), p.jsx("div", {
          className: "flex min-h-screen items-center justify-center bg-muted",
          children: p.jsxs("div", {
              className: "text-center",
              children: [p.jsx("h1", {
                  className: "mb-4 text-4xl font-bold",
                  children: "404"
              }), p.jsx("p", {
                  className: "mb-4 text-xl text-muted-foreground",
                  children: "Oops! Page not found"
              }), p.jsx("a", {
                  href: "/",
                  className: "text-primary underline hover:text-primary/90",
                  children: "Return to Home"
              })]
          })
      })
  },
  HV = () => {
      const [e] = g.useState(() => new yI);
      return p.jsx(SI, {
          client: e,
          children: p.jsxs(eI, {
              children: [p.jsx(MN, {}), p.jsx(pj, {}), p.jsx(P2, {
                  children: p.jsxs(S2, {
                      children: [p.jsx(Yo, {
                          path: "/",
                          element: p.jsx(uU, {})
                      }), p.jsx(Yo, {
                          path: "/admin",
                          element: p.jsx(hU, {})
                      }), p.jsx(Yo, {
                          path: "/admin/dashboard",
                          element: p.jsx(zV, {})
                      }), p.jsx(Yo, {
                          path: "*",
                          element: p.jsx(WV, {})
                      })]
                  })
              })]
          })
      })
  };
o1(document.getElementById("root")).render(p.jsx(HV, {}));